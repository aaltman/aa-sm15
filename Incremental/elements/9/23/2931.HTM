<H2><B><FONT class=extract>1. Purpose of polling, SSE, and WebSockets</FONT></B></H2>
<P><FONT class=extract><SPAN style="FONT-WEIGHT: 400">The internet is built on the HTTP standard for communicating data between web browsers and web servers. The client, in most cases a web browser, makes an HTTP request to the server, which sends back the appropriate response. This roundtrip is what happens when you type an address like '</SPAN><SPAN style="FONT-WEIGHT: 400"><A href="http://www.example.com/">http://www.example.com</A>'</SPAN><SPAN style="FONT-WEIGHT: 400">&nbsp;into your browser, and you get a web page back.</SPAN></FONT></P>
<P><SPAN style="FONT-WEIGHT: 400"><FONT class=extract>The HTTP standard is widely supported and very functional. But when your application needs to transmit continuous information streams or real-time updates to clients, like a collaborative document editor that shows changes in real time. In cases like this, having to repeatedly make regular HTTP requests will slow things down. </FONT></SPAN></P>
<P><SPAN style="FONT-WEIGHT: 400"><FONT class=extract>That&#8217;s where polling, WebSockets, and&nbsp;SSE come in. These are three protocols that specifically focus on speed and memory efficiency for data streams. Which approach you&#8217;d want to use in a system depends on the use case. So, let&#8217;s&nbsp; go over how each of these protocols work, and when to use them.</FONT></SPAN></P>
<H2><A name=polling></A><B><FONT class=extract>2. Polling</FONT></B></H2>
<H3><B><FONT class=extract>2.1 Short Polling</FONT></B></H3>
<P><SPAN style="FONT-WEIGHT: 400"><FONT class=extract>Short polling is the original polling protocol for clients to get regular information updates from a server. The steps of short polling are:</FONT></SPAN></P>
<UL>
<LI style="FONT-WEIGHT: 400"><FONT class=extract><SPAN style="FONT-WEIGHT: 400">Client sends Server an HTTP request for new information.</SPAN> </FONT>
<LI style="FONT-WEIGHT: 400"><FONT class=extract><SPAN style="FONT-WEIGHT: 400">Server responds with new information, or no information.</SPAN> </FONT>
<LI style="FONT-WEIGHT: 400"><SPAN style="FONT-WEIGHT: 400"><FONT class=extract>Client repeats the request at a set interval (e.g. 2s)</FONT></SPAN></LI></UL>
<P><SPAN style="FONT-WEIGHT: 400"><FONT class=extract>The advantages of Short polling are that it&#8217;s very simple and widely supported because it&#8217;s part of the HTTP. The downside of short polling is that it has a lot of request overhead from both sides: the client has to constantly make new requests, and the server has to handle them whether or not there&#8217;s new information. In practice if you want a polling connection, long polling is preferred to short polling.&nbsp;</FONT></SPAN></P>
<P><SPAN style="FONT-WEIGHT: 400"><FONT class=extract><IMG alt="short polling" src="https://d3no4ktch0fdq4.cloudfront.net/public/CACHE/images/blog-articles/content-images/Diagram_19_2x_25a5182a-3701-4ca0-b71d-a30df791da28_1024x1024/ba229342f3dc2f571025c2a6ec7c6ff3.webp" width=660 height=544 loading="lazy"></FONT></SPAN></P>
<H3><B><FONT class=extract>2.2 Long Polling</FONT></B></H3>
<P><SPAN style="FONT-WEIGHT: 400"><FONT class=extract>Long polling is a more efficient version of short polling. The steps of long polling are:</FONT></SPAN></P>
<UL>
<LI style="FONT-WEIGHT: 400"><FONT class=extract><SPAN style="FONT-WEIGHT: 400">Client sends Server and HTTP request for new information</SPAN> </FONT>
<LI style="FONT-WEIGHT: 400"><FONT class=extract><SPAN style="FONT-WEIGHT: 400">Server waits until there&#8217;s new information to respond (a &#8220;hanging&#8221; response)</SPAN> </FONT>
<LI style="FONT-WEIGHT: 400"><SPAN style="FONT-WEIGHT: 400"><FONT class=extract>Client repeats the request as soon as it gets the previous response back</FONT></SPAN></LI></UL>
<P><FONT class=extract><IMG alt="long polling" src="https://d3no4ktch0fdq4.cloudfront.net/public/CACHE/images/blog-articles/content-images/Diagram_22_2x_5b96c5a6-efa9-4c4d-97fb-f3c6f09e6ac9_1024x1024/fa09c27841d16a7f0ab3715a8168e30d.webp" width=660 height=544 loading="lazy"></FONT></P>
<P><SPAN style="FONT-WEIGHT: 400"><FONT class=extract>Long polling cuts down the number of HTTP requests necessary to transmit the same amount of data to the client. The server has to be able to &#8220;hold&#8221; unfulfilled client requests, and handle the case where it gets new information to send, but the client hasn&#8217;t sent a new request yet. </FONT></SPAN></P>
<P><SPAN style="FONT-WEIGHT: 400"><FONT class=extract>The benefits of long polling are that it&#8217;s part of the HTTP protocol, so it&#8217;s widely supported, and it produces less traffic than short polling because it takes fewer requests. In order to support this, the server-side implementation is slightly more complex than short polling, but not nearly as complex as the other two protocols we&#8217;ll look at: Websockets and Server Sent Events. </FONT></SPAN></P>
<P><SPAN style="FONT-WEIGHT: 400"><FONT class=extract>There are a few drawbacks to long polling. In some implementations holding unfulfilled requests can take more server resources than short polling, and limit the overall number of possible connections. Also if there are multiple open requests from the same client, message ordering can&#8217;t be guaranteed, and messages can get lost. </FONT></SPAN></P>
<P><SPAN style="FONT-WEIGHT: 400"><FONT class=extract>Overall, long polling is a good strategy when you need a simple implementation for regularly updating clients with new information, like updating a dashboard every minute with new data. It won&#8217;t handle high volume data streams, and is still slowed down by the overhead of repeatedly reestablishing a connection between server and client.&nbsp;</FONT></SPAN></P>
<H2><A name=SSEs></A><B><FONT class=extract>3. Server Sent Events</FONT></B></H2>
<P><SPAN style="FONT-WEIGHT: 400"><FONT class=extract>Server Sent Events provide a one-way connection for a server to push new data to a client, without reestablishing a connection every time. For example a social media app could use SSE to push new posts to a user feed as soon as they&#8217;re available. SSE connections follow the </FONT></SPAN><A href="https://developer.mozilla.org/en-US/docs/Web/API/EventSource"><SPAN style="FONT-WEIGHT: 400"><FONT class=extract>EventSource</FONT></SPAN></A><SPAN style="FONT-WEIGHT: 400"><FONT class=extract> interface, which uses HTTP to make the underlying communications.</FONT></SPAN></P>
<P><SPAN style="FONT-WEIGHT: 400"><FONT class=extract>At a high level, the steps of SSE are:</FONT></SPAN></P>
<UL>
<LI style="FONT-WEIGHT: 400"><FONT class=extract><SPAN style="FONT-WEIGHT: 400">Client creates a new EventSource object targeting the server</SPAN> </FONT>
<LI style="FONT-WEIGHT: 400"><FONT class=extract><SPAN style="FONT-WEIGHT: 400">Server registers SSE connection</SPAN> </FONT>
<LI style="FONT-WEIGHT: 400"><FONT class=extract><SPAN style="FONT-WEIGHT: 400">Server sends new data to the client</SPAN> </FONT>
<LI style="FONT-WEIGHT: 400"><FONT class=extract><SPAN style="FONT-WEIGHT: 400">Client receives messages with EventSource handlers</SPAN> </FONT>
<LI style="FONT-WEIGHT: 400"><SPAN style="FONT-WEIGHT: 400"><FONT class=extract>Either side closes the connection</FONT></SPAN></LI></UL>
<DIV><FONT class=extract><IMG alt="server sent events" src="https://d3no4ktch0fdq4.cloudfront.net/public/CACHE/images/blog-articles/content-images/Diagram_20_2x_0035a022-b7e7-41a0-93cf-8a2d90c4a5ab_1024x1024/7d877930655c33c7d6afd99a4ac2e08d.webp" width=660 height=544 loading="lazy"></FONT></DIV>
<P><SPAN style="FONT-WEIGHT: 400"><FONT class=extract>The main benefit of SSEs is it provides an efficient one directional data stream where the client and server don&#8217;t need to constantly reestablish the connection. And SSE is fairly straightforward to implement, unlike websockets - EventSource is supported by all the browsers except IE. Luckly, IE support is a common issue so there are libraries for supporting it with polyfills. </FONT></SPAN></P>
<P><SPAN style="FONT-WEIGHT: 400"><FONT class=extract>There are a couple of drawbacks to SSEs. If your service outgrows the one-way connection model you&#8217;ll just have to switch to a different protocol like WebSockets. SSEs over HTTP (instead of HTTP/2) are also limited to 6 connections per browser, so if a user opens multiple tabs of your website the SSE won&#8217;t work after the first 6 tabs. </FONT></SPAN></P>
<P><SPAN style="FONT-WEIGHT: 400"><FONT class=extract>Overall, SSEs are great when you need a simple implementation for real-time data streams where the client doesn&#8217;t need to communicate much with the server, just receive updates. But if you expect your service to need more robust functionality like bi-directional communication, you should consider investing in an implementation of WebSockets.&nbsp;</FONT></SPAN></P>
<H2><A name=websockets></A><B><FONT class=extract>4. WebSockets</FONT></B></H2>
<P><SPAN style="FONT-WEIGHT: 400"><FONT class=extract>WebSockets is a two-way message passing protocol based on TCP (the protocol at Layer 4 of the OSI networking model). WebSockets are faster for data transmission than HTTP because it has less protocol overhead and operates at a lower level in the network stack. At a high level, the steps of a websocket connection are:</FONT></SPAN></P>
<UL>
<LI style="FONT-WEIGHT: 400"><FONT class=extract><SPAN style="FONT-WEIGHT: 400">Client and Server establish a connection over HTTP and then &#8220;upgraded&#8221; using the WebSockets handshake</SPAN> </FONT>
<LI style="FONT-WEIGHT: 400"><FONT class=extract><SPAN style="FONT-WEIGHT: 400">WebSockets TCP messages are transmitted in both directions over port 443 (or 80 if it&#8217;s not TLS encrypted)&nbsp;</SPAN> </FONT>
<LI style="FONT-WEIGHT: 400"><SPAN style="FONT-WEIGHT: 400"><FONT class=extract>Either side closes the connection</FONT></SPAN></LI></UL>
<P><SPAN style="FONT-WEIGHT: 400"><FONT class=extract><IMG alt=WebSockets src="https://d3no4ktch0fdq4.cloudfront.net/public/CACHE/images/blog-articles/content-images/Diagram_21_2x_31d27e31-adb5-4471-a29e-db314d7a870d_1024x1024/ad4488834e1128fad2582db10c714181.webp" width=660 height=544 loading="lazy"></FONT></SPAN></P>
<P><FONT class=extract><SPAN style="FONT-WEIGHT: 400">The main advantage of WebSockets is speed: the client and server don&#8217;t have to find and reestablish their connection with each other </SPAN><I><SPAN style="FONT-WEIGHT: 400">every time</SPAN></I><SPAN style="FONT-WEIGHT: 400"> a message is sent. Once the WebSockets connection is established, data can flow immediately and securely in either direction. TCP ensures that the messages will always arrive in order. </SPAN></FONT></P>
<P><SPAN style="FONT-WEIGHT: 400"><FONT class=extract>The main downside of WebSockets is it takes a good amount of initial developer work to implement. You&#8217;ll have to write your own code to support some things like automatically reconnecting. Also, since WebSockets functions over ports it can be blocked by firewalls in big institutions. </FONT></SPAN></P>
<P><SPAN style="FONT-WEIGHT: 400"><FONT class=extract>An example where WebSockets is really useful is multiplayer online gaming, where the high-quality graphics of the world need to be transmitted to distributed users with real-time state updates and tight synchronization. </FONT></SPAN></P>
<P><SPAN style="FONT-WEIGHT: 400"><FONT class=extract>Overall, WebSockets are a good choice if you know you need a fast, high-quality, bi-directional connection. But it should only be used if Polling or SSE don&#8217;t fit because it adds substantial complexity to the system and takes more upfront investment to implement.</FONT></SPAN></P>
<H2><A name=example></A><B><FONT class=extract>5. Example polling, server sent events, and WebSockets system design questions</FONT></B></H2>
<P><SPAN style="FONT-WEIGHT: 400"><FONT class=extract>The questions asked in system design interviews tend to begin with a broad problem or goal, so it&#8217;s unlikely that you&#8217;ll get an interview question entirely about polling, SSE, and WebSockets. </FONT></SPAN></P>
<P><SPAN style="FONT-WEIGHT: 400"><FONT class=extract>However, you may be asked to solve a problem where these topics will be relevant. As a result, what you really need to know is WHEN (or IF) you should bring them up and how you should approach them.</FONT></SPAN></P>
<P><SPAN style="FONT-WEIGHT: 400"><FONT class=extract>To help you with this, we&#8217;ve compiled the below list of sample system design interview questions,&nbsp;where these topics&nbsp;are relevant.&nbsp;</FONT></SPAN></P>
<UL>
<LI style="FONT-WEIGHT: 400"><SPAN style="FONT-WEIGHT: 400"><FONT class=extract>Design support for long running jobs (</FONT></SPAN><A href="https://blog.usejournal.com/system-design-interview-prep-how-to-handle-long-running-job-asynchronously-with-long-polling-34d8b2a890e1"><SPAN style="FONT-WEIGHT: 400"><FONT class=extract>Read the answer</FONT></SPAN></A><FONT class=extract><SPAN style="FONT-WEIGHT: 400">)</SPAN> </FONT>
<LI style="FONT-WEIGHT: 400"><SPAN style="FONT-WEIGHT: 400"><FONT class=extract>Design Twitter (</FONT></SPAN><A href="https://www.geeksforgeeks.org/design-twitter-a-system-design-interview-question/"><SPAN style="FONT-WEIGHT: 400"><FONT class=extract>Read the answer</FONT></SPAN></A><FONT class=extract><SPAN style="FONT-WEIGHT: 400">)</SPAN> </FONT>
<LI style="FONT-WEIGHT: 400"><SPAN style="FONT-WEIGHT: 400"><FONT class=extract>Design Instagram (</FONT></SPAN><A href="https://www.educative.io/courses/grokking-the-system-design-interview/m2yDVZnQ8lG"><SPAN style="FONT-WEIGHT: 400"><FONT class=extract>Read the answer</FONT></SPAN></A><FONT class=extract><SPAN style="FONT-WEIGHT: 400">)&nbsp;</SPAN> </FONT>
<LI style="FONT-WEIGHT: 400"><SPAN style="FONT-WEIGHT: 400"><FONT class=extract>Design Netflix (</FONT></SPAN><A href="https://medium.com/@narengowda/netflix-system-design-dbec30fede8d"><SPAN style="FONT-WEIGHT: 400"><FONT class=extract>Read the answer</FONT></SPAN></A><SPAN style="FONT-WEIGHT: 400"><FONT class=extract>)</FONT></SPAN></LI></UL>
<H2><A name=prep></A><B><FONT class=extract>6. System design interview preparation</FONT></B></H2>
<P><SPAN style="FONT-WEIGHT: 400"><FONT class=extract>Polling, SSE, and WebSockets are important to consider when designing a system. But to succeed on system design interviews, you&#8217;ll also need to familiarize yourself with a few other concepts. And you&#8217;ll need to practice how you communicate your answers.</FONT></SPAN></P>
<P><SPAN style="FONT-WEIGHT: 400"><FONT class=extract>It&#8217;s best to take a systematic approach to make the most of your practice time, and we recommend the steps below.&nbsp;For extra tips, take a look at our article:&nbsp;</FONT><A title="system design interview tips from ex-interviewers" href="https://igotanoffer.com/blogs/tech/system-design-interview-tips"><FONT class=extract>19 system design interview tips from FAANG ex-interviewers</FONT></A><FONT class=extract>.</FONT></SPAN></P>
<P><SPAN style="FONT-WEIGHT: 400"><FONT class=extract>Otherwise, you can prepare by following the steps below.</FONT></SPAN>