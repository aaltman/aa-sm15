<b> : </b><STRONG>3.1 LRU - least recently used</STRONG></H3>
<P><SPAN style="FONT-WEIGHT: 400">In an LRU replacement policy, the entry in the cache that is the oldest will be freed. LRU performs well and is fairly simple to understand, so it&#8217;s a good default choice of replacement policy. </SPAN></P>
<P><SPAN style="FONT-WEIGHT: 400">To implement LRU the cache keeps track of recency with </SPAN><STRONG>aging bits</STRONG> that need to get updated on every entry every time data is accessed. Although LRU makes efficient decisions about what data to remove, the computational overhead of keeping track of the aging bits leads to approximations like the clock replacement policy.&nbsp;</P>
<P>A clock replacement policy approximates LRU with a clock pointer that cycles sequentially through the cache looking for an available entry. As the pointer passes an in-use entry, it marks the <STRONG>stale bit</STRONG>, which gets reset whenever the entry is accessed again. If the clock pointer ever finds an entry with a positive stale bit, it means the cached data hasn&#8217;t been accessed for an entire cycle of the clock, so the entry is freed and used as the next available entry.&nbsp;</P>
<P><SPAN style="FONT-WEIGHT: 400">LRU-based algorithms are well suited for applications where the oldest data are the least likely to be used again. For example, a local news outlet where users mostly access today&#8217;s news could use a CDN with LRU replacement to make today&#8217;s news faster to load. After that day has passed, it becomes less likely that the news article is accessed again, so it can be freed from the cache to make space for the next day&#8217;s news.&nbsp;</SPAN>