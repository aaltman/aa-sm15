<b> : </b><SPAN style="FONT-WEIGHT: 400"><A name=writing-policies></A><STRONG>2. Cache writing policies</STRONG></SPAN></H2>
<P>There are interesting design tradeoffs between the speed of writing and the consistency with persisted data. A cache is made of copies of data, and is thus transient storage, so when writing we need to decide when to write to the cache and when to write to the primary data store.</P>
<P>A <STRONG>write-behind cache</STRONG> writes first to the cache, and then to the primary datastore. This can either mean that the primary data store is updated almost immediately, or that the data is not persisted until the cache entry is replaced, in which case it&#8217;s tagged with a <STRONG>dirty bit</STRONG> to keep track that the data is out of sync.</P>
<P>It is possible that at the moment a write-behind cache fails that some data has not been persisted, and is lost. Ultimately writes will be fastest in a write-behind cache, and it can be a reasonable choice if the cached data tolerates possible data loss.</P>
<P>In a&nbsp;<STRONG>write-around cache</STRONG> design, the application writes directly to the primary datastore, and the cache checks with the primary datastore to keep the cached data valid. If the application is accessing the newest data, the cache might be behind, but the write doesn&#8217;t have to wait on two systems being updated and the primary datastore is always up to date.&nbsp;</P>
<P>Finally, a&nbsp;<STRONG>write-through cache</STRONG> updates both the cache data and the backing data at the same time. If the cache layer fails, then the update isn&#8217;t lost because it&#8217;s been persisted. In exchange, the write takes longer to succeed because it needs to update the slower memory.&nbsp;</P>
<P><IMG alt="Cache writing policies" src="https://d3no4ktch0fdq4.cloudfront.net/public/CACHE/images/blog-articles/content-images/Diagram_4_2x_1_1024x1024/36bccfda8bccee11deca1341630c2c4a.webp" width=660 height=680 loading="lazy"></P>
<P>A cache has a limited amount of available memory, so at some point we need to clear out the old data and make space for more relevant data. The choice of which data to remove is made by a cache replacement policy.