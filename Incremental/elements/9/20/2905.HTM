<b> : </b><B>3.1 Locking</B></H3>
<P><SPAN style="FONT-WEIGHT: 400">A locking model ensures that concurrent operations on a shared resource don't conflict by only allowing changes from one node at a time. With</SPAN><B> optimistic locking </B><SPAN style="FONT-WEIGHT: 400">a node will read a resource and its version id, make changes, and then before updating make sure that the version id is the same. If the id is different this means the resource has been updated since the node first read it. Going forward with the intended changes based on the old id would lose the other changes, so&nbsp; the node needs to try again.</SPAN></P>
<P><SPAN style="FONT-WEIGHT: 400">In </SPAN><B>pessimistic locking</B><SPAN style="FONT-WEIGHT: 400"> a node locks the resource, makes changes, and then unlocks the resource. If another node tries to initiate a change while the resource is locked, it will fail and try again later. Pessimistic locking is more rigorous, but can be hard to implement and bugs can cause </SPAN><B>deadlocks</B><SPAN style="FONT-WEIGHT: 400"> that stop a system from functioning.</SPAN></P>
<P><SPAN style="FONT-WEIGHT: 400">These locking patterns are named for use cases. Optimistic locking is useful when you can make the "optimistic" assumption that another node won't change the resource out from under the operation. And pessimistic locking is useful when you can make the "pessimistic" assumption that there will be contention for the resource.</SPAN>