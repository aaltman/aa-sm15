<H2><B><FONT class=extract>1. Sharding Basics</FONT></B></H2>
<P><SPAN style="FONT-WEIGHT: 400"><FONT class=extract>Modern software services increasingly collect and use more data than can fit on a single machine. The capacity of the database server can be increased, but eventually runs into a physical limit. The alternative is splitting up data across a cluster of database servers.&nbsp; </FONT></SPAN></P>
<P><FONT class=extract><B>Database sharding</B><SPAN style="FONT-WEIGHT: 400"> splits up data in a particular way so that data access patterns can remain as efficient as possible. A</SPAN><B> shard</B><SPAN style="FONT-WEIGHT: 400"> is a </SPAN><B>horizontal partition</B><SPAN style="FONT-WEIGHT: 400">, meaning the database table is split up by drawing a horizontal line between rows. This is in contrast to a </SPAN><B>vertical partition</B><SPAN style="FONT-WEIGHT: 400">, where partitions are made between columns. </SPAN></FONT></P>
<P><SPAN style="FONT-WEIGHT: 400"><FONT class=extract><IMG alt="Horizontal and vertical partition for sharding" src="https://d3no4ktch0fdq4.cloudfront.net/public/CACHE/images/blog-articles/content-images/Diagram_13_2x_bced9a00-2ff9-45fa-a633-9602824da786_1024x1024/b266575031e75662c59602c6f40df0d5.webp" width=660 height=730 loading="lazy"></FONT></SPAN></P>
<P><SPAN style="FONT-WEIGHT: 400"><FONT class=extract>The goal of sharding is to increase database capacity, but another effect is that the database can handle more traffic because any one server in the cluster only has to respond to a fraction of the total requests.</FONT></SPAN></P>
<P><SPAN style="FONT-WEIGHT: 400"><FONT class=extract>There are a couple of key features a sharded architecture needs to be efficient. We&#8217;ll go over how it&#8217;s implemented with shard keys, and the importance of denormalizing data. Then we&#8217;ll cover when to use and when not to use sharding. Let&#8217;s jump in. </FONT></SPAN></P>
<H3><FONT class=extract><STRONG>1.1 How sharding works</STRONG><BR>&nbsp;</FONT></H3>
<P><FONT class=extract><SPAN style="FONT-WEIGHT: 400">Each row is assigned a </SPAN><B>shard key</B><SPAN style="FONT-WEIGHT: 400"> that maps it to the </SPAN><B>logical shard</B><SPAN style="FONT-WEIGHT: 400"> it can be found on. More than one logical shard can be located on the same </SPAN><B>physical shard</B><SPAN style="FONT-WEIGHT: 400">, but a logical shard can&#8217;t be split between physical shards. </SPAN></FONT></P>
<P><FONT class=extract><SPAN style="FONT-WEIGHT: 400">When creating a sharded architecture, the goal is to have many small shards to create an even distribution of data across the nodes. This prevents </SPAN><B>hotspots</B><SPAN style="FONT-WEIGHT: 400"> from overwhelming any one of the nodes and produces fast response times for all nodes. </SPAN></FONT></P>
<P><SPAN style="FONT-WEIGHT: 400"><FONT class=extract>Sharding can be implemented either at the application level or the database level. At this point, most databases support sharded architectures, with the notable exception of PostgresQL, one of the top relational databases.</FONT></SPAN></P>
<H3><STRONG><FONT class=extract>1.2 Denormalization</FONT></STRONG></H3>
<P><SPAN style="FONT-WEIGHT: 400"><FONT class=extract>When implementing a sharded database architecture, you need to take special consideration about how the relational model spans shards. Relational data models are optimized for data with many cross-table relationships. If shards aren&#8217;t isolated, the cluster will spend a lot of time on multi-shard queries and upholding multi-shard consistency.</FONT></SPAN></P>
<P><FONT class=extract><SPAN style="FONT-WEIGHT: 400">This process of making sure there aren&#8217;t relational constraints between different shards is called </SPAN><B>denormalization</B><SPAN style="FONT-WEIGHT: 400">. Denormalization is achieved by duplicating data (which adds write complexity) and grouping data so that it can be accessed in a single row. Notably, denormalized data is different from </SPAN><B>non-normalized</B><SPAN style="FONT-WEIGHT: 400"> data where relationships between data are unknown rather than located on a single table.</SPAN></FONT></P>
<P><SPAN style="FONT-WEIGHT: 400"><FONT class=extract>As an example, let&#8217;s think about where to store data for messages between two friends. Both users want fast responses, but what if their user records are split up onto different shards? We can store the messages in both places. This increases write time slightly, because it means the data is written twice. But it also ensures the message data is fast to look up regardless which&nbsp; friend is checking their messages.</FONT></SPAN></P>
<P><SPAN style="FONT-WEIGHT: 400"><FONT class=extract>If denormalization isn&#8217;t possible (multi-shard queries are necessary,) then the service needs to consider the tradeoffs between consistency and availability. You can read more about this tradeoff and the CAP theorem in </FONT></SPAN><A href="https://igotanoffer.com/blogs/tech/databases-system-design-interview"><SPAN style="FONT-WEIGHT: 400"><FONT class=extract>our article on databases</FONT></SPAN></A><SPAN style="FONT-WEIGHT: 400"><FONT class=extract>. </FONT></SPAN></P>
<H3><STRONG><FONT class=extract>1.3 When to use sharding&nbsp;</FONT></STRONG></H3>
<P><SPAN style="FONT-WEIGHT: 400"><FONT class=extract>The benefits of a sharded architecture, versus other kinds of database partitioning are:</FONT></SPAN></P>
<UL>
<LI style="FONT-WEIGHT: 400"><FONT class=extract><SPAN style="FONT-WEIGHT: 400">Leveraging average hardware instead of high end machines</SPAN> </FONT>
<LI style="FONT-WEIGHT: 400"><FONT class=extract><SPAN style="FONT-WEIGHT: 400">Quickly scaling by adding more shards</SPAN> </FONT>
<LI style="FONT-WEIGHT: 400"><SPAN style="FONT-WEIGHT: 400"><FONT class=extract>Better performance because each machine is under less load</FONT></SPAN></LI></UL>
<P><SPAN style="FONT-WEIGHT: 400"><FONT class=extract>Sharding is particularly useful when a single database server:&nbsp;</FONT></SPAN></P>
<UL>
<LI style="FONT-WEIGHT: 400"><FONT class=extract><SPAN style="FONT-WEIGHT: 400">Can&#8217;t hold all the data</SPAN> </FONT>
<LI style="FONT-WEIGHT: 400"><FONT class=extract><SPAN style="FONT-WEIGHT: 400">Can't compute all the query responses fast enough</SPAN> </FONT>
<LI style="FONT-WEIGHT: 400"><SPAN style="FONT-WEIGHT: 400"><FONT class=extract>Can&#8217;t handle the number of concurrent connections</FONT></SPAN></LI></UL>
<P><FONT class=extract><SPAN style="FONT-WEIGHT: 400">You might also need sharding when you need to maintain distinct geographic regions, even if the above compute constraints </SPAN><I><SPAN style="FONT-WEIGHT: 400">haven't </SPAN></I><SPAN style="FONT-WEIGHT: 400">been hit. Either your service will be faster when the data servers are physically closer to the users, or there's legislation about data location and usage in one of the countries your service operates in.&nbsp;</SPAN></FONT></P>
<H3><STRONG><FONT class=extract>1.4 When not to use sharding&nbsp;</FONT></STRONG></H3>
<P><SPAN style="FONT-WEIGHT: 400"><FONT class=extract>The disadvantages of database sharding are all about complexity. The queries become more complex because they have to somehow get the correct shard key, and need to be aware of avoiding multi-shard queries. </FONT></SPAN></P>
<P><SPAN style="FONT-WEIGHT: 400"><FONT class=extract>If the shards can't be entirely isolated, you need to implement eventual consistency for duplicated data or upholding relational constraints. The implementation and deployment of your database get a lot more complex, as do failovers, backups, and other kinds of maintenance. Essentially - you should only use database sharding when you absolutely have to.</FONT></SPAN></P>
<P><A name=Approaches><FONT class=extract></FONT></A></P>
<H2><A name=approaches></A><B><FONT class=extract>2. Approaches to Sharding</FONT></B></H2>
<P><FONT class=extract><SPAN style="FONT-WEIGHT: 400">The different approaches to sharded architectures are based on how the shard key is assigned. Regardless of what they're derived from, shard keys need to be unique </SPAN><I><SPAN style="FONT-WEIGHT: 400">across</SPAN></I><SPAN style="FONT-WEIGHT: 400"> shards, so their values need to be coordinated. This leads to a tradeoff between a centralized "name server" that can dynamically optimize logical shards for performance, and a predetermined distributed algorithm that is faster to compute.</SPAN></FONT></P>
<P><SPAN style="FONT-WEIGHT: 400"><FONT class=extract>Shard keys are derived from some invariant feature of the data that utilizes business logic to optimize for the most common queries. Common choices are tenant ids, location, and timestamps. Custom configuration can also tune the performance of a sharded architecture based on usage patterns, actual shard sizes, etc.</FONT></SPAN></P>
<P><SPAN style="FONT-WEIGHT: 400"><FONT class=extract>Here are the three most common approaches to sharding you should know about when designing systems.&nbsp;</FONT></SPAN></P>
<H3><STRONG><FONT class=extract>2.1 Range</FONT></STRONG></H3>
<P><SPAN style="FONT-WEIGHT: 400"><FONT class=extract>Data can be assigned to a shard based on what "range" it falls into. For example, a database with sequential time-based data like log history could shard based on month ranges. One big advantage of range-based shard keys is they make sequential access patterns very fast, because data that is "close" in the given range will be on the same shard. </FONT></SPAN></P>
<P><SPAN style="FONT-WEIGHT: 400"><FONT class=extract>One downside to ranges is the balance of data can be unpredictable. For example, an e-commerce company might have a lot more orders in December because of holiday shopping, so the shard with the December range could get overwhelmed while the other shards aren't doing much.</FONT></SPAN></P>
<H3><STRONG><FONT class=extract>2.2 Hash</FONT></STRONG></H3>
<P><SPAN style="FONT-WEIGHT: 400"><FONT class=extract>To address the issue of imbalanced shards, data can be distributed based on a hash of part of the data. An effective hash function will randomize and distribute incoming data to prevent any access patterns that could overwhelm a node. For example, the profile pages of celebrities get substantially more traffic than the average user, so a hash function can be used to randomly distribute these celebrity users and prevent hotspots. </FONT></SPAN></P>
<P><SPAN style="FONT-WEIGHT: 400"><FONT class=extract>One major advantage of a hash-based sharded architecture is the shard key can be computed by any server that knows the hash function, so there's no centralized point of failure.</FONT></SPAN></P>
<P><FONT class=extract><SPAN style="FONT-WEIGHT: 400">One big downside of hashing is adding shards can require a lot of overhead, depending on the implementation. </SPAN><B>Consistent hashing</B><SPAN style="FONT-WEIGHT: 400"> limits this by guaranteeing a minimum amount of data will have to be moved when a new node is added.</SPAN></FONT></P>
<H3><STRONG><FONT class=extract>2.3 Name Node</FONT></STRONG></H3>
<P><SPAN style="FONT-WEIGHT: 400"><FONT class=extract>The last approach is any implementation that uses a central "name node" to coordinate the mapping of data to shard keys. What's nice about this approach is it makes the business logic very clear and easy to update based on usage patterns. </FONT></SPAN></P>
<P><SPAN style="FONT-WEIGHT: 400"><FONT class=extract>For example, an important client might want to guarantee a precise location distribution of their data on your service. You can base the shard key on tennant it and have a clear mapping in the name node that assigns their tenant to shards in their desired geographic regions and is easy to update if their needs change. </FONT></SPAN></P>
<P><SPAN style="FONT-WEIGHT: 400"><FONT class=extract>The main downside is a name node is a central point of failure, and additional care is needed to implement good replication and failovers for that node. This approach also adds an additional step of consulting the name node in the lookup process, which can slow down database operations.</FONT></SPAN>