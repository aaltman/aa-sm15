<H3 class="post-title entry-title" style='WHITE-SPACE: normal; WORD-SPACING: 0px; POSITION: relative; TEXT-TRANSFORM: none; COLOR: rgb(102,102,102); FONT: 22px "Trebuchet MS", Trebuchet, Verdana, sans-serif; ORPHANS: 2; WIDOWS: 2; MARGIN: 0.75em 0px 0px; LETTER-SPACING: normal; BACKGROUND-COLOR: rgb(255,255,255); TEXT-INDENT: 0px; -webkit-text-stroke-width: 0px; text-decoration-thickness: initial; text-decoration-style: initial; text-decoration-color: initial' itemprop="name">Is RCU a generic concurrency control?</H3>
<DIV class=post-header style='FONT-SIZE: 10px; FONT-FAMILY: "Trebuchet MS", Trebuchet, Verdana, sans-serif; WHITE-SPACE: normal; WORD-SPACING: 0px; TEXT-TRANSFORM: none; FONT-WEIGHT: 400; COLOR: rgb(102,102,102); FONT-STYLE: normal; ORPHANS: 2; WIDOWS: 2; MARGIN: 0px 0px 1.5em; LETTER-SPACING: normal; LINE-HEIGHT: 1.6; BACKGROUND-COLOR: rgb(255,255,255); TEXT-INDENT: 0px; -webkit-text-stroke-width: 0px; text-decoration-thickness: initial; text-decoration-style: initial; text-decoration-color: initial; font-variant-ligatures: normal; font-variant-caps: normal'>
<DIV class=post-header-line-1></DIV></DIV>
<DIV id=post-body-7409921288232894837 class="post-body entry-content" style='FONT-SIZE: 13px; FONT-FAMILY: "Trebuchet MS", Trebuchet, Verdana, sans-serif; WIDTH: 546px; WHITE-SPACE: normal; WORD-SPACING: 0px; POSITION: relative; TEXT-TRANSFORM: none; FONT-WEIGHT: 400; COLOR: rgb(102,102,102); FONT-STYLE: normal; ORPHANS: 2; WIDOWS: 2; LETTER-SPACING: normal; LINE-HEIGHT: 1.4; BACKGROUND-COLOR: rgb(255,255,255); TEXT-INDENT: 0px; -webkit-text-stroke-width: 0px; text-decoration-thickness: initial; text-decoration-style: initial; text-decoration-color: initial; font-variant-ligatures: normal; font-variant-caps: normal' itemprop="description articleBody">In this post we're going to talk about RCU and we're going to start by what it means.<BR>When people talk about RCU they usually mean two different things combined: a synchronization mechanism, which I'll call RCU-sync, and a make-copy-of-object-and-modify-copy, which I'll call Copy-On-Write (COW).<BR><BR>Let's start with Copy-On-Write.<BR>This is a technique used in concurrency and even on durability (see previous post) where instead of modifying an object in-place, you make a copy of the object, modify the new object and then toggle a pointer to point from the old object to the new object. The name RCU comes from Read-Copy-Update as a reference to this technique.<BR>When used in (shared memory) concurrency this creates the problem of what to do with the old object: is it safe to delete it immediately? What if there are other threads currently accessing it?<BR>Solving this problem of object lifetime tracking is what the synchronization mechanism of RCU (RCU-sync) does.<BR><BR>There are many different algorithms that implement an RCU-sync. Some examples of RCU-sync algorithms can be seen in<SPAN>&nbsp;</SPAN><A style="TEXT-DECORATION: none; COLOR: rgb(34,136,187)" href="https://mirrors.edge.kernel.org/pub/linux/kernel/people/paulmck/perfbook/perfbook.html">Paul McKenney's excellent book</A><SPAN>&nbsp;</SPAN>or in our<SPAN>&nbsp;</SPAN><A style="TEXT-DECORATION: none; COLOR: rgb(34,136,187)" href="https://github.com/pramalhe/ConcurrencyFreaks/blob/master/papers/gracesharingurcu-2017.pdf">paper about fast userspace RCUs</A>. The thing about an RCU-sync is that it's a concurrency construct, like a mutual exclusion lock or a reader-writer lock. For example, a mutual exclusion lock implements at least the following API:<BR><SPAN style='FONT-FAMILY: "courier new", courier, monospace'>&nbsp; lock()<BR>&nbsp; unlock()</SPAN><BR>while a reader-writer lock implements at least:<BR><SPAN style='FONT-FAMILY: "courier new", courier, monospace'>&nbsp; read_lock()<BR>&nbsp; read_unlock()<BR>&nbsp; write_lock()<BR>&nbsp; write_unlock()</SPAN><BR>and an RCU-sync implements at least:<BR><SPAN style='FONT-FAMILY: "courier new", courier, monospace'>&nbsp; rcu_read_lock()<BR>&nbsp; rcu_read_unlock()<BR>&nbsp; rcu_synchronize()</SPAN><BR>The difference between RCU and locks is that locks provide a generic way of doing concurrency, while RCU does not.<BR><BR>The rcu_read_lock() and rcu_read_unlock() methods must guarantee that code within a critical section defined by these two functions must not<SPAN>&nbsp;</SPAN><I>escape</I><SPAN>&nbsp;</SPAN>outside the critical section. An RCU-sync must also guarantee that a call to rcu_synchronize() will wait for all threads currently executing a block of code in a rcu_read_lock/unlock() block to complete (call rcu_read_unlock) before rcu_synchronize() returns to the caller. This guarantee is called<SPAN>&nbsp;</SPAN><I>quiescence</I><SPAN>&nbsp;</SPAN>and it's extremely useful in shared memory concurrency. Note that the actual semantics are much more formal that what I've described here, but for the purpose of this post, it's enough to get an idea of how an RCU-sync behaves.<BR><BR>As mentioned above, RCU-sync provides quiescence, not mutual exclusion.<BR>A thread calling rcu_synchronize() will know that by the time the call to rcu_synchronize() returns, everything done<SPAN>&nbsp;</SPAN><B>before</B><SPAN>&nbsp;</SPAN>this call is now visible to other threads (as long as the other threads call rcu_read_lock/unlock to access the associated data). However, there is nothing preventing other threads from modyfing the same data at the same time (data race behavior). This means that even when using RCU-synch we still need some extra mechanism to provide mutual exclusion or prevent races in some other way.<BR><BR>At its essence, RCU-sync is mechanism for a<SPAN>&nbsp;</SPAN><B>single</B><SPAN>&nbsp;</SPAN>writer to synchronize with multiple readers. It doesn't solve the problem of<SPAN>&nbsp;</SPAN><B>multiple</B><SPAN>&nbsp;</SPAN>writers and it also doesn't solve the problem of the readers having a consistent view of the data.<BR>Let me explain a bit more about what I mean with "consistent view". Suppose we have two variables, "a" and "b" initially at zero and a single writer thread and multiple reader threads. The writer code could be:<BR><SPAN style='FONT-FAMILY: "courier new", courier, monospace'>writer() {<BR>&nbsp;&nbsp;&nbsp; a = 1;<BR>&nbsp;&nbsp;&nbsp; rcu_synchronize();<BR>&nbsp;&nbsp;&nbsp; b = 1;<BR>&nbsp;&nbsp;&nbsp; rcu_synchronize();<BR>}</SPAN><BR>and the reader code:<BR><SPAN style='FONT-FAMILY: "courier new", courier, monospace'>reader() {<BR>&nbsp;&nbsp;&nbsp; rcu_read_lock();<BR>&nbsp;&nbsp;&nbsp; printf("a=%d\n", a);<BR>&nbsp;&nbsp;&nbsp; printf("b=%d\n", b);<BR>&nbsp;&nbsp;&nbsp; rcu_read_unlock();<BR>}</SPAN><BR><BR>A reader thread could print "a=1,b=0", even if "a" and "b" are std::atomic with memory_order_consume, or even memory_order_seq_cst.<BR>RCU-sync does<SPAN>&nbsp;</SPAN><B>not</B><SPAN>&nbsp;</SPAN>provide atomicity for multiple variables. In order to achieve this, we need to aggregate all those variables within a single object and make a snapshopt of this object using Copy-On-Write. But then, the concurrency technique really is COW, not RCU-sync. With such an approach, the RCU-sync is used only for memory reclamation of the old objects and if we're in Java then we don't even need that because the GC will do it for us.<BR>And<SPAN>&nbsp;</SPAN><B>that</B><SPAN>&nbsp;</SPAN>is why whenever they use copy-on-write on java.util.concurrent they call it copy-on-write and not RCU&nbsp; ;)<BR><BR><BR>Let me repeat it again: RCU-sync is extremely useful for memory reclamation and as a component of more complex concurrency techniques, but it is not generic. RCU-sync does not provide atomicity, nor does it prevent write-write races, not even read-write races. All it does it give quiescence, which personally I think it's awesome! It's all a matter of expectations.<BR><BR>Just to go back to COW briefly, COW can be used to solve write-write races and read-write races by creating a new object on every modification of every sub-object. Basically, if you want full consistency across your data, you need a<SPAN>&nbsp;</SPAN><I>god object</I><SPAN>&nbsp;</SPAN>that contains all your data and<SPAN>&nbsp;</SPAN><B>any</B><SPAN>&nbsp;</SPAN>modification to the data (or just a single variable) will require<B><SPAN>&nbsp;</SPAN>a full copy of the entire data</B>.<BR>So yes, COW can be generic, it's just that nobody does it like this because it would be too slow.<BR><BR>Both COW and RCU-sync are valuable tools that researchers and concurrency library implementers can use to make sophisticated concurrent data structures or other synchronization mechanisms, but calling them<SPAN>&nbsp;</SPAN><I>generic concurrency controls</I><SPAN>&nbsp;</SPAN>is going too far.<BR>In other words, there certainly are database engines and STMs (software transactional memory) which use COW or RCU-sync internally, but you'll never see a DBMS or STM whose concurrency control<SPAN>&nbsp;</SPAN><B>is</B><SPAN>&nbsp;</SPAN>RCU. It just doesn't make sense to have a DBMS where any mutative operation causes a copy of the entire DB to be made. Because, that would be the only way to provide generic transactions on that DBMS or STM.<BR>In the DBMS context, a concurrency control is something like MVCC (multi-version concurrency control) or 2PL (two-phase locking) or OCC (optimistic concurrency control).<BR><BR>RCU is<SPAN>&nbsp;</SPAN><B>not</B><SPAN>&nbsp;</SPAN>a generic concurrency control.</DIV>