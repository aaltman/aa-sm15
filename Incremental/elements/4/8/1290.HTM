<b> : </b>OneFile is also a database engine</H3>
<DIV class=post-header style='FONT-SIZE: 10px; FONT-FAMILY: "Trebuchet MS", Trebuchet, Verdana, sans-serif; WHITE-SPACE: normal; WORD-SPACING: 0px; TEXT-TRANSFORM: none; FONT-WEIGHT: 400; COLOR: rgb(102,102,102); FONT-STYLE: normal; ORPHANS: 2; WIDOWS: 2; MARGIN: 0px 0px 1.5em; LETTER-SPACING: normal; LINE-HEIGHT: 1.6; BACKGROUND-COLOR: rgb(255,255,255); TEXT-INDENT: 0px; -webkit-text-stroke-width: 0px; text-decoration-thickness: initial; text-decoration-style: initial; text-decoration-color: initial; font-variant-ligatures: normal; font-variant-caps: normal'>
<DIV class=post-header-line-1></DIV></DIV>
<DIV id=post-body-392837873057077868 class="post-body entry-content" style='FONT-SIZE: 13px; FONT-FAMILY: "Trebuchet MS", Trebuchet, Verdana, sans-serif; WIDTH: 546px; WHITE-SPACE: normal; WORD-SPACING: 0px; POSITION: relative; TEXT-TRANSFORM: none; FONT-WEIGHT: 400; COLOR: rgb(102,102,102); FONT-STYLE: normal; ORPHANS: 2; WIDOWS: 2; LETTER-SPACING: normal; LINE-HEIGHT: 1.4; BACKGROUND-COLOR: rgb(255,255,255); TEXT-INDENT: 0px; -webkit-text-stroke-width: 0px; text-decoration-thickness: initial; text-decoration-style: initial; text-decoration-color: initial; font-variant-ligatures: normal; font-variant-caps: normal' itemprop="description articleBody">In this post we'll talk about<SPAN>&nbsp;</SPAN><A style="TEXT-DECORATION: none; COLOR: rgb(34,136,187)" href="https://github.com/pramalhe/OneFile/">OneFile</A>, the world's first wait-free Software Transactional Memory that works on Persistent Memory, and why it's actually a (wait-free) database storage engine.<BR><BR>An STM (Software Transactional Memory) is a library which provides dynamic transactions over multiple objects with linearizable consistency. In effect, an STM provides Atomicity, Consistency and Isolation, but not Durability, i.e. and STM gives ACI transactions.<BR>A Persistent Transactional Memory (PTM) is just like an STM except it also gives Durability, or as I like to call it "failure-resilience". PTMs are capable of providing fully ACID transactions, as long as they're used with byte-addressable Persistent Memory (PM).<BR><BR>Examples of Persistent Memory are the Optane Persistent Memory NV-DIMMS:<BR><A style="TEXT-DECORATION: none; COLOR: rgb(34,136,187)" href="https://www.intel.com/content/www/us/en/architecture-and-technology/optane-dc-persistent-memory.html">https://www.intel.com/content/www/us/en/architecture-and-technology/optane-dc-persistent-memory.html</A><BR>or the battery backed NV-DIMMS by HP or Viking:<BR><A style="TEXT-DECORATION: none; COLOR: rgb(34,136,187)" href="https://www.hpe.com/nl/en/servers/persistent-memory.html">https://www.hpe.com/nl/en/servers/persistent-memory.html</A><BR><A style="TEXT-DECORATION: none; COLOR: rgb(34,136,187)" href="https://www.vikingtechnology.com/products/nvdimm/">https://www.vikingtechnology.com/products/nvdimm/</A><BR><BR>Not all PTMs provide ACID with serializable isolation.<BR>In the concurrency literature there are two major distinctions for the consistency of durable transactions:<BR>- durable linearizable: pretty much equivalent to what the databse community calls "serializable isolation" or full ACID transactions;<BR>- buffered durable linearizable: means that transactions are linearizable however, in the event of a failure, a non-specified amount of transactions will be lost up to the current one. The system is guaranteed to be restored to a consistent state in the past, just not necessarily the last committed transaction.<BR><A style="TEXT-DECORATION: none; COLOR: rgb(34,136,187)" href="https://urresearch.rochester.edu/institutionalPublicationPublicView.action?institutionalItemId=30821">https://urresearch.rochester.edu/institutionalPublicationPublicView.action?institutionalItemId=30821</A><BR><BR>All the other cases in between, which the database folks have names for such as "dirty reads", "non-repeatable reads", "phantom reads", we just call those "wrong" or "bugs" because that's how most users think of them.<BR><BR>Last year we made a PTM with (blocking) durable linearizable mutative transactions and wait-free read-only transactions called RomulusLR:<BR><A style="TEXT-DECORATION: none; COLOR: rgb(34,136,187)" href="https://dl.acm.org/citation.cfm?id=3210392">https://dl.acm.org/citation.cfm?id=3210392</A><BR>This PTM has ACID transactions and it's pretty fast due to its combining technique, but it does serialize all mutative transactions. Other PTMs like Mnemosyne don't have this limitation, but they have other limitations.<BR>A pretty well know PTM is libpmemobj in PMDK by the Intel guys, which understandably use it as a way to sell more Optane persistent memory&nbsp; ;)<BR>libpmemobj only has durable transactions and leaves the concurrency part up to the user, either by using a global lock, or fine grained locking (good luck with that!).&nbsp;&nbsp;<BR><A style="TEXT-DECORATION: none; COLOR: rgb(34,136,187)" href="https://pmem.io/">https://pmem.io/</A><BR>PMDK is an awesome piece of software because it has many tools that help enable the usage of persistent memory, not to mention all the effort that the Intel guys have put in in defining standards so that it all works with the PM products from different vendors.<BR><BR>We made a variant of OneFile for PM. In this variant the memory reclamation is done in a different way. We'll leave those details to its own blog post, but the cool thing about OneFile for PM is that it comes with its own memory allocator for persistent memory:<BR><A style="TEXT-DECORATION: none; COLOR: rgb(34,136,187)" href="https://github.com/pramalhe/OneFile/blob/master/ptms/OneFilePTMWF.hpp">https://github.com/pramalhe/OneFile/blob/master/ptms/OneFilePTMWF.hpp</A><BR>Even if you don't have persistent memory, you can use a region of your DRAM memory and mmap on it. This will give you durability for process failure but not for system failure. In other words, if the process that is doing a transaction gets killed, the information will be recovered correctly, but if the machine dies (gets unpluged or reboots) then the data is lost (unless you have a persistent memory module in your machine).<BR><BR>The allocator that comes with OneFile is very simple, doesn't do coalescence of blocks or anything like that. We call it EsLoco (Extremely Simple Allocator).<BR>Other allocators can be used, as long as annotation is added to them by adding the template tmtype to each struct/class member of the allocator metadata.<BR>Because the changes to allocator metadata are part of the transaction, there will not be any leaks in the event of a failure and all the operations are wait-free. This means that this allocator is capable of allocating and de-allocating blocks of data in a wait-free way.<BR>In summary, by using OneFile,<SPAN>&nbsp;</SPAN><B>we've made the world's first wait-free allocator!</B><BR>So ok, the bad news is that it serializes all operations, whether allocations or de-allocations. Don't expect any scalability from it, but on the other hand, it will be hard to find anything better in a multi-threaded environment when it comes to tail latency.<BR><BR>Another interesting aspect is the number of fences.<BR>When doing a durable transaction in block storage (disk) the typical trick is to do two fsync() or two fdatasync(). The cost of the fsync() is significant because it's about the order of the latency of a round trip to the media device, i.e. the disk's latency.<BR>In PM, the equivalent is to do two pfence (SFENCE instructions on x86). The cost of the pfence is also the cost of a round trip to the device, but this is sub-microsecond so it's not that costly.<BR>Libpmemobj in PMDK uses an undo-log technique, which means it executes two SFENCE per modified range/object in a transaction. Even though the pfence are 1000x cheaper than calling fsync,() if we do too many of them it becomes a performance bottleneck. In OneFile we did our best to reduce the number of pfence to a minimum and reduced them to 2 per transaction, regardless of the number of objects modified during the transaction.<BR><BR>In effect, OneFile is the world's first wait-free database engine. When coupled with persistent memory, it is capable of providing transactions with serializable isolation.<BR>A relevant question would be:<BR><I>Like all other databases, it has to have a recovery mechanism for when a failure occurs... right?</I><BR>Actually, no it doesn't.<BR>OneFile is the first database engine with<SPAN>&nbsp;</SPAN><I>null-recovery</I>. Null-recovery is a property of certain lock-free algorithms which was first introduced in a paper by Izraelevitz et al. in 2016<BR><A style="TEXT-DECORATION: none; COLOR: rgb(34,136,187)" href="https://www.cs.rochester.edu/u/scott/papers/2016_DISC_persistence.pdf">https://www.cs.rochester.edu/u/scott/papers/2016_DISC_persistence.pdf</A><BR>Basically it says that some lock-free (and wait-free) algorithms have this property of simply continuing where they left off after a failure, meaning that they don't need a specific recovery procedure to recover after a crash.<BR>This property is theoretically appealing but no database engine or PTM had so far been able to do it. With OneFile we've shown a practical implementation of it and we showed that database recovery can be done with the cost of applying the last incomplete transaction (it's actually possible to do even less).<BR>The database research community has entire papers where they have complicated techniques to improve the time it takes to recover a database:<SPAN>&nbsp;</SPAN><A style="TEXT-DECORATION: none; COLOR: rgb(34,136,187)" href="https://research.fb.com/wp-content/uploads/2016/11/fast-database-restarts-at-facebook.pdf?">https://research.fb.com/wp-content/uploads/2016/11/fast-database-restarts-at-facebook.pdf?</A><BR>With OneFile + PM, we've reduced recovery time to the time of a single transaction!<BR><BR>... and did I mention that transactions in OneFile PTM are wait-free and have serializable isolation?&nbsp; :)</DIV>