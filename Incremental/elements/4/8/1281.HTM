<b> : </b>Atomic Durability - How do databases recover from a crash ?</H3>
<DIV class=post-header style='FONT-SIZE: 10px; FONT-FAMILY: "Trebuchet MS", Trebuchet, Verdana, sans-serif; WHITE-SPACE: normal; WORD-SPACING: 0px; TEXT-TRANSFORM: none; FONT-WEIGHT: 400; COLOR: rgb(102,102,102); FONT-STYLE: normal; ORPHANS: 2; WIDOWS: 2; MARGIN: 0px 0px 1.5em; LETTER-SPACING: normal; LINE-HEIGHT: 1.6; BACKGROUND-COLOR: rgb(255,255,255); TEXT-INDENT: 0px; -webkit-text-stroke-width: 0px; text-decoration-thickness: initial; text-decoration-style: initial; text-decoration-color: initial; font-variant-ligatures: normal; font-variant-caps: normal'>
<DIV class=post-header-line-1></DIV></DIV>
<DIV id=post-body-1846693057987968918 class="post-body entry-content" style='FONT-SIZE: 13px; FONT-FAMILY: "Trebuchet MS", Trebuchet, Verdana, sans-serif; WIDTH: 546px; WHITE-SPACE: normal; WORD-SPACING: 0px; POSITION: relative; TEXT-TRANSFORM: none; FONT-WEIGHT: 400; COLOR: rgb(102,102,102); FONT-STYLE: normal; ORPHANS: 2; WIDOWS: 2; LETTER-SPACING: normal; LINE-HEIGHT: 1.4; BACKGROUND-COLOR: rgb(255,255,255); TEXT-INDENT: 0px; -webkit-text-stroke-width: 0px; text-decoration-thickness: initial; text-decoration-style: initial; text-decoration-color: initial; font-variant-ligatures: normal; font-variant-caps: normal' itemprop="description articleBody">In this post we're going to talk about the four different ways of having durable transactions.<SPAN>&nbsp;</SPAN><B>If you want to know how databases and file systems guarantee correct data recovery after a power failure, then keep reading</B>!<BR><BR>Writing to a durable/persistent media can be a complex task. If there is a failure half-way through, you may end up with corrupted data.<BR>By<SPAN>&nbsp;</SPAN><I>durable media</I><SPAN>&nbsp;</SPAN>I mean a disk drive, an SD card, a USB stick, a Persistent Memory module (NV-DIMM), a network attached NAS, and many other like these.<BR><BR>Suppose you're changing a customer address in a database. The current address is "<SPAN style="COLOR: blue"><SPAN style='FONT-FAMILY: "courier new", courier, monospace'>Bag End, Shire</SPAN></SPAN>" and we want to change it to "<SPAN style="COLOR: red"><SPAN style='FONT-FAMILY: "courier new", courier, monospace'>Rivendell</SPAN></SPAN>".<BR>What happens of there is a crash half-way through the write?<BR>Suppose the first four bytes were written before the crash occurred. Upon restart, the address in the database is now "<SPAN style='FONT-FAMILY: "courier new", courier, monospace'><SPAN style="COLOR: red">Rive</SPAN><SPAN style="COLOR: blue">nd, Shire</SPAN></SPAN>"... clearly an incorrect address. What should we do?<BR><BR>This is a typical problem encountered by the designers of DBMS (Database Management Systems) and file systems.<BR>Generally speaking, there are four solutions to this problem and they are:<BR>1) Undo-Log;<BR>2) Redo-Log;<BR>3) Copy-On-Write (sometimes called<SPAN>&nbsp;</SPAN><I>Shadow Copy</I><SPAN>&nbsp;</SPAN>or<SPAN>&nbsp;</SPAN><I>Shadow Paging</I>);<BR>4) Romulus;<BR><BR><BR>Before we explain how each of these works, we need to introduce two things which we're going to call "<B>ordering fence</B>" and "<B>synchronization fence</B>".<BR>An "ordering fence" is something that guarantees that previous writes will reach the durable media<SPAN>&nbsp;</SPAN><I>before</I><SPAN>&nbsp;</SPAN>subsequent writes. For example:<BR><BR><SPAN style='FONT-FAMILY: "courier new", courier, monospace'>write(a);<BR><B>order_fence</B>();<BR>write(b);</SPAN><BR>implies that "<SPAN style='FONT-FAMILY: "courier new", courier, monospace'>a</SPAN>" will always be written to the durable media<SPAN>&nbsp;</SPAN><I>before</I><SPAN>&nbsp;</SPAN>"<SPAN style='FONT-FAMILY: "courier new", courier, monospace'>b</SPAN>" is written.<BR><BR>A "synchronization fence" is something that guarantees that previously written data is now durable. And by<SPAN>&nbsp;</SPAN><I>durable</I><SPAN>&nbsp;</SPAN>I mean it's persistent in the media and in the event of a crash, this data will not be lost. For example:<BR><BR><SPAN style='FONT-FAMILY: "courier new", courier, monospace'>write(a);<BR><B>sync_fence</B>();<BR>computer_beeps();</SPAN><BR>if you heard a<SPAN>&nbsp;</SPAN><I>beep</I><SPAN>&nbsp;</SPAN>and immediately after there is a power cut, you know for sure that the media contains the data "<SPAN style='FONT-FAMILY: "courier new", courier, monospace'>a</SPAN>" because the<SPAN>&nbsp;</SPAN><I>beep</I><SPAN>&nbsp;</SPAN>occurred<SPAN>&nbsp;</SPAN><I>after</I><SPAN>&nbsp;</SPAN>the<SPAN>&nbsp;</SPAN><SPAN style='FONT-FAMILY: "courier new", courier, monospace'>sync_fence()</SPAN><SPAN>&nbsp;</SPAN>which was<SPAN>&nbsp;</SPAN><I>after</I><SPAN>&nbsp;</SPAN>the<SPAN>&nbsp;</SPAN><SPAN style='FONT-FAMILY: "courier new", courier, monospace'>write(a)</SPAN><SPAN>&nbsp;</SPAN>was persisted.<BR><BR><BR>The actual semantics depend on what hardware we're talking about, but the idea is pretty much the same: you need<SPAN>&nbsp;</SPAN><SPAN style='FONT-FAMILY: "courier new", courier, monospace'>order_fence()</SPAN><SPAN>&nbsp;</SPAN>and you need<SPAN>&nbsp;</SPAN><SPAN style='FONT-FAMILY: "courier new", courier, monospace'>sync_fence()</SPAN>.<BR>When writing to disk, both the<SPAN>&nbsp;</SPAN><SPAN style='FONT-FAMILY: "courier new", courier, monospace'>order_fence()</SPAN><SPAN>&nbsp;</SPAN>and<SPAN>&nbsp;</SPAN><SPAN style='FONT-FAMILY: "courier new", courier, monospace'>sync_fence()</SPAN><SPAN>&nbsp;</SPAN>have to be implemented as<SPAN>&nbsp;</SPAN><SPAN style='FONT-FAMILY: "courier new", courier, monospace'>fsync()</SPAN><SPAN>&nbsp;</SPAN>or<SPAN>&nbsp;</SPAN><SPAN style='FONT-FAMILY: "courier new", courier, monospace'>fdatasync()</SPAN>. When writing to PM they're made up of a combination of CLWB and SFENCE instructions.<BR><BR>Now back to the actual algorithms