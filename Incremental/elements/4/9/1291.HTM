<H3 class="post-title entry-title" style='WHITE-SPACE: normal; WORD-SPACING: 0px; POSITION: relative; TEXT-TRANSFORM: none; COLOR: rgb(102,102,102); FONT: 22px "Trebuchet MS", Trebuchet, Verdana, sans-serif; ORPHANS: 2; WIDOWS: 2; MARGIN: 0.75em 0px 0px; LETTER-SPACING: normal; BACKGROUND-COLOR: rgb(255,255,255); TEXT-INDENT: 0px; -webkit-text-stroke-width: 0px; text-decoration-thickness: initial; text-decoration-style: initial; text-decoration-color: initial' itemprop="name">Optimization to Michael-Scott Persistent Lock-Free Queue</H3>
<DIV class=post-header style='FONT-SIZE: 10px; FONT-FAMILY: "Trebuchet MS", Trebuchet, Verdana, sans-serif; WHITE-SPACE: normal; WORD-SPACING: 0px; TEXT-TRANSFORM: none; FONT-WEIGHT: 400; COLOR: rgb(102,102,102); FONT-STYLE: normal; ORPHANS: 2; WIDOWS: 2; MARGIN: 0px 0px 1.5em; LETTER-SPACING: normal; LINE-HEIGHT: 1.6; BACKGROUND-COLOR: rgb(255,255,255); TEXT-INDENT: 0px; -webkit-text-stroke-width: 0px; text-decoration-thickness: initial; text-decoration-style: initial; text-decoration-color: initial; font-variant-ligatures: normal; font-variant-caps: normal'>
<DIV class=post-header-line-1></DIV></DIV>
<DIV id=post-body-9195664220625732803 class="post-body entry-content" style='FONT-SIZE: 13px; FONT-FAMILY: "Trebuchet MS", Trebuchet, Verdana, sans-serif; WIDTH: 546px; WHITE-SPACE: normal; WORD-SPACING: 0px; POSITION: relative; TEXT-TRANSFORM: none; FONT-WEIGHT: 400; COLOR: rgb(102,102,102); FONT-STYLE: normal; ORPHANS: 2; WIDOWS: 2; LETTER-SPACING: normal; LINE-HEIGHT: 1.4; BACKGROUND-COLOR: rgb(255,255,255); TEXT-INDENT: 0px; -webkit-text-stroke-width: 0px; text-decoration-thickness: initial; text-decoration-style: initial; text-decoration-color: initial; font-variant-ligatures: normal; font-variant-caps: normal' itemprop="description articleBody">After making the previous post, I went back to the code of the Michael-Scott persistent queue and figured out there is one psync and one pwb calls that can be removed in the enqueue() method, namely, the ones before the return statement.<BR><BR>This is possible because, for enqueue() to return, it means the CAS on tail has been done, and although the value of tail may not be persisted, the CAS on tail guarantees that the value of the<SPAN>&nbsp;</SPAN><SPAN style='FONT-FAMILY: "courier new", courier, monospace'>node-&gt;next</SPAN><SPAN>&nbsp;</SPAN>is persisted. This means that if a crash occurs (in the scenario shown on the previous post) and<SPAN>&nbsp;</SPAN><SPAN style='FONT-FAMILY: "courier new", courier, monospace'>a_is_persisted</SPAN><SPAN>&nbsp;</SPAN>is persisted and the change to tail occurring on the enqueue is not, it's still ok because the<SPAN>&nbsp;</SPAN><SPAN style='FONT-FAMILY: "courier new", courier, monospace'>node-&gt;next</SPAN><SPAN>&nbsp;</SPAN>is persisted, which will allow the<SPAN>&nbsp;</SPAN><SPAN style='FONT-FAMILY: "courier new", courier, monospace'>recover()</SPAN><SPAN>&nbsp;</SPAN>of the queue to advance the tail and persist it as well.<BR>Ok I know, that sentence was long and confusing, but if I were to make a formal proof, it would be waaayyy more confusing&nbsp; ;)<BR><BR>Unfortunately, for the dequeue(), no such trick is possible on the head, therefore, we really do need the PWB(&amp;head) and PSYNC() before returning from dequeue().<BR><BR>The source code on github has been updated:<BR><A style="TEXT-DECORATION: none; COLOR: rgb(34,136,187)" href="https://github.com/pramalhe/ConcurrencyFreaks/blob/master/CPP/pqueues/PMichaelScottQueue.hpp">https://github.com/pramalhe/ConcurrencyFreaks/blob/master/CPP/pqueues/PMichaelScottQueue.hpp</A><BR><BR>The performance increase is barely noticeable so I won't even bother to show the new plot.<BR><BR><BR>This is&nbsp; nice illustration of the similarities between the C++/C11/Java sequentially-consistent atomics, and the pwb/pfence/psync model described<SPAN>&nbsp;</SPAN><A style="TEXT-DECORATION: none; COLOR: rgb(34,136,187)" href="https://www.cs.rochester.edu/u/jhi1/papers/2016-spaa-transform">here</A>. Sure, we can do the algorithms with everything seq-cst, and everything full persistence fences, but to get better performance, we need to understand the algorithm to reduce the number of fences to a minimum, regardless of whether those fences are for synchronization (concurrency) or for persistency.</DIV>