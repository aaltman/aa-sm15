<H3 class="post-title entry-title" style='WHITE-SPACE: normal; WORD-SPACING: 0px; POSITION: relative; TEXT-TRANSFORM: none; COLOR: rgb(102,102,102); FONT: 22px "Trebuchet MS", Trebuchet, Verdana, sans-serif; ORPHANS: 2; WIDOWS: 2; MARGIN: 0.75em 0px 0px; LETTER-SPACING: normal; BACKGROUND-COLOR: rgb(255,255,255); TEXT-INDENT: 0px; -webkit-text-stroke-width: 0px; text-decoration-thickness: initial; text-decoration-style: initial; text-decoration-color: initial' itemprop="name"><FONT class=extract>What is Eventual Consistency ?</FONT></H3>
<DIV class=post-header style='FONT-SIZE: 10px; FONT-FAMILY: "Trebuchet MS", Trebuchet, Verdana, sans-serif; WHITE-SPACE: normal; WORD-SPACING: 0px; TEXT-TRANSFORM: none; FONT-WEIGHT: 400; COLOR: rgb(102,102,102); FONT-STYLE: normal; ORPHANS: 2; WIDOWS: 2; MARGIN: 0px 0px 1.5em; LETTER-SPACING: normal; LINE-HEIGHT: 1.6; BACKGROUND-COLOR: rgb(255,255,255); TEXT-INDENT: 0px; -webkit-text-stroke-width: 0px; text-decoration-thickness: initial; text-decoration-style: initial; text-decoration-color: initial; font-variant-ligatures: normal; font-variant-caps: normal'>
<DIV class=post-header-line-1><FONT class=extract></FONT></DIV></DIV>
<DIV id=post-body-5945375595747378317 class="post-body entry-content" style='FONT-SIZE: 13px; FONT-FAMILY: "Trebuchet MS", Trebuchet, Verdana, sans-serif; WIDTH: 546px; WHITE-SPACE: normal; WORD-SPACING: 0px; POSITION: relative; TEXT-TRANSFORM: none; FONT-WEIGHT: 400; COLOR: rgb(102,102,102); FONT-STYLE: normal; ORPHANS: 2; WIDOWS: 2; LETTER-SPACING: normal; LINE-HEIGHT: 1.4; BACKGROUND-COLOR: rgb(255,255,255); TEXT-INDENT: 0px; -webkit-text-stroke-width: 0px; text-decoration-thickness: initial; text-decoration-style: initial; text-decoration-color: initial; font-variant-ligatures: normal; font-variant-caps: normal' itemprop="description articleBody"><FONT class=extract>On this post we're going to talk about Eventual Consistency in the context of lock-free and wait-free data structures, with focus on the C++ memory model, although most (or all) of what we're going to cover also applies to other memory models likes the ones in D, Java , Rust, C11,<SPAN>&nbsp;</SPAN><I>&lt;insert language here&gt;</I>.<BR>If you're looking for an explanation on what Eventual Consistency is in the context of databases then this (may or) may not be what you're looking for!<BR><BR>Before we explain what is eventual consistency in C++, we need to explain a little of what shared memory is and a what is a memory model.<BR>Computers do many things: arithmetic computations, decide different things based on logical expressions, sending and receiving packets, putting pixels on a screen, etc. For this post, we care about reading from main memory and writing to main memory. This means "<SPAN style='FONT-FAMILY: "courier new", courier, monospace'>loads</SPAN>" and "<SPAN style='FONT-FAMILY: "courier new", courier, monospace'>stores</SPAN>".<BR>The whole C++ memory model is about what happens when you do loads and stores from different threads, and all the other stuff that the computer does is pretty much out of the picture.<BR>Obviously, stores are used to store a value in a certain memory location, and loads are used to read a value from a given memory location:<BR></FONT><FONT class=extract><SPAN style='FONT-FAMILY: "courier new", courier, monospace'>&nbsp;&nbsp;&nbsp; x.store(value);<BR>&nbsp;&nbsp;&nbsp; value = x.load();</SPAN><BR><BR>Also, from the memory model's point of view, all loads are indistinguishable, and so are all stores. CPU vendors have peculiarities, like some stores may re-order but others not (think stores on the same cache line), but the memory model doesn't really care about that, so for this post, we won't care either.<BR><BR>Ok, so this was really important. If you're not convinced that everything is about loads and stores then you better go and read the memory model of your favorite language and then come back.<BR>Let me say it once more:<SPAN>&nbsp;</SPAN><I>It's all about loads and stores</I>.<BR><BR><BR>Combinatorically, if we have two different operations (loads and stores) we can define ordering constraints based on four cases:<BR></FONT><FONT class=extract><B>1. A load may not reorder with a subsequent load;<BR>2. A store may not reorder with a subsequent store;<BR>3. A load may not reorder with a subsequent store;<BR>4. A store may not reorder with a subsequent load;</B><BR><BR>When none of the four constraints above are set, and if we want to share data among threads or processes (remember, our context is lock-free and wait-free data structures) then in C++ this is called memory_order_relaxed. In this memory ordering any loads can reorder with any stores. Whatever the order of the code you wrote, the compiler may decide to reorder the loads and stores in whatever way it thinks is the best.<BR>This has reduced synchronization and gives a lot of leeway to the compiler, thus resulting in high performance code. The downside is that most lock-free and wait-free algorithms were designed with a specific order in mind, and when this order is not respected, the algorithm no longer works.<BR><BR>To enforce constraint<SPAN>&nbsp;</SPAN><B>1</B>, the first load has to be done with a<SPAN>&nbsp;</SPAN><SPAN style='FONT-FAMILY: "courier new", courier, monospace'>memory_order_acquire</SPAN><SPAN>&nbsp;</SPAN>or<SPAN>&nbsp;</SPAN><SPAN style='FONT-FAMILY: "courier new", courier, monospace'>memory_order_seq_cst</SPAN>. In the C++ memory model, loads with memory_order_acquire can not be reordered with any subsequent load or store. Most of today's CPUs enforce this constraint by default already, which means that it needs no synchronization as well.<BR><BR>To enforce constraint<B><SPAN>&nbsp;</SPAN>2</B>, the second store has to be done with a<SPAN>&nbsp;</SPAN><SPAN style='FONT-FAMILY: "courier new", courier, monospace'>memory_order_release</SPAN><SPAN>&nbsp;</SPAN>or<SPAN>&nbsp;</SPAN><SPAN style='FONT-FAMILY: "courier new", courier, monospace'>memory_order_seq_cst</SPAN>. In the C++ memory model, stores with a<SPAN>&nbsp;</SPAN><SPAN style='FONT-FAMILY: "courier new", courier, monospace'>memory_order_release</SPAN><SPAN>&nbsp;</SPAN>can not be reordered with any previous load or store. CPUs with Total-Store-Order (TSO) like x86, enforce this constraint by default already, which means it needs no explicit synchronization. In practice the CPU internally has synchronization to achieve this strong ordering, but that's out of scope.<BR><BR>To enforce constraint<SPAN>&nbsp;</SPAN><B>3</B>, the first load has to be done with<SPAN>&nbsp;</SPAN><SPAN style='FONT-FAMILY: "courier new", courier, monospace'>memory_order_acquire</SPAN><SPAN>&nbsp;</SPAN>or<SPAN>&nbsp;</SPAN><SPAN style='FONT-FAMILY: "courier new", courier, monospace'>memory_order_seq_cst</SPAN>. x86 CPUs provide this guarantee without explicit synchronization (barriers/fences).<BR><BR>To enforce constraint<SPAN>&nbsp;</SPAN><B>4</B>, both the load and the store have to be<SPAN>&nbsp;</SPAN><SPAN style='FONT-FAMILY: "courier new", courier, monospace'>memory_order_seq_cst</SPAN>. No practical CPU provides this by default (such a CPU would be too slow) and to have such a constraint requires costly synchronization, typically a<SPAN>&nbsp;</SPAN><I>full fence</I><SPAN>&nbsp;</SPAN>or at least a<SPAN>&nbsp;</SPAN><I>store-load fence</I>.<BR>Explaining why this requires such high synchronization would require an entire (large) post about this topic, so let's just accept it as it is.<BR><BR>To sum it up, if we want all four constraints, we have to use sequentially consistent memory ordering, while if we want only the first three constraints, then the acquire-release memory ordering is enough.<BR>Notice that stores and loads are done at the<SPAN>&nbsp;</SPAN><I>word</I><SPAN>&nbsp;</SPAN>level, 64 bits let's say. Therefore, when we talk about sequential consistency we are talking about it at the word level.<SPAN>&nbsp;</SPAN><B>Any object bigger than one word and this guarantee disappears</B><SPAN>&nbsp;</SPAN>because it will take multiple stores (or multiple loads) to modify (or read) such an object.<BR><BR><BR>So what about eventual consistency?<BR>Roughly speaking,<SPAN>&nbsp;</SPAN><B>eventual consistency guarantees if no new updates (stores) are made to a data item (word), then eventually all accesses (loads) to that item (word) will return the last updated value</B>.<BR>In other words, if we stop doing stores in a certain variable, eventually, when we go and read it from another thread, we will see the last store that was made. Pop quiz: which memory ordering is the weakest that gives this guarantee?<BR>Answer: It's<SPAN>&nbsp;</SPAN><SPAN style='FONT-FAMILY: "courier new", courier, monospace'>memory_order_relaxed</SPAN><SPAN>&nbsp;</SPAN>(<SPAN style='FONT-FAMILY: "courier new", courier, monospace'>memory_order_acq_rel</SPAN><SPAN>&nbsp;</SPAN>and<SPAN>&nbsp;</SPAN><SPAN style='FONT-FAMILY: "courier new", courier, monospace'>memory_order_seq_cst</SPAN><SPAN>&nbsp;</SPAN>also provide this guarantee but at a greater cost).<BR>You see, something I didn't say about<SPAN>&nbsp;</SPAN><SPAN style='FONT-FAMILY: "courier new", courier, monospace'>memory_order_relaxed</SPAN><SPAN>&nbsp;</SPAN>is that the end result must<SPAN>&nbsp;</SPAN><I>look like</I><SPAN>&nbsp;</SPAN>the code you wrote, which means that eventually it will have to keep whatever was the last store you wrote in your code. This is highly non-obvious from reading the specs, but that's how it works, otherwise it would let the compiler produce incorrect programs, even in single-threaded code.<BR><BR><BR>Ok, so now that we know that in C++ memory_order_relaxed provides eventual consistency (at the word level), what can we do with that?<BR>Well, the answer to that depends on how useful you think that eventual consistency is.<BR>The term<SPAN>&nbsp;</SPAN><I>eventual consistency</I><SPAN>&nbsp;</SPAN>is meant as a consistency property of an item, or<SPAN>&nbsp;</SPAN><I>object</I><SPAN>&nbsp;</SPAN>in C++ parlance. If the object is the size of a word (64 bits or less) then just make it<SPAN>&nbsp;</SPAN><SPAN style='FONT-FAMILY: "courier new", courier, monospace'>atomic&lt;&gt;</SPAN><SPAN>&nbsp;</SPAN>and all stores and loads to/from it must be changed to use<SPAN>&nbsp;</SPAN><SPAN style='FONT-FAMILY: "courier new", courier, monospace'>memory_order_relaxed</SPAN>.<BR>If the object is larger than a word then things start to get more complicated because then we could have concurrent stores touching different words of the object and it would leave it in an inconsistent state. Example below:<BR></FONT><FONT class=extract><SPAN style="FONT-SIZE: x-small"><SPAN style='FONT-FAMILY: "courier new", courier, monospace'>struct myobject {<BR>&nbsp;&nbsp;&nbsp; atomic&lt;uint64_t&gt; a {0};&nbsp; // Consistency for this object implies that a is equal to b<BR>&nbsp;&nbsp;&nbsp; atomic&lt;uint64_t&gt; b {0};<BR>}<BR><BR>myobject obj;<BR><BR>Thread 1:<BR>&nbsp;&nbsp;&nbsp; obj.a.store(1, memory_order_relaxed);<BR>&nbsp;&nbsp;&nbsp; obj.b.store(1, memory_order_relaxed);<BR>&nbsp;&nbsp;&nbsp;<BR>Thread 2:<BR>&nbsp;&nbsp;&nbsp; obj.a.store(2, memory_order_relaxed);&nbsp; // May occur before a.store() in thread 1<BR>&nbsp;&nbsp;&nbsp; obj.b.store(2, memory_order_relaxed);&nbsp; // May occur after b.store() in thread 1<BR>&nbsp;&nbsp;&nbsp;<BR>Thread 3:<BR>&nbsp;&nbsp;&nbsp; while (true) {<BR>&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (obj.a.load() == obj.b.load()) break; // This may loop forever<BR>&nbsp;&nbsp;&nbsp; }&nbsp;&nbsp;&nbsp;<BR>&nbsp;&nbsp;&nbsp;</SPAN></SPAN><BR>In the above example, we defined the object to be consistent when having a and b members equal. The stores with Thread 1 may interleave with the stores in Thread 2, causing the object to be left in a inconsistent state permanently, with a=1 and b=2, which is not<SPAN>&nbsp;</SPAN><I>eventually consistent</I><SPAN>&nbsp;</SPAN>because the stores on the object have stopped but thread 3 will be in an infinite loop waiting for the object to be consistent.<BR><BR><BR>Even without going into the topic of whether or when is eventual consistency useful, we still have to care about a subtle but extremely important detail in the definition of eventual consistency:<SPAN>&nbsp;</SPAN><B>it refers to an object</B>.<BR>Let me say this again because it's important:<SPAN>&nbsp;</SPAN><B>Eventual Consistency requires you to define the item (or object) on where this consistency is being applied</B>.<BR>This means that what you define to be the object affects the consistency.<BR>Saying that you provide eventual consistency in your application is completely irrelevant unless you define at which<SPAN>&nbsp;</SPAN><I>granularity</I><SPAN>&nbsp;</SPAN>level you're providing such a guarantee.<BR>If you're providing eventual consistency at the word level, then it's easy to implement, just make all accesses<SPAN>&nbsp;</SPAN><SPAN style='FONT-FAMILY: "courier new", courier, monospace'>memory_order_relaxed</SPAN>;<BR>If it's eventual consistent at the C++ object level, then each object must itself be<SPAN>&nbsp;</SPAN><SPAN style='FONT-FAMILY: "courier new", courier, monospace'>atomic&lt;&gt;</SPAN>, which means that the underlying implementation is using a mutual exclusion lock to protect it, thus denying any benefit from doing eventual consistency. You might has well say you're providing strong consistency because you are in fact providing linearizability (at the object level);<BR><BR>In the context of data structures, if we say that a data structure is eventually consistent, it still needs to be atomic itself and all its nodes/whatever constitutes it. This means that the data structure itself needs to be consistent, or atomic. This is extremely hard to achieve without going into a fully linearizable (or at least sequentially consistent) algorithm, so perhaps this is not very useful in practice.<BR><BR>However, if we have multiple data structure instances, even if each of them is linearizable, doing operations or two or more of these data structures is not trivial to make them appear atomic (unless we're protecting everything with a global lock, or using a transactional memory). In such case, we can simply say that we're providing eventual consistency at the data structure level, and it would be correct to say so, because in each data structure instance we provide<SPAN>&nbsp;</SPAN><I>atomicity</I><SPAN>&nbsp;</SPAN>(linearizable consistency) but across data structure instances we only guarantee that eventually the modifications will be seen over all the instances.<BR><BR>If you take anything away from this post it should be this:<BR><I>Eventual Consistency only makes sense when we define what is the "object" where this consistency is being applied.</I></FONT></DIV>