<B>: </B>Closing thoughts 
<H4></H4>This isn't the whole story. There are two very important points we're missing here to get the full picture:<BR><BR>1st, if your function needs to allocate memory, then<SPAN>&nbsp;</SPAN><B>the progress guarantee it can give is bounded in practice by the progress condition given by the memory allocation mechanism</B>. In my view, we should have a different sub-classification to distinguish between the functions that need to allocate memory and those who don't. You can check out this<SPAN>&nbsp;</SPAN><A style="TEXT-DECORATION: none; COLOR: rgb(34,136,187)" href="http://concurrencyfreaks.blogspot.fr/2013/03/lock-free-isnt-what-its-cracked-up-to-be.html">post<SPAN>&nbsp;</SPAN></A>for more details, but the basic idea is that there is not much of a point in creating a Wait-Free Population Oblivious function which always needs to allocate memory using a Blocking mechanism.<BR><BR>2nd, the whole concept of Progress Condition is to classify algorithms and functions in terms of<SPAN>&nbsp;</SPAN><I>time</I><SPAN>&nbsp;</SPAN>guarantees, yet, the definitions are made in terms of<SPAN>&nbsp;</SPAN><I>number of operations</I>.<SPAN>&nbsp;</SPAN><B>This is done under the assumption that the time it takes for an operation to complete is the same regardless of the number of active threads, which is a correct assumption for single-threaded code, but an invalid one when it comes to multi-threaded programs</B>.<BR>The way the CPU's cache-coherence mechanisms work, makes it so that contention on (atomic) variables that are being accessed by multiple threads/cores can cause an operation/instruction to take much longer in certain situations (due to cache-misses). If you don't believe me then take a look at this post in the<SPAN>&nbsp;</SPAN><A style="TEXT-DECORATION: none; COLOR: rgb(34,136,187)" href="http://mechanical-sympathy.blogspot.co.uk/2011/09/adventures-with-atomiclong.html">Mechanical Sympathy blog</A>.<BR>This is the main reason (or one of the main reasons) why many implementations of Wait-Free data structures are much slower than Lock-Free implementations of the same data structures, because although they have a stronger guarantee on the total number of operations, each operation may take much longer to complete because it causes more contention... and because they may have a larger average number of operations.<BR><BR><BR>In practice, there is little difference between "Wait-Free" and "Wait-Free Bounded". This paper has a good explanation on it: "<A style="TEXT-DECORATION: none; COLOR: rgb(34,136,187)" href="http://www.cs.technion.ac.il/~moran/r/PS/bm94.ps">Wait-Freedom vs. Bounded Wait-Freedom in Public Data Structures</A>"<BR><BR>Another detail is that there is no "Wait-Free<SPAN>&nbsp;</SPAN><I>Bounded<SPAN>&nbsp;</SPAN></I>Population Oblivious" because being Population Oblivious implies an upper bound on the worst-case number operations it takes to complete.<BR><BR><BR><BR>Hope that this post has helped you understand the differences between Lock-Free and Wait-Free.<BR><BR>
<DIV></DIV>