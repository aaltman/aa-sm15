<B>: </B>Lock-Free and Wait-Free, definition and examples 
<H3></H3>
<DIV class=post-header style='FONT-SIZE: 10px; FONT-FAMILY: "Trebuchet MS", Trebuchet, Verdana, sans-serif; WHITE-SPACE: normal; WORD-SPACING: 0px; TEXT-TRANSFORM: none; FONT-WEIGHT: 400; COLOR: rgb(102,102,102); FONT-STYLE: normal; ORPHANS: 2; WIDOWS: 2; MARGIN: 0px 0px 1.5em; LETTER-SPACING: normal; LINE-HEIGHT: 1.6; BACKGROUND-COLOR: rgb(255,255,255); TEXT-INDENT: 0px; -webkit-text-stroke-width: 0px; text-decoration-thickness: initial; text-decoration-style: initial; text-decoration-color: initial; font-variant-ligatures: normal; font-variant-caps: normal'>
<DIV class=post-header-line-1></DIV></DIV>
<DIV id=post-body-7520744292207940889 class="post-body entry-content" style='FONT-SIZE: 13px; FONT-FAMILY: "Trebuchet MS", Trebuchet, Verdana, sans-serif; WIDTH: 546px; WHITE-SPACE: normal; WORD-SPACING: 0px; POSITION: relative; TEXT-TRANSFORM: none; FONT-WEIGHT: 400; COLOR: rgb(102,102,102); FONT-STYLE: normal; ORPHANS: 2; WIDOWS: 2; LETTER-SPACING: normal; LINE-HEIGHT: 1.4; BACKGROUND-COLOR: rgb(255,255,255); TEXT-INDENT: 0px; -webkit-text-stroke-width: 0px; text-decoration-thickness: initial; text-decoration-style: initial; text-decoration-color: initial; font-variant-ligatures: normal; font-variant-caps: normal' itemprop="description articleBody">After searching around in Google, I found that there is no single place that properly explains the different<SPAN>&nbsp;</SPAN><B>Progress Conditions</B><SPAN>&nbsp;</SPAN>that a concurrent algorithm or data structure may provide. Even "<A style="TEXT-DECORATION: none; COLOR: rgb(34,136,187)" href="http://www.amazon.com/The-Multiprocessor-Programming-Revised-Reprint/dp/0123973376">The Art of Multiprocessor Programming</A>" has these definitions a bit spread around the book, and most of them are single one-line sentences that are way to cryptic for common mortals like myself, so I decided to put together what I know on the subject, and add some examples for each case.<BR><BR><FONT class=extract>We start with a list of the different classifications for Progress Conditions separated into the four main groups Blocking, Obstruction-Free, Lock-Free, and Wait-Free:<BR><BR></FONT><FONT class=extract><SPAN style="FONT-FAMILY: Arial, Helvetica, sans-serif">Blocking<BR>&nbsp;&nbsp;&nbsp; 1. Blocking<BR>&nbsp;&nbsp;&nbsp; 2. Starvation-Free</SPAN><BR></FONT><FONT class=extract><SPAN style="FONT-FAMILY: Arial, Helvetica, sans-serif">Obstruction-Free<BR>&nbsp;&nbsp;&nbsp; 3. Obstruction-Free<BR>Lock-Free<BR>&nbsp;&nbsp;&nbsp; 4. Lock-Free (LF)<BR>Wait-Free<BR>&nbsp;&nbsp;&nbsp; 5. Wait-Free (WF)&nbsp;<BR>&nbsp; &nbsp; 6. Wait-Free Bounded (WFB)</SPAN><BR><SPAN style="FONT-FAMILY: Arial, Helvetica, sans-serif"><SPAN style="FONT-FAMILY: Arial, Helvetica, sans-serif">&nbsp;&nbsp;&nbsp; 7. Wait-Free Population Oblivious (WFPO)</SPAN></SPAN></FONT><BR><BR><BR>Before we dive into the definition of each of these terms, let us look at some of the details behind them.<BR><BR>From what's written on section 3.6 of "The Art of Multiprocessor Programming", it is difficult to understand whether or not the definitions for Wait-Free Bounded and Wait-Free Population Oblivious are orthogonal or not. Personally, I think that having an algorithm that is Wait-Free Population-Oblivious implies that it is bounded and, therefore, it is also Wait-Free Bounded. This means that a function (or algorithm, or class) can be WF, or WFB, or WFPO, this last one being the "<I>best</I>" of all the Progress Conditions.<BR><BR><FONT class=extract>The examples we will give here are all concerning the progress condition of a particular function (of an algorithm, or class), and not the full algorithm. We do this because different functions in a given algorithm may have very different progress guarantees, like for example: the Write operations may be Blocking, while the Read operations be Wait-Free Population Oblivious, something that is not obvious when you first look at Lock-Free and Wait-Free data structures.<BR><BR>Yes, you read it correctly: a data structure may have some of its functions Blocking and others Lock-Free and others even Wait-Free. On the other hand, when we say that a particular data structure is Lock-Free it means that<SPAN>&nbsp;</SPAN><I>all<SPAN>&nbsp;</SPAN></I>its operations are Lock-Free, or better.</FONT><BR>There is no standard strict ranking in the literature of which one is<SPAN>&nbsp;</SPAN><I>better</I>, but it is usually implied as :<BR><SPAN style='FONT-FAMILY: "Courier New", Courier, monospace'>Wait-Free is<SPAN>&nbsp;</SPAN><I>better<SPAN>&nbsp;</SPAN></I>than Lock-Free which is<SPAN>&nbsp;</SPAN><I>better<SPAN>&nbsp;</SPAN></I>than Blocking.</SPAN><BR><BR>The reason for this is that, there aren't that many (practical) data structures that are Lock-Free or Wait-Free, so the issue of properly classifying them doesn't usually show up. Andreia and I have come up with so many different variations of different concurrent algorithms with mixed Progress Conditions that we had to start naming them properly and "sorting" them, to keep a handle on it, and to figure out which ones were worth researching.<BR>Our order is the one described in the beginning of the post, where item<SPAN>&nbsp;</SPAN><SPAN style="FONT-FAMILY: Arial, Helvetica, sans-serif">1. Blocking</SPAN><SPAN>&nbsp;</SPAN>is the worst, and<SPAN>&nbsp;</SPAN><SPAN style="FONT-FAMILY: Arial, Helvetica, sans-serif">7. WFPO</SPAN><SPAN>&nbsp;</SPAN>is the best possible kind of guarantee you can get.</DIV>