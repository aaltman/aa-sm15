<DIV class=mYVXT style="BOX-SIZING: border-box; WIDTH: 1271px; VERTICAL-ALIGN: middle; DISPLAY: table-cell">
<DIV tabIndex=-1 class="LS81yb VICjCf j5pSsc db35Fc" style="BOX-SIZING: border-box; MAX-WIDTH: 1280px; WIDTH: 1271px; OUTLINE-WIDTH: 0px; OUTLINE-STYLE: none; PADDING-LEFT: 48px; MARGIN: 0px auto; OUTLINE-COLOR: invert; PADDING-RIGHT: 48px">
<DIV class="hJDwNd-AhqUyc-uQSCkd Ft7HRd-AhqUyc-uQSCkd purZT-AhqUyc-II5mzb ZcASvf-AhqUyc-II5mzb pSzOP-AhqUyc-qWD73c Ktthjf-AhqUyc-qWD73c JNdkSc SQVYQc" style="BOX-SIZING: border-box; WIDTH: 1175px; VERTICAL-ALIGN: top; POSITION: relative; PADDING-LEFT: 0px; DISPLAY: inline-block; PADDING-RIGHT: 0px">
<DIV class="JNdkSc-SmKAyb LkDMRd" style="BOX-SIZING: border-box; PADDING-LEFT: 14px; PADDING-RIGHT: 14px">
<DIV style="BOX-SIZING: border-box" jsname="F57UId" jsaction="zXBUYb:zTPCnb;zQF9Uc:Qxe3nd;" jscontroller="sGwD4d">
<DIV class="oKdM2c ZZyype Kzv0Me" style="BOX-SIZING: border-box; MARGIN-BOTTOM: 0px; MAX-WIDTH: 1280px; WIDTH: 1145px; MARGIN-TOP: 0px">
<DIV id=h.3a1d27e4f28c40eb_1192 class="hJDwNd-AhqUyc-uQSCkd Ft7HRd-AhqUyc-uQSCkd jXK9ad D2fZ2 zu5uec OjCsFc dmUFtb wHaque g5GTcb JYTMs" style="BOX-SIZING: border-box; WIDTH: 1145px; VERTICAL-ALIGN: top; WHITE-SPACE: pre-wrap; POSITION: relative; PADDING-LEFT: 0px; DISPLAY: inline-block; PADDING-RIGHT: 0px">
<DIV class=jXK9ad-SmKAyb style="BOX-SIZING: border-box; WIDTH: 1145px">
<DIV class="tyJCtd mGzaTb Depvyb baZpAe" style="BOX-SIZING: border-box; WIDTH: 1145px; POSITION: relative; PADDING-BOTTOM: 8px; PADDING-TOP: 8px; PADDING-LEFT: 8px; PADDING-RIGHT: 8px; overflow-wrap: break-word">
<P class="CDt4Ke zfr3Q" style='BOX-SIZING: border-box; FONT-SIZE: 11pt; TEXT-DECORATION: ; FONT-FAMILY: "Open Sans"; POSITION: relative; COLOR: rgb(33,33,33); OUTLINE-WIDTH: medium; PADDING-TOP: 0px; OUTLINE-STYLE: none; MARGIN: 0px; OUTLINE-COLOR: invert; LINE-HEIGHT: 1.6; font-variant-ligatures: none' dir=ltr>I'm going to share my thoughts on concurrent priority queues (CPQ) in general and tbb::concurrent_priority_queue (Intel Threading Building Blocks) in particular.</P>
<P class="CDt4Ke zfr3Q" style='BOX-SIZING: border-box; FONT-SIZE: 11pt; TEXT-DECORATION: ; FONT-FAMILY: "Open Sans"; POSITION: relative; COLOR: rgb(33,33,33); OUTLINE-WIDTH: medium; OUTLINE-STYLE: none; MARGIN: 15px 0px 0px; OUTLINE-COLOR: invert; LINE-HEIGHT: 1.6; font-variant-ligatures: none' dir=ltr>For information on tbb::concurrent_priority_queue check out <SPAN class=" aw5Odc" style="BOX-SIZING: border-box; TEXT-DECORATION: underline; COLOR: "><A class=XqQF9c style="BOX-SIZING: border-box; TEXT-DECORATION: none; COLOR: ; pointer-events: all" href="http://www.google.com/url?q=http%3A%2F%2Fsoftware.intel.com%2Fen-us%2Fblogs%2F2010%2F12%2F02%2Fintel-threading-building-blocks-version-30-update-4-showcases-its-first-community-preview-feature-concurrent-priority-queue&amp;sa=D&amp;sntz=1&amp;usg=AOvVaw16q_cURIm-PnRBg2ZdlnyB" target=_blank>the blog post</A></SPAN>. First of all, it's not all that "concurrent" at all. It uses mutual exclusion, it uses blocking, and in the end at most 1 thread does useful work at any given moment in time. There are nice pictures in the blog that show that it does not scale.</P>
<P class="CDt4Ke zfr3Q" style='BOX-SIZING: border-box; FONT-SIZE: 11pt; TEXT-DECORATION: ; FONT-FAMILY: "Open Sans"; POSITION: relative; COLOR: rgb(33,33,33); OUTLINE-WIDTH: medium; OUTLINE-STYLE: none; MARGIN: 15px 0px 0px; OUTLINE-COLOR: invert; LINE-HEIGHT: 1.6; font-variant-ligatures: none' dir=ltr>I think there are some ways to improve the implementation (and most likely TBB developers do not consider the first implementation as a final destination point). For example, producers do not actually need to wait (block) for the operation to complete, the only source of failure is a memory allocation error, so a producer can ensure there is enough space reserved in the queue, and immediately return once he offloaded the operation.</P>
<P class="CDt4Ke zfr3Q" style='BOX-SIZING: border-box; FONT-SIZE: 11pt; TEXT-DECORATION: ; FONT-FAMILY: "Open Sans"; POSITION: relative; COLOR: rgb(33,33,33); OUTLINE-WIDTH: medium; OUTLINE-STYLE: none; MARGIN: 15px 0px 0px; OUTLINE-COLOR: invert; LINE-HEIGHT: 1.6; font-variant-ligatures: none' dir=ltr>Another possible improvement is to increase batching. Namely, if a "handler" thread notices more work when he is about to retire, he can process more work up to to some predefined limit, I think it will improve locality somehow.</P>
<P class="CDt4Ke zfr3Q" style='BOX-SIZING: border-box; FONT-SIZE: 11pt; TEXT-DECORATION: ; FONT-FAMILY: "Open Sans"; POSITION: relative; COLOR: rgb(33,33,33); OUTLINE-WIDTH: medium; OUTLINE-STYLE: none; MARGIN: 15px 0px 0px; OUTLINE-COLOR: invert; LINE-HEIGHT: 1.6; font-variant-ligatures: none' dir=ltr>Hey, here I assume that you have skimmed through the implementation. Don't get upset if you don't, I believe it's not a way to go anyway.</P>
<P class="CDt4Ke zfr3Q" style='BOX-SIZING: border-box; FONT-SIZE: 11pt; TEXT-DECORATION: ; FONT-FAMILY: "Open Sans"; POSITION: relative; COLOR: rgb(33,33,33); OUTLINE-WIDTH: medium; OUTLINE-STYLE: none; MARGIN: 15px 0px 0px; OUTLINE-COLOR: invert; LINE-HEIGHT: 1.6; font-variant-ligatures: none' dir=ltr><FONT class=extract>Another potential route to go [AA: besides&nbsp;tbb::concurrent_priority_queue]&nbsp;is concurrent ordered skip-lists. Skip-lists are randomized, so no need for global repair/rebalance operations that are required for heaps/trees. Enqueues are naturally distributed (=scalable) over the whole skip-list; however dequeue operations are all happen at list head (=!scalable) (can be made lockfree, though, but that's not a panacea).</FONT> A possible improvement for skip-list based CPQ would be to embed a concurrent queue into each list node; the queue will contain elements with equal priority. So, for example, if a head node contains a queue with, say, 10 element, 9 subsequent CPQ dequeue operations will just pop an element from the queue (no need to do anything with skip-list itself). I would consider such design as the best choice (from available choices, not quite good anyway) for general CPQ for now.</P>
<P class="CDt4Ke zfr3Q" style='BOX-SIZING: border-box; FONT-SIZE: 11pt; TEXT-DECORATION: ; FONT-FAMILY: "Open Sans"; POSITION: relative; COLOR: rgb(33,33,33); OUTLINE-WIDTH: medium; OUTLINE-STYLE: none; MARGIN: 15px 0px 0px; OUTLINE-COLOR: invert; LINE-HEIGHT: 1.6; font-variant-ligatures: none' dir=ltr><FONT class=extract>General priority queues inherently non-scalable because of claimed properties - all producers and consumers must achieve strong global consensus on what is the highest priority element. Fear such things like death in a concurrent environment. Rare CPQ achieves at least 2x speedup under load.</FONT></P>
<P class="CDt4Ke zfr3Q" style='BOX-SIZING: border-box; FONT-SIZE: 11pt; TEXT-DECORATION: ; FONT-FAMILY: "Open Sans"; POSITION: relative; COLOR: rgb(33,33,33); OUTLINE-WIDTH: medium; OUTLINE-STYLE: none; MARGIN: 15px 0px 0px; OUTLINE-COLOR: invert; LINE-HEIGHT: 1.6; font-variant-ligatures: none' dir=ltr>So, if one *really* needs a CPQ, I would suggest 3 approaches: either give up on total consistency (strong priorities), or use specialized CPQ design, or both.</P>
<P class="CDt4Ke zfr3Q" style='BOX-SIZING: border-box; FONT-SIZE: 11pt; TEXT-DECORATION: ; FONT-FAMILY: "Open Sans"; POSITION: relative; COLOR: rgb(33,33,33); OUTLINE-WIDTH: medium; OUTLINE-STYLE: none; MARGIN: 15px 0px 0px; OUTLINE-COLOR: invert; LINE-HEIGHT: 1.6; font-variant-ligatures: none' dir=ltr><FONT class=extract>By giving up on total consistency I mean a distributed design (on a par with the distributed work-stealing Cilk-like scheduler). That is, each thread has it's own CPQ, a thread enqueues and dequeues elements from the own queue, and if it is empty he tries to steal a high priority element (or a batch of elements) from another thread. Such design is naturally distributed (=scalable). However, of course, threads will work on not the globally highest priority elements. As to whether it is a problem for a particuar system or not depends.</FONT></P>
<P class="CDt4Ke zfr3Q" style='BOX-SIZING: border-box; FONT-SIZE: 11pt; TEXT-DECORATION: ; FONT-FAMILY: "Open Sans"; POSITION: relative; COLOR: rgb(33,33,33); OUTLINE-WIDTH: medium; OUTLINE-STYLE: none; MARGIN: 15px 0px 0px; OUTLINE-COLOR: invert; LINE-HEIGHT: 1.6; font-variant-ligatures: none' dir=ltr><FONT class=extract>By specialized CPQ design I mean the following. A lot of systems are Ok with only, say, 5 or even 3 priorities - low, normal, high. So, you can just setup 3 concurrent queues - one for each priority level, and threads will poll the queues starting from high prio queue to low prio queue (checking few empty high prio queues is not a big deal performance-wise). Such design allows a lot of flexibility. For example, if you have single-producer/single-consumer (SPSC) scenario you can setup SPSC queues (which are a way faster and more scalable that general MPMC queues) (similarly for multi-producer/single-consumer and single-producer/multi-consumer scenarios). Or you can use array-based queues, or linked-list based queues, or whatever queues are the most suitable for you in a particular situation.</FONT></P>
<P class="CDt4Ke zfr3Q" style='BOX-SIZING: border-box; FONT-SIZE: 11pt; TEXT-DECORATION: ; FONT-FAMILY: "Open Sans"; POSITION: relative; COLOR: rgb(33,33,33); OUTLINE-WIDTH: medium; OUTLINE-STYLE: none; MARGIN: 15px 0px 0px; OUTLINE-COLOR: invert; LINE-HEIGHT: 1.6; font-variant-ligatures: none' dir=ltr>Or, you are able to prevent starvation of low prio elements, that is, if there is a constant flow of high and normal prio elements, you still may want to process some low prio elements in between (it's a good idea for most systems, your OS definitely does this for threads). Separate queues allow you to do this, while monolithic CPQ does not.</P>
<P class="CDt4Ke zfr3Q" style='BOX-SIZING: border-box; FONT-SIZE: 11pt; TEXT-DECORATION: ; FONT-FAMILY: "Open Sans"; POSITION: relative; COLOR: rgb(33,33,33); OUTLINE-WIDTH: medium; OUTLINE-STYLE: none; MARGIN: 15px 0px 0px; OUTLINE-COLOR: invert; LINE-HEIGHT: 1.6; font-variant-ligatures: none' dir=ltr>Moreover, if you have priorities (-inf..+inf) but expect to handle elements with priorities -1, 0, +1 most of the time, you can setup 3 concurrent queues for -1, 0, +1 and 2 CPQs for (-inf..-1) and (+1..+inf) (which are expected to be mostly idle).</P>
<P class="CDt4Ke zfr3Q" style='BOX-SIZING: border-box; FONT-SIZE: 11pt; TEXT-DECORATION: ; FONT-FAMILY: "Open Sans"; POSITION: relative; COLOR: rgb(33,33,33); OUTLINE-WIDTH: medium; OUTLINE-STYLE: none; MARGIN: 15px 0px 0px; OUTLINE-COLOR: invert; LINE-HEIGHT: 1.6; font-variant-ligatures: none' dir=ltr>As I've said, you can combine both approaches - a distributed setup of quantized queues.</P>
<P class="CDt4Ke zfr3Q" style='BOX-SIZING: border-box; FONT-SIZE: 11pt; TEXT-DECORATION: ; FONT-FAMILY: "Open Sans"; POSITION: relative; COLOR: rgb(33,33,33); OUTLINE-WIDTH: medium; PADDING-BOTTOM: 0px; OUTLINE-STYLE: none; MARGIN: 15px 0px 0px; OUTLINE-COLOR: invert; LINE-HEIGHT: 1.6; font-variant-ligatures: none' dir=ltr>I believe it's the way to go. By the way, most modern OS employ exactly such a design for thread scheduling not without a reason. Don't expect spicing up your system with a magical general "concurrent" priority queue to fix all your problems.</P></DIV></DIV></DIV></DIV></DIV></DIV></DIV></DIV></DIV></SECTION><SECTION id=h.3a1d27e4f28c40eb_1193 class=yaqOZd style="BOX-SIZING: border-box; WIDTH: 1271px; TABLE-LAYOUT: fixed; POSITION: relative; DISPLAY: table; background-size: cover">
<DIV class=IFuOkc style="BOX-SIZING: border-box; HEIGHT: 439px; WIDTH: 1271px; TABLE-LAYOUT: fixed; POSITION: absolute; LEFT: 0px; DISPLAY: table-cell; TOP: 0px; pointer-events: none; background-size: cover"></DIV>
<DIV class=mYVXT style="BOX-SIZING: border-box; WIDTH: 1271px; VERTICAL-ALIGN: middle; DISPLAY: table-cell">
<DIV tabIndex=-1 class="LS81yb VICjCf j5pSsc db35Fc" style="BOX-SIZING: border-box; MAX-WIDTH: 1280px; WIDTH: 1271px; OUTLINE-WIDTH: 0px; OUTLINE-STYLE: none; PADDING-LEFT: 48px; MARGIN: 0px auto; OUTLINE-COLOR: invert; PADDING-RIGHT: 48px">
<DIV class="hJDwNd-AhqUyc-c5RTEf Ft7HRd-AhqUyc-c5RTEf JNdkSc SQVYQc L6cTce-purZT L6cTce-pSzOP" style="BOX-SIZING: border-box; WIDTH: 293px; VERTICAL-ALIGN: top; POSITION: relative; PADDING-LEFT: 0px; DISPLAY: inline-block; PADDING-RIGHT: 0px">
<DIV class="JNdkSc-SmKAyb LkDMRd" style="BOX-SIZING: border-box; PADDING-LEFT: 14px; PADDING-RIGHT: 14px">
<DIV style="BOX-SIZING: border-box" jsname="F57UId" jsaction="zXBUYb:zTPCnb;zQF9Uc:Qxe3nd;" jscontroller="sGwD4d"></DIV></DIV></DIV>
<DIV class="hJDwNd-AhqUyc-wNfPc Ft7HRd-AhqUyc-wNfPc purZT-AhqUyc-II5mzb ZcASvf-AhqUyc-II5mzb pSzOP-AhqUyc-wNfPc Ktthjf-AhqUyc-wNfPc JNdkSc SQVYQc" style="BOX-SIZING: border-box; WIDTH: 489px; VERTICAL-ALIGN: top; POSITION: relative; PADDING-LEFT: 0px; DISPLAY: inline-block; PADDING-RIGHT: 0px">
<DIV class="JNdkSc-SmKAyb LkDMRd" style="BOX-SIZING: border-box; PADDING-LEFT: 14px; PADDING-RIGHT: 14px">
<DIV style="BOX-SIZING: border-box" jsname="F57UId" jsaction="zXBUYb:zTPCnb;zQF9Uc:Qxe3nd;" jscontroller="sGwD4d">
<DIV class="oKdM2c ZZyype Kzv0Me" style="BOX-SIZING: border-box; MARGIN-BOTTOM: 0px; MAX-WIDTH: 1280px; WIDTH: 460px; MARGIN-TOP: 0px">
<DIV id=h.3a1d27e4f28c40eb_1196 class="hJDwNd-AhqUyc-wNfPc Ft7HRd-AhqUyc-wNfPc pSzOP-AhqUyc-wNfPc Ktthjf-AhqUyc-wNfPc jXK9ad D2fZ2 zu5uec OjCsFc dmUFtb wHaque g5GTcb" style="BOX-SIZING: border-box; WIDTH: 460px; VERTICAL-ALIGN: top; POSITION: relative; PADDING-LEFT: 0px; DISPLAY: inline-block; PADDING-RIGHT: 0px">
<DIV class=jXK9ad-SmKAyb style="BOX-SIZING: border-box; WIDTH: 460px">
<DIV class="tyJCtd OWlOyc baZpAe" style="BOX-SIZING: border-box; WIDTH: 460px; POSITION: relative">
<DIV style="BOX-SIZING: border-box" jsaction="rcuQ6b:rcuQ6b;" jscontroller="VYKRW">
<DIV class="WIdY2d M1aSXe" style="BOX-SIZING: border-box; OVERFLOW: hidden; HEIGHT: 391px; WIDTH: 460px; POSITION: relative; LINE-HEIGHT: 0">
<DIV style="BOX-SIZING: border-box; FONT-SIZE: 16px; FONT-FAMILY: sans-serif; WHITE-SPACE: normal; WORD-SPACING: 0px; TEXT-TRANSFORM: none; FONT-WEIGHT: 400; COLOR: rgb(0,0,0); FONT-STYLE: normal; PADDING-TOP: 391px; ORPHANS: 2; WIDOWS: 2; LETTER-SPACING: normal; TEXT-INDENT: 0px; font-variant-ligatures: normal; font-variant-caps: normal; -webkit-text-stroke-width: 0px; text-decoration-thickness: initial; text-decoration-style: initial; text-decoration-color: initial" jsname="WXxXjd"></DIV><BR class=Apple-interchange-newline></DIV></DIV></DIV></DIV></DIV></DIV></DIV></DIV></DIV></DIV></DIV>