<b> : </b>Heap Only Tuples (HOT)<BR>======================</P>
<P>The Heap Only Tuple (HOT) feature eliminates redundant index entries and<BR>allows the re-use of space taken by DELETEd or obsoleted UPDATEd tuples<BR>without performing a table-wide vacuum.&nbsp; It does this by allowing<BR>single-page vacuuming, also called "defragmentation" or "pruning".</P>
<P>Note: there is a Glossary at the end of this document that may be helpful<BR>for first-time readers.</P>
<P><BR>Technical Challenges<BR>--------------------</P>
<P>Page-at-a-time vacuuming is normally impractical because of the costs of<BR>finding and removing the index entries that link to the tuples to be<BR>reclaimed.&nbsp; Standard vacuuming scans the indexes to ensure all such index<BR>entries are removed, amortizing the index scan cost across as many dead<BR>tuples as possible; this approach does not scale down well to the case of<BR>reclaiming just a few tuples.&nbsp; In principle one could recompute the index<BR>keys and do standard index searches to find the index entries, but this is<BR>risky in the presence of possibly-buggy user-defined functions in<BR>functional indexes.&nbsp; An allegedly immutable function that in fact is not<BR>immutable might prevent us from re-finding an index entry (and we cannot<BR>throw an error for not finding it, in view of the fact that dead index<BR>entries are sometimes reclaimed early).&nbsp; That would lead to a seriously<BR>corrupt index, in the form of entries pointing to tuple slots that by now<BR>contain some unrelated content.&nbsp; In any case we would prefer to be able<BR>to do vacuuming without invoking any user-written code.</P>
<P>HOT solves this problem for two restricted but useful special cases:</P>
<P>First, where a tuple is repeatedly updated in ways that do not change<BR>its indexed columns.&nbsp; (Here, "indexed column" means any column referenced<BR>at all in an index definition, including for example columns that are<BR>tested in a partial-index predicate but are not stored in the index.)</P>
<P>Second, where the modified columns are only used in indexes that do not<BR>contain tuple IDs, but maintain summaries of the indexed data by block.<BR>As these indexes don't contain references to individual tuples, they<BR>can't remove tuple references in VACUUM, and thus don't need to get a new<BR>and unique reference to a tuple.&nbsp; These indexes still need to be notified<BR>of the new column data, but don't need a new HOT chain to be established.</P>
<P>An additional property of HOT is that it reduces index size by avoiding<BR>the creation of identically-keyed index entries.&nbsp; This improves search<BR>speeds.</P>
<P><BR>Update Chains With a Single Index Entry<BR>---------------------------------------</P>
<P>Without HOT, every version of a row in an update chain has its own index<BR>entries, even if all indexed columns are the same.&nbsp; With HOT, a new tuple<BR>placed on the same page and with all indexed columns the same as its<BR>parent row version does not get new index entries.&nbsp; This means there is<BR>only one index entry for the entire update chain on the heap page.<BR>An index-entry-less tuple is marked with the HEAP_ONLY_TUPLE flag.<BR>The prior row version is marked HEAP_HOT_UPDATED, and (as always in an<BR>update chain) its t_ctid field links forward to the newer version.</P>
<P>For example:</P>
<P>&nbsp;Index points to 1<BR>&nbsp;lp [1]&nbsp; [2]</P>
<P>&nbsp;[111111111]-&gt;[2222222222]</P>
<P>In the above diagram, the index points to line pointer 1, and tuple 1 is<BR>marked as HEAP_HOT_UPDATED.&nbsp; Tuple 2 is a HOT tuple, meaning it has<BR>no index entry pointing to it, and is marked as HEAP_ONLY_TUPLE.<BR>Although tuple 2 is not directly referenced by the index, it can still be<BR>found by an index search: after traversing from the index to tuple 1,<BR>the index search proceeds forward to child tuples as long as it sees the<BR>HEAP_HOT_UPDATED flag set.&nbsp; Since we restrict the HOT chain to lie within<BR>a single page, this requires no additional page fetches and doesn't<BR>introduce much performance penalty.</P>
<P>Eventually, tuple 1 will no longer be visible to any transaction.<BR>At that point its space could be reclaimed, but its line pointer cannot,<BR>since the index still links to that line pointer and we still need to<BR>be able to find tuple 2 in an index search.&nbsp; HOT handles this by turning<BR>line pointer 1 into a "redirecting line pointer", which links to tuple 2<BR>but has no actual tuple attached.&nbsp; This state of affairs looks like</P>
<P>&nbsp;Index points to 1<BR>&nbsp;lp [1]-&gt;[2]</P>
<P>&nbsp;[2222222222]</P>
<P>If now the row is updated again, to version 3, the page looks like this:</P>
<P>&nbsp;Index points to 1<BR>&nbsp;lp [1]-&gt;[2]&nbsp; [3]</P>
<P>&nbsp;[2222222222]-&gt;[3333333333]</P>
<P>At some later time when no transaction can see tuple 2 in its snapshot,<BR>tuple 2 and its line pointer can be pruned entirely:</P>
<P>&nbsp;Index points to 1<BR>&nbsp;lp [1]------&gt;[3]</P>
<P>&nbsp;[3333333333]</P>
<P>This is safe because no index entry points to line pointer 2.&nbsp; Subsequent<BR>insertions into the page can now recycle both line pointer 2 and the<BR>space formerly used by tuple 2.</P>
<P>If an update changes any column indexed by a non-summarizing indexes, or<BR>if there is not room on the same page for the new tuple, then the HOT<BR>chain ends: the last member has a regular t_ctid link to the next version<BR>and is not marked HEAP_HOT_UPDATED.&nbsp; (In principle we could continue a<BR>HOT chain across pages, but this would destroy the desired property of<BR>being able to reclaim space with just page-local manipulations.&nbsp; Anyway,<BR>we don't want to have to chase through multiple heap pages to get from an<BR>index entry to the desired tuple, so it seems better to create a new<BR>index entry for the new tuple.)&nbsp; If further updates occur, the next<BR>version could become the root of a new HOT chain.</P>
<P>Line pointer 1 has to remain as long as there is any non-dead member of<BR>the chain on the page.&nbsp; When there is not, it is marked "dead".<BR>This lets us reclaim the last child line pointer and associated tuple<BR>immediately.&nbsp; The next regular VACUUM pass can reclaim the index entries<BR>pointing at the line pointer and then the line pointer itself.&nbsp; Since a<BR>line pointer is small compared to a tuple, this does not represent an<BR>undue space cost.</P>
<P>Note: we can use a "dead" line pointer for any DELETEd tuple,<BR>whether it was part of a HOT chain or not.&nbsp; This allows space reclamation<BR>in advance of running VACUUM for plain DELETEs as well as HOT updates.</P>
<P>The requirement for doing a HOT update is that indexes which point to<BR>the root line pointer (and thus need to be cleaned up by VACUUM when the<BR>tuple is dead) do not reference columns which are updated in that HOT<BR>chain.&nbsp; Summarizing indexes (such as BRIN) are assumed to have no<BR>references to individual tuples and thus are ignored when checking HOT<BR>applicability.&nbsp; The updated columns are checked at execution time by<BR>comparing the binary representation of the old and new values.&nbsp; We insist<BR>on bitwise equality rather than using datatype-specific equality routines.<BR>The main reason to avoid the latter is that there might be multiple<BR>notions of equality for a datatype, and we don't know exactly which one<BR>is relevant for the indexes at hand.&nbsp; We assume that bitwise equality<BR>guarantees equality for all purposes.</P>
<P>If any columns that are included by non-summarizing indexes are updated,<BR>the HOT optimization is not applied, and the new tuple is inserted into<BR>all indexes of the table.&nbsp; If none of the updated columns are included in<BR>the table's indexes, the HOT optimization is applied and no indexes are<BR>updated.&nbsp; If instead the updated columns are only indexed by summarizing<BR>indexes, the HOT optimization is applied, but the update is propagated to<BR>all summarizing indexes.&nbsp; (Realistically, we only need to propagate the<BR>update to the indexes that contain the updated values, but that is yet to<BR>be implemented.)</P>
<P>Abort Cases<BR>-----------</P>
<P>If a heap-only tuple's xmin is aborted, then it can be removed immediately:<BR>it was never visible to any other transaction, and all descendant row<BR>versions must be aborted as well.&nbsp; Therefore we need not consider it part<BR>of a HOT chain.&nbsp; By the same token, if a HOT-updated tuple's xmax is<BR>aborted, there is no need to follow the chain link.&nbsp; However, there is a<BR>race condition here: the transaction that did the HOT update might abort<BR>between the time we inspect the HOT-updated tuple and the time we reach<BR>the descendant heap-only tuple.&nbsp; It is conceivable that someone prunes<BR>the heap-only tuple before that, and even conceivable that the line pointer<BR>is re-used for another purpose.&nbsp; Therefore, when following a HOT chain,<BR>it is always necessary to be prepared for the possibility that the<BR>linked-to line pointer is unused, dead, or redirected; and if it is a<BR>normal line pointer, we still have to check that XMIN of the tuple matches<BR>the XMAX of the tuple we left.&nbsp; Otherwise we should assume that we have<BR>come to the end of the HOT chain.&nbsp; Note that this sort of XMIN/XMAX<BR>matching is required when following ordinary update chains anyway.</P>
<P>(Early versions of the HOT code assumed that holding pin on the page<BR>buffer while following a HOT link would prevent this type of problem,<BR>but checking XMIN/XMAX matching is a much more robust solution.)</P>
<P><BR>Index/Sequential Scans<BR>----------------------</P>
<P>When doing an index scan, whenever we reach a HEAP_HOT_UPDATED tuple whose<BR>xmax is not aborted, we need to follow its t_ctid link and check that<BR>entry as well; possibly repeatedly until we reach the end of the HOT<BR>chain.&nbsp; (When using an MVCC snapshot it is possible to optimize this a<BR>bit: there can be at most one visible tuple in the chain, so we can stop<BR>when we find it.&nbsp; This rule does not work for non-MVCC snapshots, though.)</P>
<P>Sequential scans do not need to pay attention to the HOT links because<BR>they scan every line pointer on the page anyway.&nbsp; The same goes for a<BR>bitmap heap scan with a lossy bitmap.</P>
<P><BR>Pruning<BR>-------</P>
<P>HOT pruning means updating line pointers so that HOT chains are<BR>reduced in length, by collapsing out line pointers for intermediate dead<BR>tuples.&nbsp; Although this makes those line pointers available for re-use,<BR>it does not immediately make the space occupied by their tuples available.</P>
<P><BR>Defragmentation<BR>---------------</P>
<P>Defragmentation centralizes unused space.&nbsp; After we have converted root<BR>line pointers to redirected line pointers and pruned away any dead<BR>intermediate line pointers, the tuples they linked to are free space.<BR>But unless that space is adjacent to the central "hole" on the page<BR>(the pd_lower-to-pd_upper area) it cannot be used by tuple insertion.<BR>Defragmentation moves the surviving tuples to coalesce all the free<BR>space into one "hole".&nbsp; This is done with the same PageRepairFragmentation<BR>function that regular VACUUM uses.</P>
<P><BR>When can/should we prune or defragment?<BR>---------------------------------------</P>
<P>This is the most interesting question in HOT implementation, since there<BR>is no simple right answer: we must use heuristics to determine when it's<BR>most efficient to perform pruning and/or defragmenting.</P>
<P>We cannot prune or defragment unless we can get a "buffer cleanup lock"<BR>on the target page; otherwise, pruning might destroy line pointers that<BR>other backends have live references to, and defragmenting might move<BR>tuples that other backends have live pointers to.&nbsp; Thus the general<BR>approach must be to heuristically decide if we should try to prune<BR>or defragment, and if so try to acquire the buffer cleanup lock without<BR>blocking.&nbsp; If we succeed we can proceed with our housekeeping work.<BR>If we cannot get the lock (which should not happen often, except under<BR>very heavy contention) then the housekeeping has to be postponed till<BR>some other time.&nbsp; The worst-case consequence of this is only that an<BR>UPDATE cannot be made HOT but has to link to a new tuple version placed on<BR>some other page, for lack of centralized space on the original page.</P>
<P>Ideally we would do defragmenting only when we are about to attempt<BR>heap_update on a HOT-safe tuple.&nbsp; The difficulty with this approach<BR>is that the update query has certainly got a pin on the old tuple, and<BR>therefore our attempt to acquire a buffer cleanup lock will always fail.<BR>(This corresponds to the idea that we don't want to move the old tuple<BR>out from under where the query's HeapTuple pointer points.&nbsp; It might<BR>be possible to finesse that, but it seems fragile.)</P>
<P>Pruning, however, is potentially useful even when we are not about to<BR>insert a new tuple, since shortening a HOT chain reduces the cost of<BR>subsequent index searches.&nbsp; However it is unclear that this gain is<BR>large enough to accept any extra maintenance burden for.</P>
<P>The currently planned heuristic is to prune and defrag when first accessing<BR>a page that potentially has prunable tuples (as flagged by the pd_prune_xid<BR>page hint field) and that either has free space less than MAX(fillfactor<BR>target free space, BLCKSZ/10) *or* has recently had an UPDATE fail to<BR>find enough free space to store an updated tuple version.&nbsp; (These rules<BR>are subject to change.)</P>
<P>We have effectively implemented the "truncate dead tuples to just line<BR>pointer" idea that has been proposed and rejected before because of fear<BR>of line pointer bloat: we might end up with huge numbers of line pointers<BR>and just a few actual tuples on a page.&nbsp; To limit the damage in the worst<BR>case, and to keep various work arrays as well as the bitmaps in bitmap<BR>scans reasonably sized, the maximum number of line pointers per page<BR>is arbitrarily capped at MaxHeapTuplesPerPage (the most tuples that<BR>could fit without HOT pruning).</P>
<P>Effectively, space reclamation happens during tuple retrieval when the<BR>page is nearly full (&lt;10% free) and a buffer cleanup lock can be<BR>acquired.&nbsp; This means that UPDATE, DELETE, and SELECT can trigger space<BR>reclamation, but often not during INSERT ... VALUES because it does<BR>not retrieve a row.</P>
<P><BR>VACUUM<BR>------</P>
<P>There is little change to regular vacuum.&nbsp; It performs pruning to remove<BR>dead heap-only tuples, and cleans up any dead line pointers as if they were<BR>regular dead tuples.</P>
<P><BR>Statistics<BR>----------</P>
<P>Currently, we count HOT updates the same as cold updates for statistics<BR>purposes, though there is an additional per-table counter that counts<BR>only HOT updates.&nbsp; When a page pruning operation is able to remove a<BR>physical tuple by eliminating an intermediate heap-only tuple or<BR>replacing a physical root tuple by a redirect pointer, a decrement in<BR>the table's number of dead tuples is reported to pgstats, which may<BR>postpone autovacuuming.&nbsp; Note that we do not count replacing a root tuple<BR>by a DEAD line pointer as decrementing dead_tuples; we still want<BR>autovacuum to run to clean up the index entries and DEAD item.</P>
<P>This area probably needs further work ...</P>
<P><BR>CREATE INDEX<BR>------------</P>
<P>CREATE INDEX presents a problem for HOT updates.&nbsp; While the existing HOT<BR>chains all have the same index values for existing indexes, the columns<BR>in the new index might change within a pre-existing HOT chain, creating<BR>a "broken" chain that can't be indexed properly.</P>
<P>To address this issue, regular (non-concurrent) CREATE INDEX makes the<BR>new index usable only by new transactions and transactions that don't<BR>have snapshots older than the CREATE INDEX command.&nbsp; This prevents<BR>queries that can see the inconsistent HOT chains from trying to use the<BR>new index and getting incorrect results.&nbsp; Queries that can see the index<BR>can only see the rows that were visible after the index was created,<BR>hence the HOT chains are consistent for them.</P>
<P>Entries in the new index point to root tuples (tuples with current index<BR>pointers) so that our index uses the same index pointers as all other<BR>indexes on the table.&nbsp; However the row we want to index is actually at<BR>the *end* of the chain, ie, the most recent live tuple on the HOT chain.<BR>That is the one we compute the index entry values for, but the TID<BR>we put into the index is that of the root tuple.&nbsp; Since queries that<BR>will be allowed to use the new index cannot see any of the older tuple<BR>versions in the chain, the fact that they might not match the index entry<BR>isn't a problem.&nbsp; (Such queries will check the tuple visibility<BR>information of the older versions and ignore them, without ever looking at<BR>their contents, so the content inconsistency is OK.)&nbsp; Subsequent updates<BR>to the live tuple will be allowed to extend the HOT chain only if they are<BR>HOT-safe for all the indexes.</P>
<P>Because we have ShareLock on the table, any DELETE_IN_PROGRESS or<BR>INSERT_IN_PROGRESS tuples should have come from our own transaction.<BR>Therefore we can consider them committed since if the CREATE INDEX<BR>commits, they will be committed, and if it aborts the index is discarded.<BR>An exception to this is that early lock release is customary for system<BR>catalog updates, and so we might find such tuples when reindexing a system<BR>catalog.&nbsp; In that case we deal with it by waiting for the source<BR>transaction to commit or roll back.&nbsp; (We could do that for user tables<BR>too, but since the case is unexpected we prefer to throw an error.)</P>
<P>Practically, we prevent certain transactions from using the new index by<BR>setting pg_index.indcheckxmin to TRUE.&nbsp; Transactions are allowed to use<BR>such an index only after pg_index.xmin is below their TransactionXmin<BR>horizon, thereby ensuring that any incompatible rows in HOT chains are<BR>dead to them. (pg_index.xmin will be the XID of the CREATE INDEX<BR>transaction.&nbsp; The reason for using xmin rather than a normal column is<BR>that the regular vacuum freezing mechanism will take care of converting<BR>xmin to FrozenTransactionId before it can wrap around.)</P>
<P>This means in particular that the transaction creating the index will be<BR>unable to use the index if the transaction has old snapshots.&nbsp; We<BR>alleviate that problem somewhat by not setting indcheckxmin unless the<BR>table actually contains HOT chains with RECENTLY_DEAD members.</P>
<P>Another unpleasant consequence is that it is now risky to use SnapshotAny<BR>in an index scan: if the index was created more recently than the last<BR>vacuum, it's possible that some of the visited tuples do not match the<BR>index entry they are linked to.&nbsp; This does not seem to be a fatal<BR>objection, since there are few users of SnapshotAny and most use seqscans.<BR>The only exception at this writing is CLUSTER, which is okay because it<BR>does not require perfect ordering of the indexscan readout (and especially<BR>so because CLUSTER tends to write recently-dead tuples out of order anyway).</P>
<P><BR>CREATE INDEX CONCURRENTLY<BR>-------------------------</P>
<P>In the concurrent case we must take a different approach.&nbsp; We create the<BR>pg_index entry immediately, before we scan the table.&nbsp; The pg_index entry<BR>is marked as "not ready for inserts".&nbsp; Then we commit and wait for any<BR>transactions which have the table open to finish.&nbsp; This ensures that no<BR>new HOT updates will change the key value for our new index, because all<BR>transactions will see the existence of the index and will respect its<BR>constraint on which updates can be HOT.&nbsp; Other transactions must include<BR>such an index when determining HOT-safety of updates, even though they<BR>must ignore it for both insertion and searching purposes.</P>
<P>We must do this to avoid making incorrect index entries.&nbsp; For example,<BR>suppose we are building an index on column X and we make an index entry for<BR>a non-HOT tuple with X=1.&nbsp; Then some other backend, unaware that X is an<BR>indexed column, HOT-updates the row to have X=2, and commits.&nbsp; We now have<BR>an index entry for X=1 pointing at a HOT chain whose live row has X=2.<BR>We could make an index entry with X=2 during the validation pass, but<BR>there is no nice way to get rid of the wrong entry with X=1.&nbsp; So we must<BR>have the HOT-safety property enforced before we start to build the new<BR>index.</P>
<P>After waiting for transactions which had the table open, we build the index<BR>for all rows that are valid in a fresh snapshot.&nbsp; Any tuples visible in the<BR>snapshot will have only valid forward-growing HOT chains.&nbsp; (They might have<BR>older HOT updates behind them which are broken, but this is OK for the same<BR>reason it's OK in a regular index build.)&nbsp; As above, we point the index<BR>entry at the root of the HOT-update chain but we use the key value from the<BR>live tuple.</P>
<P>We mark the index open for inserts (but still not ready for reads) then<BR>we again wait for transactions which have the table open.&nbsp; Then we take<BR>a second reference snapshot and validate the index.&nbsp; This searches for<BR>tuples missing from the index, and inserts any missing ones.&nbsp; Again,<BR>the index entries have to have TIDs equal to HOT-chain root TIDs, but<BR>the value to be inserted is the one from the live tuple.</P>
<P>Then we wait until every transaction that could have a snapshot older than<BR>the second reference snapshot is finished.&nbsp; This ensures that nobody is<BR>alive any longer who could need to see any tuples that might be missing<BR>from the index, as well as ensuring that no one can see any inconsistent<BR>rows in a broken HOT chain (the first condition is stronger than the<BR>second).&nbsp; Finally, we can mark the index valid for searches.</P>
<P>Note that we do not need to set pg_index.indcheckxmin in this code path,<BR>because we have outwaited any transactions that would need to avoid using<BR>the index.&nbsp; (indcheckxmin is only needed because non-concurrent CREATE<BR>INDEX doesn't want to wait; its stronger lock would create too much risk of<BR>deadlock if it did.)</P>
<P><BR>DROP INDEX CONCURRENTLY<BR>-----------------------</P>
<P>DROP INDEX CONCURRENTLY is sort of the reverse sequence of CREATE INDEX<BR>CONCURRENTLY.&nbsp; We first mark the index as not indisvalid, and then wait for<BR>any transactions that could be using it in queries to end.&nbsp; (During this<BR>time, index updates must still be performed as normal, since such<BR>transactions might expect freshly inserted tuples to be findable.)<BR>Then, we clear indisready and indislive, and again wait for transactions<BR>that could be updating the index to end.&nbsp; Finally we can drop the index<BR>normally (though taking only ShareUpdateExclusiveLock on its parent table).</P>
<P>The reason we need the pg_index.indislive flag is that after the second<BR>wait step begins, we don't want transactions to be touching the index at<BR>all; otherwise they might suffer errors if the DROP finally commits while<BR>they are reading catalog entries for the index.&nbsp; If we had only indisvalid<BR>and indisready, this state would be indistinguishable from the first stage<BR>of CREATE INDEX CONCURRENTLY --- but in that state, we *do* want<BR>transactions to examine the index, since they must consider it in<BR>HOT-safety checks.</P>
<P><BR>Limitations and Restrictions<BR>----------------------------</P>
<P>It is worth noting that HOT forever forecloses alternative approaches<BR>to vacuuming, specifically the recompute-the-index-keys approach alluded<BR>to in Technical Challenges above.&nbsp; It'll be tough to recompute the index<BR>keys for a root line pointer you don't have data for anymore ...</P>
<P><BR>Glossary<BR>--------</P>
<P>Broken HOT Chain</P>
<P>&nbsp;A HOT chain in which the key value for an index has changed.</P>
<P>&nbsp;This is not allowed to occur normally but if a new index is created<BR>&nbsp;it can happen.&nbsp; In that case various strategies are used to ensure<BR>&nbsp;that no transaction for which the older tuples are visible can<BR>&nbsp;use the index.</P>
<P>Cold update</P>
<P>&nbsp;A normal, non-HOT update, in which index entries are made for<BR>&nbsp;the new version of the tuple.</P>
<P>Dead line pointer</P>
<P>&nbsp;A stub line pointer, that does not point to anything, but cannot<BR>&nbsp;be removed or reused yet because there are index pointers to it.<BR>&nbsp;Semantically same as a dead tuple.&nbsp; It has state LP_DEAD.</P>
<P>Heap-only tuple</P>
<P>&nbsp;A heap tuple with no index pointers, which can only be reached<BR>&nbsp;from indexes indirectly through its ancestral root tuple.<BR>&nbsp;Marked with HEAP_ONLY_TUPLE flag.</P>
<P>HOT-safe</P>
<P>&nbsp;A proposed tuple update is said to be HOT-safe if it changes<BR>&nbsp;none of the tuple's indexed columns.&nbsp; It will only become an<BR>&nbsp;actual HOT update if we can find room on the same page for<BR>&nbsp;the new tuple version.</P>
<P>HOT update</P>
<P>&nbsp;An UPDATE where the new tuple becomes a heap-only tuple, and no<BR>&nbsp;new index entries are made.</P>
<P>HOT-updated tuple</P>
<P>&nbsp;An updated tuple, for which the next tuple in the chain is a<BR>&nbsp;heap-only tuple.&nbsp; Marked with HEAP_HOT_UPDATED flag.</P>
<P>Indexed column</P>
<P>&nbsp;A column used in an index definition.&nbsp; The column might not<BR>&nbsp;actually be stored in the index --- it could be used in a<BR>&nbsp;functional index's expression, or used in a partial index<BR>&nbsp;predicate.&nbsp; HOT treats all these cases alike.</P>
<P>Redirecting line pointer</P>
<P>&nbsp;A line pointer that points to another line pointer and has no<BR>&nbsp;associated tuple.&nbsp; It has the special lp_flags state LP_REDIRECT,<BR>&nbsp;and lp_off is the OffsetNumber of the line pointer it links to.<BR>&nbsp;This is used when a root tuple becomes dead but we cannot prune<BR>&nbsp;the line pointer because there are non-dead heap-only tuples<BR>&nbsp;further down the chain.</P>
<P>Root tuple</P>
<P>&nbsp;The first tuple in a HOT update chain; the one that indexes point to.</P>
<P>Update chain</P>
<P>&nbsp;A chain of updated tuples, in which each tuple's ctid points to<BR>&nbsp;the next tuple in the chain. A HOT update chain is an update chain<BR>&nbsp;(or portion of an update chain) that consists of a root tuple and<BR>&nbsp;one or more heap-only tuples.&nbsp; A complete update chain can contain<BR>&nbsp;both HOT and non-HOT (cold) updated tuples.