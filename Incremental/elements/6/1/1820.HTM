<b> : </b><SPAN class=section-number style="BOX-SIZING: border-box">3.2.8.7.<SPAN>&nbsp;</SPAN></SPAN>CUDA Graphs<A title="Permalink to this headline" class=headerlink style="BOX-SIZING: border-box; CURSOR: pointer; TEXT-DECORATION: none; COLOR: ; FONT: 14px/1 FontAwesome; MARGIN-LEFT: 0.5em; DISPLAY: inline-block; text-rendering: auto; -webkit-font-smoothing: antialiased; opacity: 0" href="https://docs.nvidia.com/cuda/cuda-c-programming-guide/index.html#cuda-graphs">&#61633;</A></H4>
<P style="BOX-SIZING: border-box; COLOR: ; MARGIN: 15px 5px 15px 0px">CUDA Graphs present a new model for work submission in CUDA. A graph is a series of operations, such as kernel launches, connected by dependencies, which is defined separately from its execution. This allows a graph to be defined once and then launched repeatedly. Separating out the definition of a graph from its execution enables a number of optimizations: first, CPU launch costs are reduced compared to streams, because much of the setup is done in advance; second, presenting the whole workflow to CUDA enables optimizations which might not be possible with the piecewise work submission mechanism of streams.</P>
<P style="BOX-SIZING: border-box; COLOR: ; MARGIN: 15px 5px 15px 0px">To see the optimizations possible with graphs, consider what happens in a stream: when you place a kernel into a stream, the host driver performs a sequence of operations in preparation for the execution of the kernel on the GPU. These operations, necessary for setting up and launching the kernel, are an overhead cost which must be paid for each kernel that is issued. For a GPU kernel with a short execution time, this overhead cost can be a significant fraction of the overall end-to-end execution time.</P>
<P style="BOX-SIZING: border-box; COLOR: ; MARGIN: 15px 5px 15px 0px">Work submission using graphs is separated into three distinct stages: definition, instantiation, and execution.</P>
<UL class=simple style="LIST-STYLE-TYPE: disc; BOX-SIZING: border-box; PADDING-BOTTOM: 0px; PADDING-TOP: 0px; PADDING-LEFT: 0px; MARGIN: 0px 0px 24px; LINE-HEIGHT: 24px; PADDING-RIGHT: 0px">
<LI style="LIST-STYLE-TYPE: disc; BOX-SIZING: border-box; MARGIN-LEFT: 24px">
<P style="BOX-SIZING: border-box; COLOR: ; MARGIN: 0px 5px 0px 0px">During the definition phase, a program creates a description of the operations in the graph along with the dependencies between them.</P></LI>
<LI style="LIST-STYLE-TYPE: disc; BOX-SIZING: border-box; MARGIN-LEFT: 24px">
<P style="BOX-SIZING: border-box; COLOR: ; MARGIN: 0px 5px 0px 0px">Instantiation takes a snapshot of the graph template, validates it, and performs much of the setup and initialization of work with the aim of minimizing what needs to be done at launch. The resulting instance is known as an<SPAN>&nbsp;</SPAN><EM style="BOX-SIZING: border-box">executable graph.</EM></P></LI>
<LI style="LIST-STYLE-TYPE: disc; BOX-SIZING: border-box; MARGIN-LEFT: 24px">
<P style="BOX-SIZING: border-box; COLOR: ; MARGIN: 0px 5px 0px 0px">An executable graph may be launched into a stream, similar to any other CUDA work. It may be launched any number of times without repeating the instantiation.</P></LI></UL><SECTION id=graph-structure style="BOX-SIZING: border-box; DISPLAY: block">