<b> : </b>1.5. Level m: m-process consensus objects</H2><SPAN id=line-91 class=anchor style="FONT-SIZE: 16px; FONT-FAMILY: sans-serif; WHITE-SPACE: normal; WORD-SPACING: 0px; TEXT-TRANSFORM: none; FONT-WEIGHT: 400; COLOR: rgb(0,0,0); FONT-STYLE: normal; ORPHANS: 2; WIDOWS: 2; LETTER-SPACING: normal; BACKGROUND-COLOR: rgb(255,255,255); TEXT-INDENT: 0px; font-variant-ligatures: normal; font-variant-caps: normal; -webkit-text-stroke-width: 0px; text-decoration-thickness: initial; text-decoration-style: initial; text-decoration-color: initial"></SPAN><SPAN id=line-92 class=anchor style="FONT-SIZE: 16px; FONT-FAMILY: sans-serif; WHITE-SPACE: normal; WORD-SPACING: 0px; TEXT-TRANSFORM: none; FONT-WEIGHT: 400; COLOR: rgb(0,0,0); FONT-STYLE: normal; ORPHANS: 2; WIDOWS: 2; LETTER-SPACING: normal; BACKGROUND-COLOR: rgb(255,255,255); TEXT-INDENT: 0px; font-variant-ligatures: normal; font-variant-caps: normal; -webkit-text-stroke-width: 0px; text-decoration-thickness: initial; text-decoration-style: initial; text-decoration-color: initial"></SPAN>
<P class=line862 style="FONT-SIZE: 16px; FONT-FAMILY: sans-serif; WHITE-SPACE: normal; WORD-SPACING: 0px; TEXT-TRANSFORM: none; FONT-WEIGHT: 400; COLOR: rgb(0,0,0); FONT-STYLE: normal; ORPHANS: 2; WIDOWS: 2; LETTER-SPACING: normal; BACKGROUND-COLOR: rgb(255,255,255); TEXT-INDENT: 0px; font-variant-ligatures: normal; font-variant-caps: normal; -webkit-text-stroke-width: 0px; text-decoration-thickness: initial; text-decoration-style: initial; text-decoration-color: initial">An<SPAN>&nbsp;</SPAN><STRONG>m-process consensus object</STRONG><SPAN>&nbsp;</SPAN>has a single<SPAN>&nbsp;</SPAN><EM>consensus</EM><SPAN>&nbsp;</SPAN>operation that, the first m times it is called, returns the input value in the first operation, and thereafter returns only &#8869;. Clearly this solves m-process consensus. To show that it doesn't solve (m+1)-process consensus even when augmented with registers, run a bivalent initial configuration to a configuration C where any further operation yields a univalent state. By an argument similar to the m-register write case we can show that the pending operations in C must all be consensus operations on the same consensus object (anything else commutes or overwrites). Now run Cxyz<SUB>1</SUB>...z<SUB>k</SUB><SPAN>&nbsp;</SPAN>and Cyxz<SUB>1</SUB>...z<SUB>k</SUB>, where x and y lead to 0- and 1-valent states, and observe that p<SUB>k</SUB><SPAN>&nbsp;</SPAN>can't distinguish the resulting configurations because all it got was &#8869;. (Note: this works even if the consensus object isn't in its initial state, since we know that before x or y the configuration is still bivalent.)<SPAN id=line-93 class=anchor></SPAN><SPAN id=line-94 class=anchor></SPAN></P>
<P class=line862 style="FONT-SIZE: 16px; FONT-FAMILY: sans-serif; WHITE-SPACE: normal; WORD-SPACING: 0px; TEXT-TRANSFORM: none; FONT-WEIGHT: 400; COLOR: rgb(0,0,0); FONT-STYLE: normal; ORPHANS: 2; WIDOWS: 2; LETTER-SPACING: normal; BACKGROUND-COLOR: rgb(255,255,255); TEXT-INDENT: 0px; font-variant-ligatures: normal; font-variant-caps: normal; -webkit-text-stroke-width: 0px; text-decoration-thickness: initial; text-decoration-style: initial; text-decoration-color: initial">So the m-process consensus object has consensus number m. This shows that h<SUP>r</SUP><SUB>m</SUB><SPAN>&nbsp;</SPAN>is nonempty at each level.<SPAN id=line-95 class=anchor></SPAN><SPAN id=line-96 class=anchor></SPAN></P>
<P class=line874 style="FONT-SIZE: 16px; FONT-FAMILY: sans-serif; WHITE-SPACE: normal; WORD-SPACING: 0px; TEXT-TRANSFORM: none; FONT-WEIGHT: 400; COLOR: rgb(0,0,0); FONT-STYLE: normal; ORPHANS: 2; WIDOWS: 2; LETTER-SPACING: normal; BACKGROUND-COLOR: rgb(255,255,255); TEXT-INDENT: 0px; font-variant-ligatures: normal; font-variant-caps: normal; -webkit-text-stroke-width: 0px; text-decoration-thickness: initial; text-decoration-style: initial; text-decoration-color: initial">A natural question at this point is whether the inability of m-process consensus objects to solve (m+1)-process consensus implies robustness of the hierarchy. One might consider the following argument: given any object at level m, we can simulate it with an m-process consensus object, and since we can't combine m-process consensus objects to boost the consensus number, we can't combine any objects they can simulate either. The problem here is that while m-process consensus objects can simulate any object in a system with m processes (see below), it may be that some objects can do more in a system with m+1 objects while still not solving (m+1)-process consensus. A simple way to see this would be to imagine a variant of the m-process consensus object that doesn't fail completely after m operations; for example, it might return one of the first two inputs given to it instead of &#8869;. This doesn't help with solving consensus, but it might (or might not) make it too powerful to implement using standard m-process consensus objects.<SPAN id=line-97 class=anchor></SPAN><SPAN id=line-98 class=anchor></SPAN></P>
<P class=line867 style="FONT-SIZE: 16px; FONT-FAMILY: sans-serif; WHITE-SPACE: normal; WORD-SPACING: 0px; TEXT-TRANSFORM: none; FONT-WEIGHT: 400; COLOR: rgb(0,0,0); FONT-STYLE: normal; ORPHANS: 2; WIDOWS: 2; LETTER-SPACING: normal; BACKGROUND-COLOR: rgb(255,255,255); TEXT-INDENT: 0px; font-variant-ligatures: normal; font-variant-caps: normal; -webkit-text-stroke-width: 0px; text-decoration-thickness: initial; text-decoration-style: initial; text-decoration-color: initial">