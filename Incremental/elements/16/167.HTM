<b> : </b>4. Complexity measures</H1><SPAN id=line-36 class=anchor style="FONT-SIZE: 16px; FONT-FAMILY: sans-serif; WHITE-SPACE: normal; WORD-SPACING: 0px; TEXT-TRANSFORM: none; FONT-WEIGHT: 400; COLOR: rgb(0,0,0); FONT-STYLE: normal; ORPHANS: 2; WIDOWS: 2; LETTER-SPACING: normal; BACKGROUND-COLOR: rgb(255,255,255); TEXT-INDENT: 0px; font-variant-ligatures: normal; font-variant-caps: normal; -webkit-text-stroke-width: 0px; text-decoration-thickness: initial; text-decoration-style: initial; text-decoration-color: initial"></SPAN><SPAN id=line-37 class=anchor style="FONT-SIZE: 16px; FONT-FAMILY: sans-serif; WHITE-SPACE: normal; WORD-SPACING: 0px; TEXT-TRANSFORM: none; FONT-WEIGHT: 400; COLOR: rgb(0,0,0); FONT-STYLE: normal; ORPHANS: 2; WIDOWS: 2; LETTER-SPACING: normal; BACKGROUND-COLOR: rgb(255,255,255); TEXT-INDENT: 0px; font-variant-ligatures: normal; font-variant-caps: normal; -webkit-text-stroke-width: 0px; text-decoration-thickness: initial; text-decoration-style: initial; text-decoration-color: initial"></SPAN>
<DL style="FONT-SIZE: 16px; FONT-FAMILY: sans-serif; WHITE-SPACE: normal; WORD-SPACING: 0px; TEXT-TRANSFORM: none; FONT-WEIGHT: 400; COLOR: rgb(0,0,0); FONT-STYLE: normal; ORPHANS: 2; WIDOWS: 2; LETTER-SPACING: normal; BACKGROUND-COLOR: rgb(255,255,255); TEXT-INDENT: 0px; font-variant-ligatures: normal; font-variant-caps: normal; -webkit-text-stroke-width: 0px; text-decoration-thickness: initial; text-decoration-style: initial; text-decoration-color: initial">
<DT style="MARGIN-TOP: 0.5em; FONT-WEIGHT: bold">Time</DT>
<DD style="MARGIN-BOTTOM: 0px; MARGIN-TOP: 0px">
<P class=line862 style="MARGIN: 0.25em 0px">Assume that no process takes more than 1 time unit between operations (but some fast processes may take less). Assign the first operation in the schedule time 1 and each subsequent operation the largest time consistent with the bound. The time of the last operation is the time complexity. This is also known as the<SPAN>&nbsp;</SPAN><STRONG>big-step</STRONG><SPAN>&nbsp;</SPAN>or<SPAN>&nbsp;</SPAN><STRONG>round</STRONG><SPAN>&nbsp;</SPAN>measure because the time increases by 1 precisely when every non-faulty process has taken at least one step, and a minimum interval during which this occurs counts as a big step or a round.<SPAN id=line-38 class=anchor></SPAN></P></DD>
<DT style="MARGIN-TOP: 0.5em; FONT-WEIGHT: bold">Total work</DT>
<DD style="MARGIN-BOTTOM: 0px; MARGIN-TOP: 0px">
<P class=line862 style="MARGIN: 0.25em 0px">The<SPAN>&nbsp;</SPAN><STRONG>total work</STRONG><SPAN>&nbsp;</SPAN>is just the length of the schedule, i.e. the number of operations. This doesn't consider how the work is divided among the processes, e.g. an O(n<SUP>2</SUP>) total work protocol might dump all O(n<SUP>2</SUP>) operations on a single process and leave the rest with almost nothing to do. There is usually not much of a direct correspondence between total work and time. For example, any algorithm that involves<SPAN>&nbsp;</SPAN><STRONG>busy-waiting</STRONG>&#8212;where a process repeatedly reads a register until it changes&#8212;may have unbounded total work (because the busy-waiter might spin very fast) even though it runs in bounded time (because the register gets written to as soon as some slower process gets around to it). However, it is trivially the case that the time complexity never greater than the total work.<SPAN id=line-39 class=anchor></SPAN></P></DD>
<DT style="MARGIN-TOP: 0.5em; FONT-WEIGHT: bold">Per-process work</DT>
<DD style="MARGIN-BOTTOM: 0px; MARGIN-TOP: 0px">Measures the maximum number of operations performed by any single process. Produces more equitably distributed workloads (or reveals inequitably distributed workloads). Like total work, per-process work gives an upper bound on time, since each time unit includes at least one operation from the longest-running process, but time complexity might be much less than per-process work (e.g. in the busy-waiting case above).<SPAN id=line-40 class=anchor></SPAN></DD>
<DT style="MARGIN-TOP: 0.5em; FONT-WEIGHT: bold">Contention</DT>
<DD style="MARGIN-BOTTOM: 0px; MARGIN-TOP: 0px">
<P class=line862 style="MARGIN: 0.25em 0px">In multi-writer or multi-reader situations, it may be bad to have too many processes pounding on the same register at once. The<SPAN>&nbsp;</SPAN><STRONG>contention</STRONG><SPAN>&nbsp;</SPAN>measures the maximum number of pending operations on any single register during the schedule (this is the simplest of several definitions out there). A single-reader single-writer algorithm always has contention at most 2, but achieving such low contention may be harder for multi-reader multi-writer algorithms. Of course, the contention is never worse that n, since we assume each process has at most one pending operation at a time.<SPAN id=line-41 class=anchor></SPAN></P></DD>
<DT style="MARGIN-TOP: 0.5em; FONT-WEIGHT: bold">Space</DT>
<DD style="MARGIN-BOTTOM: 0px; MARGIN-TOP: 0px">
<P class=line862 style="MARGIN: 0.25em 0px">Just how big are those registers anyway? Much of the work in this area assumes they are<SPAN>&nbsp;</SPAN><EM>very</EM><SPAN>&nbsp;</SPAN>big. But we can ask for the maximum number of bits in any one register or the total size or number of all registers, and will try to minimize these quantities when possible. We can also look at the size of the internal states of the processes for another measure of space complexity.<SPAN id=line-42 class=anchor></SPAN><SPAN id=line-43 class=anchor></SPAN></P></DD></DL>
<P class=line867 style="FONT-SIZE: 16px; FONT-FAMILY: sans-serif; WHITE-SPACE: normal; WORD-SPACING: 0px; TEXT-TRANSFORM: none; FONT-WEIGHT: 400; COLOR: rgb(0,0,0); FONT-STYLE: normal; ORPHANS: 2; WIDOWS: 2; LETTER-SPACING: normal; BACKGROUND-COLOR: rgb(255,255,255); TEXT-INDENT: 0px; font-variant-ligatures: normal; font-variant-caps: normal; -webkit-text-stroke-width: 0px; text-decoration-thickness: initial; text-decoration-style: initial; text-decoration-color: initial">