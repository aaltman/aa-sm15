<b> : </b>Note</H3>
<P style="BOX-SIZING: border-box; MARGIN-BOTTOM: 0px !important; MARGIN-TOP: 0px">B-Tree deduplication is just as effective with<SPAN>&nbsp;</SPAN><SPAN class=quote style="BOX-SIZING: border-box">&#8220;<SPAN class=quote style="BOX-SIZING: border-box">duplicates</SPAN>&#8221;</SPAN><SPAN>&nbsp;</SPAN>that contain a NULL value, even though NULL values are never equal to each other according to the<SPAN>&nbsp;</SPAN><CODE class=literal style="BOX-SIZING: border-box; FONT-SIZE: 1em; BORDER-TOP: medium none; FONT-FAMILY: monospace, monospace; BORDER-RIGHT: medium none; MARGIN-TOP: 0px; BORDER-BOTTOM: medium none; FONT-WEIGHT: 400; COLOR:  !important; PADDING-BOTTOM: 0px !important; PADDING-TOP: 0px !important; PADDING-LEFT: 0px !important; MARGIN-LEFT: 0px; BORDER-LEFT: medium none; PADDING-RIGHT: 0px !important; MARGIN-RIGHT: 0px; overflow-wrap: break-word; border-radius: 0.25rem">=</CODE><SPAN>&nbsp;</SPAN>member of any B-Tree operator class. As far as any part of the implementation that understands the on-disk B-Tree structure is concerned, NULL is just another value from the domain of indexed values.</P></DIV>
<P style="BOX-SIZING: border-box; MARGIN-TOP: 0px">The deduplication process occurs lazily, when a new item is inserted that cannot fit on an existing leaf page, though only when index tuple deletion could not free sufficient space for the new item (typically deletion is briefly considered and then skipped over). Unlike GIN posting list tuples, B-Tree posting list tuples do not need to expand every time a new duplicate is inserted; they are merely an alternative physical representation of the original logical contents of the leaf page. This design prioritizes consistent performance with mixed read-write workloads. Most client applications will at least see a moderate performance benefit from using deduplication. Deduplication is enabled by default.</P>
<P style="BOX-SIZING: border-box; MARGIN-TOP: 0px"><CODE class=command style="BOX-SIZING: border-box; FONT-SIZE: 1em; FONT-FAMILY: monospace, monospace; MARGIN-TOP: 0px; FONT-WEIGHT: 400; COLOR:  !important; MARGIN-LEFT: 0px; MARGIN-RIGHT: 0px; overflow-wrap: break-word; border-radius: 0.25rem">CREATE INDEX</CODE><SPAN>&nbsp;</SPAN>and<SPAN>&nbsp;</SPAN><CODE class=command style="BOX-SIZING: border-box; FONT-SIZE: 1em; FONT-FAMILY: monospace, monospace; MARGIN-TOP: 0px; FONT-WEIGHT: 400; COLOR:  !important; MARGIN-LEFT: 0px; MARGIN-RIGHT: 0px; overflow-wrap: break-word; border-radius: 0.25rem">REINDEX</CODE><SPAN>&nbsp;</SPAN>apply deduplication to create posting list tuples, though the strategy they use is slightly different. Each group of duplicate ordinary tuples encountered in the sorted input taken from the table is merged into a posting list tuple<SPAN>&nbsp;</SPAN><SPAN class=emphasis style="BOX-SIZING: border-box"><EM style="BOX-SIZING: border-box; FONT-STYLE: italic">before</EM></SPAN><SPAN>&nbsp;</SPAN>being added to the current pending leaf page. Individual posting list tuples are packed with as many<SPAN>&nbsp;</SPAN><ACRONYM class=acronym style="BOX-SIZING: border-box">TID</ACRONYM>s as possible. Leaf pages are written out in the usual way, without any separate deduplication pass. This strategy is well-suited to<SPAN>&nbsp;</SPAN><CODE class=command style="BOX-SIZING: border-box; FONT-SIZE: 1em; FONT-FAMILY: monospace, monospace; MARGIN-TOP: 0px; FONT-WEIGHT: 400; COLOR:  !important; MARGIN-LEFT: 0px; MARGIN-RIGHT: 0px; overflow-wrap: break-word; border-radius: 0.25rem">CREATE INDEX</CODE><SPAN>&nbsp;</SPAN>and<SPAN>&nbsp;</SPAN><CODE class=command style="BOX-SIZING: border-box; FONT-SIZE: 1em; FONT-FAMILY: monospace, monospace; MARGIN-TOP: 0px; FONT-WEIGHT: 400; COLOR:  !important; MARGIN-LEFT: 0px; MARGIN-RIGHT: 0px; overflow-wrap: break-word; border-radius: 0.25rem">REINDEX</CODE><SPAN>&nbsp;</SPAN>because they are once-off batch operations.</P>
<P style="BOX-SIZING: border-box; MARGIN-TOP: 0px">Write-heavy workloads that don't benefit from deduplication due to having few or no duplicate values in indexes will incur a small, fixed performance penalty (unless deduplication is explicitly disabled). The<SPAN>&nbsp;</SPAN><CODE class=literal style="BOX-SIZING: border-box; FONT-SIZE: 1em; FONT-FAMILY: monospace, monospace; MARGIN-TOP: 0px; FONT-WEIGHT: 400; COLOR:  !important; MARGIN-LEFT: 0px; MARGIN-RIGHT: 0px; overflow-wrap: break-word; border-radius: 0.25rem">deduplicate_items</CODE><SPAN>&nbsp;</SPAN>storage parameter can be used to disable deduplication within individual indexes. There is never any performance penalty with read-only workloads, since reading posting list tuples is at least as efficient as reading the standard tuple representation. Disabling deduplication isn't usually helpful.</P>
<P style="BOX-SIZING: border-box; MARGIN-TOP: 0px">It is sometimes possible for unique indexes (as well as unique constraints) to use deduplication. This allows leaf pages to temporarily<SPAN>&nbsp;</SPAN><SPAN class=quote style="BOX-SIZING: border-box">&#8220;<SPAN class=quote style="BOX-SIZING: border-box">absorb</SPAN>&#8221;</SPAN><SPAN>&nbsp;</SPAN>extra version churn duplicates. Deduplication in unique indexes augments bottom-up index deletion, especially in cases where a long-running transaction holds a snapshot that blocks garbage collection. The goal is to buy time for the bottom-up index deletion strategy to become effective again. Delaying page splits until a single long-running transaction naturally goes away can allow a bottom-up deletion pass to succeed where an earlier deletion pass failed.</P>
<DIV class=tip style="BOX-SIZING: border-box; BORDER-TOP: 1px solid; BORDER-RIGHT: 1px solid; BORDER-BOTTOM: 1px solid; PADDING-TOP: 1px; PADDING-LEFT: 1px; BORDER-LEFT: 1px solid; MARGIN: 4ex auto; PADDING-RIGHT: 1px; border-radius: 8px">