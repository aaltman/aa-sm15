<DIV class=document style="FONT-SIZE: medium; FONT-FAMILY: serif; WIDTH: auto; WHITE-SPACE: normal; WORD-SPACING: 0px; TEXT-TRANSFORM: none; FONT-WEIGHT: 400; COLOR: rgb(0,0,0); FONT-STYLE: normal; ORPHANS: 2; WIDOWS: 2; MARGIN: 20px 10px 0px; LETTER-SPACING: normal; TEXT-INDENT: 0px; font-variant-ligatures: normal; font-variant-caps: normal; -webkit-text-stroke-width: 0px; text-decoration-thickness: initial; text-decoration-style: initial; text-decoration-color: initial">
<DIV class=documentwrapper style="WIDTH: 1243px; FLOAT: left">
<DIV class=bodywrapper style="MARGIN: 0px 0px 0px 15em">
<DIV role=main class=body style="MAX-WIDTH: 800px; MIN-WIDTH: 360px; COLOR: rgb(62,67,73); PADDING-BOTTOM: 0px; PADDING-TOP: 0px; PADDING-LEFT: 10px; PADDING-RIGHT: 15px; BACKGROUND-COLOR: rgb(255,255,255)">
<H1 style="FONT-SIZE: 28px; FONT-FAMILY: serif; FONT-WEIGHT: normal; PADDING-BOTTOM: 0px; PADDING-TOP: 0px; PADDING-LEFT: 0px; MARGIN: 0px 0px 10px; PADDING-RIGHT: 0px"><FONT class=extract>ioctl based interfaces</FONT><A title="Permalink to this heading" class=headerlink style="TEXT-DECORATION: none; COLOR: rgb(221,221,221); PADDING-BOTTOM: 0px; PADDING-TOP: 0px; PADDING-LEFT: 4px; PADDING-RIGHT: 4px; VISIBILITY: hidden" href="https://docs.kernel.org/driver-api/ioctl.html#ioctl-based-interfaces"></A></H1>
<P style="LINE-HEIGHT: 1.4em; hyphens: auto"><FONT class=extract>ioctl() is the most common way for applications to interface with device drivers. It is flexible and easily extended by adding new commands and can be passed through character devices, block devices as well as sockets and other special file descriptors.</FONT></P>
<P style="LINE-HEIGHT: 1.4em; hyphens: auto"><FONT class=extract>However, it is also very easy to get ioctl command definitions wrong, and hard to fix them later without breaking existing applications, so this documentation tries to help developers get it right.</FONT></P><SECTION id=command-number-definitions>
<H2 style="FONT-SIZE: 24px; FONT-FAMILY: serif; FONT-WEIGHT: normal; PADDING-BOTTOM: 0px; PADDING-TOP: 0px; PADDING-LEFT: 0px; MARGIN: 30px 0px 10px; PADDING-RIGHT: 0px"><FONT class=extract>Command number definitions</FONT><A title="Permalink to this heading" class=headerlink style="TEXT-DECORATION: none; COLOR: rgb(221,221,221); PADDING-BOTTOM: 0px; PADDING-TOP: 0px; PADDING-LEFT: 4px; PADDING-RIGHT: 4px; VISIBILITY: hidden" href="https://docs.kernel.org/driver-api/ioctl.html#command-number-definitions"></A></H2>
<P style="LINE-HEIGHT: 1.4em; hyphens: auto"><FONT class=extract>The command number, or request number, is the second argument passed to the ioctl system call. While this can be any 32-bit number that uniquely identifies an action for a particular driver, there are a number of conventions around defining them.</FONT></P>
<P style="LINE-HEIGHT: 1.4em; hyphens: auto"><FONT class=extract><CODE class="docutils literal notranslate" style='FONT-SIZE: 0.9em; FONT-FAMILY: Consolas, Menlo, "DejaVu Sans Mono", "Bitstream Vera Sans Mono", monospace; COLOR: rgb(34,34,34); BACKGROUND-COLOR: rgb(236,240,243)'><SPAN class=pre style="WHITE-SPACE: nowrap; hyphens: none">include/uapi/asm-generic/ioctl.h</SPAN></CODE><SPAN>&nbsp;</SPAN>provides four macros for defining ioctl commands that follow modern conventions:<SPAN>&nbsp;</SPAN><CODE class="docutils literal notranslate" style='FONT-SIZE: 0.9em; FONT-FAMILY: Consolas, Menlo, "DejaVu Sans Mono", "Bitstream Vera Sans Mono", monospace; COLOR: rgb(34,34,34); BACKGROUND-COLOR: rgb(236,240,243)'><SPAN class=pre style="WHITE-SPACE: nowrap; hyphens: none">_IO</SPAN></CODE>,<SPAN>&nbsp;</SPAN><CODE class="docutils literal notranslate" style='FONT-SIZE: 0.9em; FONT-FAMILY: Consolas, Menlo, "DejaVu Sans Mono", "Bitstream Vera Sans Mono", monospace; COLOR: rgb(34,34,34); BACKGROUND-COLOR: rgb(236,240,243)'><SPAN class=pre style="WHITE-SPACE: nowrap; hyphens: none">_IOR</SPAN></CODE>,<SPAN>&nbsp;</SPAN><CODE class="docutils literal notranslate" style='FONT-SIZE: 0.9em; FONT-FAMILY: Consolas, Menlo, "DejaVu Sans Mono", "Bitstream Vera Sans Mono", monospace; COLOR: rgb(34,34,34); BACKGROUND-COLOR: rgb(236,240,243)'><SPAN class=pre style="WHITE-SPACE: nowrap; hyphens: none">_IOW</SPAN></CODE>, and<SPAN>&nbsp;</SPAN><CODE class="docutils literal notranslate" style='FONT-SIZE: 0.9em; FONT-FAMILY: Consolas, Menlo, "DejaVu Sans Mono", "Bitstream Vera Sans Mono", monospace; COLOR: rgb(34,34,34); BACKGROUND-COLOR: rgb(236,240,243)'><SPAN class=pre style="WHITE-SPACE: nowrap; hyphens: none">_IOWR</SPAN></CODE>. These should be used for all new commands, with the correct parameters:</FONT></P>
<DL class=simple style="PADDING-BOTTOM: 0px; PADDING-TOP: 0px; PADDING-LEFT: 0px; MARGIN: 0px; PADDING-RIGHT: 0px">
<DT><FONT class=extract>_IO/_IOR/_IOW/_IOWR </FONT>
<DD style="MARGIN-BOTTOM: 10px; MARGIN-TOP: 3px; MARGIN-LEFT: 30px; LINE-HEIGHT: 1.4em; hyphens: auto">
<P style="MARGIN-TOP: 0px; LINE-HEIGHT: 1.4em; hyphens: auto"><FONT class=extract>The macro name specifies how the argument will be used. It may be a pointer to data to be passed into the kernel (_IOW), out of the kernel (_IOR), or both (_IOWR). _IO can indicate either commands with no argument or those passing an integer value instead of a pointer. It is recommended to only use _IO for commands without arguments, and use pointers for passing data.</FONT></P>
<DT><FONT class=extract>type </FONT>
<DD style="MARGIN-BOTTOM: 10px; MARGIN-TOP: 3px; MARGIN-LEFT: 30px; LINE-HEIGHT: 1.4em; hyphens: auto">
<P style="MARGIN-TOP: 0px; LINE-HEIGHT: 1.4em; hyphens: auto"><FONT class=extract>An 8-bit number, often a character literal, specific to a subsystem or driver, and listed in<SPAN>&nbsp;</SPAN></FONT><A class="reference internal" style="TEXT-DECORATION: none; BORDER-BOTTOM: rgb(0,75,107) 1px dotted; COLOR: rgb(0,75,107)" href="https://docs.kernel.org/userspace-api/ioctl/ioctl-number.html"><SPAN class=doc><FONT class=extract size=4>Ioctl Numbers</FONT></SPAN></A></P>
<DT><FONT class=extract>nr </FONT>
<DD style="MARGIN-BOTTOM: 10px; MARGIN-TOP: 3px; MARGIN-LEFT: 30px; LINE-HEIGHT: 1.4em; hyphens: auto">
<P style="MARGIN-TOP: 0px; LINE-HEIGHT: 1.4em; hyphens: auto"><FONT class=extract>An 8-bit number identifying the specific command, unique for a give value of &#8216;type&#8217;</FONT></P>
<DT><FONT class=extract>data_type </FONT>
<DD style="MARGIN-BOTTOM: 0px; MARGIN-TOP: 3px; MARGIN-LEFT: 30px; LINE-HEIGHT: 1.4em; hyphens: auto">
<P style="MARGIN-BOTTOM: 0px; MARGIN-TOP: 0px; LINE-HEIGHT: 1.4em; hyphens: auto"><FONT class=extract>The name of the data type pointed to by the argument, the command number encodes the<SPAN>&nbsp;</SPAN><CODE class="docutils literal notranslate" style='FONT-SIZE: 0.9em; FONT-FAMILY: Consolas, Menlo, "DejaVu Sans Mono", "Bitstream Vera Sans Mono", monospace; COLOR: rgb(34,34,34); BACKGROUND-COLOR: rgb(236,240,243)'><SPAN class=pre style="WHITE-SPACE: nowrap; hyphens: none">sizeof(data_type)</SPAN></CODE><SPAN>&nbsp;</SPAN>value in a 13-bit or 14-bit integer, leading to a limit of 8191 bytes for the maximum size of the argument. Note: do not pass sizeof(data_type) type into _IOR/_IOW/IOWR, as that will lead to encoding sizeof(sizeof(data_type)), i.e. sizeof(size_t). _IO does not have a data_type parameter.</FONT></P></DD></DL></SECTION><SECTION id=interface-versions>
<H2 style="FONT-SIZE: 24px; FONT-FAMILY: serif; FONT-WEIGHT: normal; PADDING-BOTTOM: 0px; PADDING-TOP: 0px; PADDING-LEFT: 0px; MARGIN: 30px 0px 10px; PADDING-RIGHT: 0px"><FONT class=extract>Interface versions</FONT><A title="Permalink to this heading" class=headerlink style="TEXT-DECORATION: none; COLOR: rgb(221,221,221); PADDING-BOTTOM: 0px; PADDING-TOP: 0px; PADDING-LEFT: 4px; PADDING-RIGHT: 4px; VISIBILITY: hidden" href="https://docs.kernel.org/driver-api/ioctl.html#interface-versions"></A></H2>
<P style="LINE-HEIGHT: 1.4em; hyphens: auto"><FONT class=extract>Some subsystems use version numbers in data structures to overload commands with different interpretations of the argument.</FONT></P>
<P style="LINE-HEIGHT: 1.4em; hyphens: auto"><FONT class=extract>This is generally a bad idea, since changes to existing commands tend to break existing applications.</FONT></P>
<P style="LINE-HEIGHT: 1.4em; hyphens: auto"><FONT class=extract>A better approach is to add a new ioctl command with a new number. The old command still needs to be implemented in the kernel for compatibility, but this can be a wrapper around the new implementation.</FONT></P></SECTION><SECTION id=return-code>
<H2 style="FONT-SIZE: 24px; FONT-FAMILY: serif; FONT-WEIGHT: normal; PADDING-BOTTOM: 0px; PADDING-TOP: 0px; PADDING-LEFT: 0px; MARGIN: 30px 0px 10px; PADDING-RIGHT: 0px"><FONT class=extract>Return code</FONT><A title="Permalink to this heading" class=headerlink style="TEXT-DECORATION: none; COLOR: rgb(221,221,221); PADDING-BOTTOM: 0px; PADDING-TOP: 0px; PADDING-LEFT: 4px; PADDING-RIGHT: 4px; VISIBILITY: hidden" href="https://docs.kernel.org/driver-api/ioctl.html#return-code"></A></H2>
<P style="LINE-HEIGHT: 1.4em; hyphens: auto"><FONT class=extract>ioctl commands can return negative error codes as documented in errno(3); these get turned into errno values in user space. On success, the return code should be zero. It is also possible but not recommended to return a positive &#8216;long&#8217; value.</FONT></P>
<P style="LINE-HEIGHT: 1.4em; hyphens: auto"><FONT class=extract>When the ioctl callback is called with an unknown command number, the handler returns either -ENOTTY or -ENOIOCTLCMD, which also results in -ENOTTY being returned from the system call. Some subsystems return -ENOSYS or -EINVAL here for historic reasons, but this is wrong.</FONT></P>
<P style="LINE-HEIGHT: 1.4em; hyphens: auto"><FONT class=extract>Prior to Linux 5.5, compat_ioctl handlers were required to return -ENOIOCTLCMD in order to use the fallback conversion into native commands. As all subsystems are now responsible for handling compat mode themselves, this is no longer needed, but it may be important to consider when backporting bug fixes to older kernels.</FONT></P></SECTION><SECTION id=timestamps>
<H2 style="FONT-SIZE: 24px; FONT-FAMILY: serif; FONT-WEIGHT: normal; PADDING-BOTTOM: 0px; PADDING-TOP: 0px; PADDING-LEFT: 0px; MARGIN: 30px 0px 10px; PADDING-RIGHT: 0px"><FONT class=extract>Timestamps</FONT><A title="Permalink to this heading" class=headerlink style="TEXT-DECORATION: none; COLOR: rgb(221,221,221); PADDING-BOTTOM: 0px; PADDING-TOP: 0px; PADDING-LEFT: 4px; PADDING-RIGHT: 4px; VISIBILITY: hidden" href="https://docs.kernel.org/driver-api/ioctl.html#timestamps"></A></H2>
<P style="LINE-HEIGHT: 1.4em; hyphens: auto"><FONT class=extract>Traditionally, timestamps and timeout values are passed as<SPAN>&nbsp;</SPAN><CODE class="docutils literal notranslate" style='FONT-SIZE: 0.9em; FONT-FAMILY: Consolas, Menlo, "DejaVu Sans Mono", "Bitstream Vera Sans Mono", monospace; COLOR: rgb(34,34,34); BACKGROUND-COLOR: rgb(236,240,243)'><SPAN class=pre style="WHITE-SPACE: nowrap; hyphens: none">struct</SPAN><SPAN>&nbsp;</SPAN><SPAN class=pre style="WHITE-SPACE: nowrap; hyphens: none">timespec</SPAN></CODE><SPAN>&nbsp;</SPAN>or<SPAN>&nbsp;</SPAN><CODE class="docutils literal notranslate" style='FONT-SIZE: 0.9em; FONT-FAMILY: Consolas, Menlo, "DejaVu Sans Mono", "Bitstream Vera Sans Mono", monospace; COLOR: rgb(34,34,34); BACKGROUND-COLOR: rgb(236,240,243)'><SPAN class=pre style="WHITE-SPACE: nowrap; hyphens: none">struct</SPAN><SPAN>&nbsp;</SPAN><SPAN class=pre style="WHITE-SPACE: nowrap; hyphens: none">timeval</SPAN></CODE>, but these are problematic because of incompatible definitions of these structures in user space after the move to 64-bit time_t.</FONT></P>
<P style="LINE-HEIGHT: 1.4em; hyphens: auto"><FONT class=extract>The<SPAN>&nbsp;</SPAN><CODE class="docutils literal notranslate" style='FONT-SIZE: 0.9em; FONT-FAMILY: Consolas, Menlo, "DejaVu Sans Mono", "Bitstream Vera Sans Mono", monospace; COLOR: rgb(34,34,34); BACKGROUND-COLOR: rgb(236,240,243)'><SPAN class=pre style="WHITE-SPACE: nowrap; hyphens: none">struct</SPAN><SPAN>&nbsp;</SPAN><SPAN class=pre style="WHITE-SPACE: nowrap; hyphens: none">__kernel_timespec</SPAN></CODE><SPAN>&nbsp;</SPAN>type can be used instead to be embedded in other data structures when separate second/nanosecond values are desired, or passed to user space directly. This is still not ideal though, as the structure matches neither the kernel&#8217;s timespec64 nor the user space timespec exactly. The<SPAN>&nbsp;</SPAN></FONT><A title=get_timespec64 class="reference internal" style="TEXT-DECORATION: none; BORDER-BOTTOM: rgb(0,75,107) 1px dotted; COLOR: rgb(0,75,107)" href="https://docs.kernel.org/driver-api/basics.html#c.get_timespec64"><CODE class="xref c c-func docutils literal notranslate" style='FONT-SIZE: 0.9em; FONT-FAMILY: Consolas, Menlo, "DejaVu Sans Mono", "Bitstream Vera Sans Mono", monospace; BORDER-BOTTOM: rgb(255,255,255) 1px solid; FONT-WEIGHT: bold; COLOR: rgb(34,34,34); BACKGROUND-COLOR: rgb(251,251,251)'><SPAN class=pre style="WHITE-SPACE: nowrap; hyphens: none"><FONT class=extract size=4>get_timespec64()</FONT></SPAN></CODE></A><FONT class=extract><SPAN>&nbsp;</SPAN>and<SPAN>&nbsp;</SPAN></FONT><A title=put_timespec64 class="reference internal" style="TEXT-DECORATION: none; BORDER-BOTTOM: rgb(0,75,107) 1px dotted; COLOR: rgb(0,75,107)" href="https://docs.kernel.org/driver-api/basics.html#c.put_timespec64"><CODE class="xref c c-func docutils literal notranslate" style='FONT-SIZE: 0.9em; FONT-FAMILY: Consolas, Menlo, "DejaVu Sans Mono", "Bitstream Vera Sans Mono", monospace; BORDER-BOTTOM: rgb(255,255,255) 1px solid; FONT-WEIGHT: bold; COLOR: rgb(34,34,34); BACKGROUND-COLOR: rgb(251,251,251)'><SPAN class=pre style="WHITE-SPACE: nowrap; hyphens: none"><FONT class=extract size=4>put_timespec64()</FONT></SPAN></CODE></A><FONT class=extract><SPAN>&nbsp;</SPAN>helper functions can be used to ensure that the layout remains compatible with user space and the padding is treated correctly.</FONT></P>
<P style="LINE-HEIGHT: 1.4em; hyphens: auto"><FONT class=extract>As it is cheap to convert seconds to nanoseconds, but the opposite requires an expensive 64-bit division, a simple __u64 nanosecond value can be simpler and more efficient.</FONT></P>
<P style="LINE-HEIGHT: 1.4em; hyphens: auto"><FONT class=extract>Timeout values and timestamps should ideally use CLOCK_MONOTONIC time, as returned by<SPAN>&nbsp;</SPAN></FONT><A title=ktime_get_ns class="reference internal" style="TEXT-DECORATION: none; BORDER-BOTTOM: rgb(0,75,107) 1px dotted; COLOR: rgb(0,75,107)" href="https://docs.kernel.org/core-api/timekeeping.html#c.ktime_get_ns"><CODE class="xref c c-func docutils literal notranslate" style='FONT-SIZE: 0.9em; FONT-FAMILY: Consolas, Menlo, "DejaVu Sans Mono", "Bitstream Vera Sans Mono", monospace; BORDER-BOTTOM: rgb(255,255,255) 1px solid; FONT-WEIGHT: bold; COLOR: rgb(34,34,34); BACKGROUND-COLOR: rgb(251,251,251)'><SPAN class=pre style="WHITE-SPACE: nowrap; hyphens: none"><FONT class=extract size=4>ktime_get_ns()</FONT></SPAN></CODE></A><FONT class=extract><SPAN>&nbsp;</SPAN>or<SPAN>&nbsp;</SPAN></FONT><A title=ktime_get_ts64 class="reference internal" style="TEXT-DECORATION: none; BORDER-BOTTOM: rgb(0,75,107) 1px dotted; COLOR: rgb(0,75,107)" href="https://docs.kernel.org/core-api/timekeeping.html#c.ktime_get_ts64"><CODE class="xref c c-func docutils literal notranslate" style='FONT-SIZE: 0.9em; FONT-FAMILY: Consolas, Menlo, "DejaVu Sans Mono", "Bitstream Vera Sans Mono", monospace; BORDER-BOTTOM: rgb(255,255,255) 1px solid; FONT-WEIGHT: bold; COLOR: rgb(34,34,34); BACKGROUND-COLOR: rgb(251,251,251)'><SPAN class=pre style="WHITE-SPACE: nowrap; hyphens: none"><FONT class=extract size=4>ktime_get_ts64()</FONT></SPAN></CODE></A><FONT class=extract>. Unlike CLOCK_REALTIME, this makes the timestamps immune from jumping backwards or forwards due to leap second adjustments and clock_settime() calls.</FONT></P>
<P style="LINE-HEIGHT: 1.4em; hyphens: auto"><A title=ktime_get_real_ns class="reference internal" style="TEXT-DECORATION: none; BORDER-BOTTOM: rgb(0,75,107) 1px dotted; COLOR: rgb(0,75,107)" href="https://docs.kernel.org/core-api/timekeeping.html#c.ktime_get_real_ns"><CODE class="xref c c-func docutils literal notranslate" style='FONT-SIZE: 0.9em; FONT-FAMILY: Consolas, Menlo, "DejaVu Sans Mono", "Bitstream Vera Sans Mono", monospace; BORDER-BOTTOM: rgb(255,255,255) 1px solid; FONT-WEIGHT: bold; COLOR: rgb(34,34,34); BACKGROUND-COLOR: rgb(251,251,251)'><SPAN class=pre style="WHITE-SPACE: nowrap; hyphens: none"><FONT class=extract size=4>ktime_get_real_ns()</FONT></SPAN></CODE></A><FONT class=extract><SPAN>&nbsp;</SPAN>can be used for CLOCK_REALTIME timestamps that need to be persistent across a reboot or between multiple machines.</FONT></P></SECTION><SECTION id=bit-compat-mode>
<H2 style="FONT-SIZE: 24px; FONT-FAMILY: serif; FONT-WEIGHT: normal; PADDING-BOTTOM: 0px; PADDING-TOP: 0px; PADDING-LEFT: 0px; MARGIN: 30px 0px 10px; PADDING-RIGHT: 0px"><FONT class=extract>32-bit compat mode</FONT><A title="Permalink to this heading" class=headerlink style="TEXT-DECORATION: none; COLOR: rgb(221,221,221); PADDING-BOTTOM: 0px; PADDING-TOP: 0px; PADDING-LEFT: 4px; PADDING-RIGHT: 4px; VISIBILITY: hidden" href="https://docs.kernel.org/driver-api/ioctl.html#bit-compat-mode"></A></H2>
<P style="LINE-HEIGHT: 1.4em; hyphens: auto"><FONT class=extract>In order to support 32-bit user space running on a 64-bit machine, each subsystem or driver that implements an ioctl callback handler must also implement the corresponding compat_ioctl handler.</FONT></P>
<P style="LINE-HEIGHT: 1.4em; hyphens: auto"><FONT class=extract>As long as all the rules for data structures are followed, this is as easy as setting the .compat_ioctl pointer to a helper function such as compat_ptr_ioctl() or blkdev_compat_ptr_ioctl().</FONT></P><SECTION id=compat-ptr>
<H3 style="FONT-SIZE: 20px; FONT-FAMILY: serif; FONT-WEIGHT: normal; PADDING-BOTTOM: 0px; PADDING-TOP: 0px; PADDING-LEFT: 0px; MARGIN: 30px 0px 10px; PADDING-RIGHT: 0px"><FONT class=extract>compat_ptr()</FONT><A title="Permalink to this heading" class=headerlink style="TEXT-DECORATION: none; COLOR: rgb(221,221,221); PADDING-BOTTOM: 0px; PADDING-TOP: 0px; PADDING-LEFT: 4px; PADDING-RIGHT: 4px; VISIBILITY: hidden" href="https://docs.kernel.org/driver-api/ioctl.html#compat-ptr"></A></H3>
<P style="LINE-HEIGHT: 1.4em; hyphens: auto"><FONT class=extract>On the s390 architecture, 31-bit user space has ambiguous representations for data pointers, with the upper bit being ignored. When running such a process in compat mode, the compat_ptr() helper must be used to clear the upper bit of a compat_uptr_t and turn it into a valid 64-bit pointer. On other architectures, this macro only performs a cast to a<SPAN>&nbsp;</SPAN><CODE class="docutils literal notranslate" style='FONT-SIZE: 0.9em; FONT-FAMILY: Consolas, Menlo, "DejaVu Sans Mono", "Bitstream Vera Sans Mono", monospace; COLOR: rgb(34,34,34); BACKGROUND-COLOR: rgb(236,240,243)'><SPAN class=pre style="WHITE-SPACE: nowrap; hyphens: none">void</SPAN><SPAN>&nbsp;</SPAN><SPAN class=pre style="WHITE-SPACE: nowrap; hyphens: none">__user</SPAN><SPAN>&nbsp;</SPAN><SPAN class=pre style="WHITE-SPACE: nowrap; hyphens: none">*</SPAN></CODE><SPAN>&nbsp;</SPAN>pointer.</FONT></P>
<P style="LINE-HEIGHT: 1.4em; hyphens: auto"><FONT class=extract>In an compat_ioctl() callback, the last argument is an unsigned long, which can be interpreted as either a pointer or a scalar depending on the command. If it is a scalar, then compat_ptr() must not be used, to ensure that the 64-bit kernel behaves the same way as a 32-bit kernel for arguments with the upper bit set.</FONT></P>
<P style="LINE-HEIGHT: 1.4em; hyphens: auto"><FONT class=extract>The compat_ptr_ioctl() helper can be used in place of a custom compat_ioctl file operation for drivers that only take arguments that are pointers to compatible data structures.</FONT></P></SECTION><SECTION id=structure-layout>
<H3 style="FONT-SIZE: 20px; FONT-FAMILY: serif; FONT-WEIGHT: normal; PADDING-BOTTOM: 0px; PADDING-TOP: 0px; PADDING-LEFT: 0px; MARGIN: 30px 0px 10px; PADDING-RIGHT: 0px"><FONT class=extract>Structure layout</FONT><A title="Permalink to this heading" class=headerlink style="TEXT-DECORATION: none; COLOR: rgb(221,221,221); PADDING-BOTTOM: 0px; PADDING-TOP: 0px; PADDING-LEFT: 4px; PADDING-RIGHT: 4px; VISIBILITY: hidden" href="https://docs.kernel.org/driver-api/ioctl.html#structure-layout"></A></H3>
<P style="LINE-HEIGHT: 1.4em; hyphens: auto"><FONT class=extract>Compatible data structures have the same layout on all architectures, avoiding all problematic members:</FONT></P>
<UL style="PADDING-BOTTOM: 0px; PADDING-TOP: 0px; PADDING-LEFT: 0px; MARGIN: 10px 0px 10px 30px; PADDING-RIGHT: 0px">
<LI style="LINE-HEIGHT: 1.4em; hyphens: auto">
<P style="MARGIN-TOP: 0px; LINE-HEIGHT: 1.4em; hyphens: auto"><FONT class=extract><CODE class="docutils literal notranslate" style='FONT-SIZE: 0.9em; FONT-FAMILY: Consolas, Menlo, "DejaVu Sans Mono", "Bitstream Vera Sans Mono", monospace; COLOR: rgb(34,34,34); BACKGROUND-COLOR: rgb(236,240,243)'><SPAN class=pre style="WHITE-SPACE: nowrap; hyphens: none">long</SPAN></CODE><SPAN>&nbsp;</SPAN>and<SPAN>&nbsp;</SPAN><CODE class="docutils literal notranslate" style='FONT-SIZE: 0.9em; FONT-FAMILY: Consolas, Menlo, "DejaVu Sans Mono", "Bitstream Vera Sans Mono", monospace; COLOR: rgb(34,34,34); BACKGROUND-COLOR: rgb(236,240,243)'><SPAN class=pre style="WHITE-SPACE: nowrap; hyphens: none">unsigned</SPAN><SPAN>&nbsp;</SPAN><SPAN class=pre style="WHITE-SPACE: nowrap; hyphens: none">long</SPAN></CODE><SPAN>&nbsp;</SPAN>are the size of a register, so they can be either 32-bit or 64-bit wide and cannot be used in portable data structures. Fixed-length replacements are<SPAN>&nbsp;</SPAN><CODE class="docutils literal notranslate" style='FONT-SIZE: 0.9em; FONT-FAMILY: Consolas, Menlo, "DejaVu Sans Mono", "Bitstream Vera Sans Mono", monospace; COLOR: rgb(34,34,34); BACKGROUND-COLOR: rgb(236,240,243)'><SPAN class=pre style="WHITE-SPACE: nowrap; hyphens: none">__s32</SPAN></CODE>,<SPAN>&nbsp;</SPAN><CODE class="docutils literal notranslate" style='FONT-SIZE: 0.9em; FONT-FAMILY: Consolas, Menlo, "DejaVu Sans Mono", "Bitstream Vera Sans Mono", monospace; COLOR: rgb(34,34,34); BACKGROUND-COLOR: rgb(236,240,243)'><SPAN class=pre style="WHITE-SPACE: nowrap; hyphens: none">__u32</SPAN></CODE>,<SPAN>&nbsp;</SPAN><CODE class="docutils literal notranslate" style='FONT-SIZE: 0.9em; FONT-FAMILY: Consolas, Menlo, "DejaVu Sans Mono", "Bitstream Vera Sans Mono", monospace; COLOR: rgb(34,34,34); BACKGROUND-COLOR: rgb(236,240,243)'><SPAN class=pre style="WHITE-SPACE: nowrap; hyphens: none">__s64</SPAN></CODE><SPAN>&nbsp;</SPAN>and<SPAN>&nbsp;</SPAN><CODE class="docutils literal notranslate" style='FONT-SIZE: 0.9em; FONT-FAMILY: Consolas, Menlo, "DejaVu Sans Mono", "Bitstream Vera Sans Mono", monospace; COLOR: rgb(34,34,34); BACKGROUND-COLOR: rgb(236,240,243)'><SPAN class=pre style="WHITE-SPACE: nowrap; hyphens: none">__u64</SPAN></CODE>.</FONT></P>
<LI style="LINE-HEIGHT: 1.4em; hyphens: auto">
<P style="LINE-HEIGHT: 1.4em; hyphens: auto"><FONT class=extract>Pointers have the same problem, in addition to requiring the use of compat_ptr(). The best workaround is to use<SPAN>&nbsp;</SPAN><CODE class="docutils literal notranslate" style='FONT-SIZE: 0.9em; FONT-FAMILY: Consolas, Menlo, "DejaVu Sans Mono", "Bitstream Vera Sans Mono", monospace; COLOR: rgb(34,34,34); BACKGROUND-COLOR: rgb(236,240,243)'><SPAN class=pre style="WHITE-SPACE: nowrap; hyphens: none">__u64</SPAN></CODE><SPAN>&nbsp;</SPAN>in place of pointers, which requires a cast to<SPAN>&nbsp;</SPAN><CODE class="docutils literal notranslate" style='FONT-SIZE: 0.9em; FONT-FAMILY: Consolas, Menlo, "DejaVu Sans Mono", "Bitstream Vera Sans Mono", monospace; COLOR: rgb(34,34,34); BACKGROUND-COLOR: rgb(236,240,243)'><SPAN class=pre style="WHITE-SPACE: nowrap; hyphens: none">uintptr_t</SPAN></CODE><SPAN>&nbsp;</SPAN>in user space, and the use of u64_to_user_ptr() in the kernel to convert it back into a user pointer.</FONT></P>
<LI style="LINE-HEIGHT: 1.4em; hyphens: auto">
<P style="LINE-HEIGHT: 1.4em; hyphens: auto"><FONT class=extract>On the x86-32 (i386) architecture, the alignment of 64-bit variables is only 32-bit, but they are naturally aligned on most other architectures including x86-64. This means a structure like:</FONT></P>
<DIV class="highlight-none notranslate" style="CLEAR: both; MARGIN: 1em 0px">
<DIV class=highlight style="BACKGROUND: rgb(255,255,255)"><PRE style='FONT-SIZE: 0.9em; FONT-FAMILY: Consolas, Menlo, "DejaVu Sans Mono", "Bitstream Vera Sans Mono", monospace; BACKGROUND: rgb(238,238,238); PADDING-BOTTOM: 7px; PADDING-TOP: 7px; PADDING-LEFT: 30px; CLEAR: both; MARGIN: 0px; LINE-HEIGHT: 1.3em; PADDING-RIGHT: 30px'><SPAN></SPAN><FONT class=extract>struct foo {
    __u32 a;
    __u64 b;
    __u32 c;
};
</FONT></PRE></DIV></DIV>
<P style="LINE-HEIGHT: 1.4em; hyphens: auto"><FONT class=extract>has four bytes of padding between a and b on x86-64, plus another four bytes of padding at the end, but no padding on i386, and it needs a compat_ioctl conversion handler to translate between the two formats.</FONT></P>
<P style="LINE-HEIGHT: 1.4em; hyphens: auto"><FONT class=extract>To avoid this problem, all structures should have their members naturally aligned, or explicit reserved fields added in place of the implicit padding. The<SPAN>&nbsp;</SPAN><CODE class="docutils literal notranslate" style='FONT-SIZE: 0.9em; FONT-FAMILY: Consolas, Menlo, "DejaVu Sans Mono", "Bitstream Vera Sans Mono", monospace; COLOR: rgb(34,34,34); BACKGROUND-COLOR: rgb(236,240,243)'><SPAN class=pre style="WHITE-SPACE: nowrap; hyphens: none">pahole</SPAN></CODE><SPAN>&nbsp;</SPAN>tool can be used for checking the alignment.</FONT></P>
<LI style="LINE-HEIGHT: 1.4em; hyphens: auto">
<P style="LINE-HEIGHT: 1.4em; hyphens: auto"><FONT class=extract>On ARM OABI user space, structures are padded to multiples of 32-bit, making some structs incompatible with modern EABI kernels if they do not end on a 32-bit boundary.</FONT></P>
<LI style="LINE-HEIGHT: 1.4em; hyphens: auto">
<P style="LINE-HEIGHT: 1.4em; hyphens: auto"><FONT class=extract>On the m68k architecture, struct members are not guaranteed to have an alignment greater than 16-bit, which is a problem when relying on implicit padding.</FONT></P>
<LI style="LINE-HEIGHT: 1.4em; hyphens: auto">
<P style="LINE-HEIGHT: 1.4em; hyphens: auto"><FONT class=extract>Bitfields and enums generally work as one would expect them to, but some properties of them are implementation-defined, so it is better to avoid them completely in ioctl interfaces.</FONT></P>
<LI style="LINE-HEIGHT: 1.4em; hyphens: auto">
<P style="MARGIN-BOTTOM: 0px; LINE-HEIGHT: 1.4em; hyphens: auto"><FONT class=extract><CODE class="docutils literal notranslate" style='FONT-SIZE: 0.9em; FONT-FAMILY: Consolas, Menlo, "DejaVu Sans Mono", "Bitstream Vera Sans Mono", monospace; COLOR: rgb(34,34,34); BACKGROUND-COLOR: rgb(236,240,243)'><SPAN class=pre style="WHITE-SPACE: nowrap; hyphens: none">char</SPAN></CODE><SPAN>&nbsp;</SPAN>members can be either signed or unsigned, depending on the architecture, so the __u8 and __s8 types should be used for 8-bit integer values, though char arrays are clearer for fixed-length strings.</FONT></P></LI></UL></SECTION></SECTION><SECTION id=information-leaks>
<H2 style="FONT-SIZE: 24px; FONT-FAMILY: serif; FONT-WEIGHT: normal; PADDING-BOTTOM: 0px; PADDING-TOP: 0px; PADDING-LEFT: 0px; MARGIN: 30px 0px 10px; PADDING-RIGHT: 0px"><FONT class=extract>Information leaks</FONT><A title="Permalink to this heading" class=headerlink style="TEXT-DECORATION: none; COLOR: rgb(221,221,221); PADDING-BOTTOM: 0px; PADDING-TOP: 0px; PADDING-LEFT: 4px; PADDING-RIGHT: 4px; VISIBILITY: hidden" href="https://docs.kernel.org/driver-api/ioctl.html#information-leaks"></A></H2>
<P style="LINE-HEIGHT: 1.4em; hyphens: auto"><FONT class=extract>Uninitialized data must not be copied back to user space, as this can cause an information leak, which can be used to defeat kernel address space layout randomization (KASLR), helping in an attack.</FONT></P>
<P style="LINE-HEIGHT: 1.4em; hyphens: auto"><FONT class=extract>For this reason (and for compat support) it is best to avoid any implicit padding in data structures. Where there is implicit padding in an existing structure, kernel drivers must be careful to fully initialize an instance of the structure before copying it to user space. This is usually done by calling<SPAN>&nbsp;</SPAN></FONT><A title=memset class="reference internal" style="TEXT-DECORATION: none; BORDER-BOTTOM: rgb(0,75,107) 1px dotted; COLOR: rgb(0,75,107)" href="https://docs.kernel.org/core-api/kernel-api.html#c.memset"><CODE class="xref c c-func docutils literal notranslate" style='FONT-SIZE: 0.9em; FONT-FAMILY: Consolas, Menlo, "DejaVu Sans Mono", "Bitstream Vera Sans Mono", monospace; BORDER-BOTTOM: rgb(255,255,255) 1px solid; FONT-WEIGHT: bold; COLOR: rgb(34,34,34); BACKGROUND-COLOR: rgb(251,251,251)'><SPAN class=pre style="WHITE-SPACE: nowrap; hyphens: none"><FONT class=extract size=4>memset()</FONT></SPAN></CODE></A><FONT class=extract><SPAN>&nbsp;</SPAN>before assigning to individual members.</FONT></P></SECTION><SECTION id=subsystem-abstractions>
<H2 style="FONT-SIZE: 24px; FONT-FAMILY: serif; FONT-WEIGHT: normal; PADDING-BOTTOM: 0px; PADDING-TOP: 0px; PADDING-LEFT: 0px; MARGIN: 30px 0px 10px; PADDING-RIGHT: 0px"><FONT class=extract>Subsystem abstractions</FONT><A title="Permalink to this heading" class=headerlink style="TEXT-DECORATION: none; COLOR: rgb(221,221,221); PADDING-BOTTOM: 0px; PADDING-TOP: 0px; PADDING-LEFT: 4px; PADDING-RIGHT: 4px; VISIBILITY: hidden" href="https://docs.kernel.org/driver-api/ioctl.html#subsystem-abstractions"></A></H2>
<P style="LINE-HEIGHT: 1.4em; hyphens: auto"><FONT class=extract>While some device drivers implement their own ioctl function, most subsystems implement the same command for multiple drivers. Ideally the subsystem has an .ioctl() handler that copies the arguments from and to user space, passing them into subsystem specific callback functions through normal kernel pointers.</FONT></P>
<P style="LINE-HEIGHT: 1.4em; hyphens: auto"><FONT class=extract>This helps in various ways:</FONT></P>
<UL class=simple style="PADDING-BOTTOM: 0px; PADDING-TOP: 0px; PADDING-LEFT: 0px; MARGIN: 10px 0px 10px 30px; PADDING-RIGHT: 0px">
<LI style="LINE-HEIGHT: 1.4em; hyphens: auto">
<P style="MARGIN-BOTTOM: 0px; MARGIN-TOP: 0px; LINE-HEIGHT: 1.4em; hyphens: auto"><FONT class=extract>Applications written for one driver are more likely to work for another one in the same subsystem if there are no subtle differences in the user space ABI.</FONT></P>
<LI style="LINE-HEIGHT: 1.4em; hyphens: auto">
<P style="MARGIN-BOTTOM: 0px; MARGIN-TOP: 0px; LINE-HEIGHT: 1.4em; hyphens: auto"><FONT class=extract>The complexity of user space access and data structure layout is done in one place, reducing the potential for implementation bugs.</FONT></P>
<LI style="LINE-HEIGHT: 1.4em; hyphens: auto">
<P style="MARGIN-BOTTOM: 0px; MARGIN-TOP: 0px; LINE-HEIGHT: 1.4em; hyphens: auto"><FONT class=extract>It is more likely to be reviewed by experienced developers that can spot problems in the interface when the ioctl is shared between multiple drivers than when it is only used in a single driver.</FONT></P></LI></UL></SECTION><SECTION id=alternatives-to-ioctl>
<H2 style="FONT-SIZE: 24px; FONT-FAMILY: serif; FONT-WEIGHT: normal; PADDING-BOTTOM: 0px; PADDING-TOP: 0px; PADDING-LEFT: 0px; MARGIN: 30px 0px 10px; PADDING-RIGHT: 0px"><FONT class=extract>Alternatives to ioctl</FONT><A title="Permalink to this heading" class=headerlink style="TEXT-DECORATION: none; COLOR: rgb(221,221,221); PADDING-BOTTOM: 0px; PADDING-TOP: 0px; PADDING-LEFT: 4px; PADDING-RIGHT: 4px; VISIBILITY: hidden" href="https://docs.kernel.org/driver-api/ioctl.html#alternatives-to-ioctl"></A></H2>
<P style="LINE-HEIGHT: 1.4em; hyphens: auto"><FONT class=extract>There are many cases in which ioctl is not the best solution for a problem. Alternatives include:</FONT></P>
<UL class=simple style="PADDING-BOTTOM: 0px; PADDING-TOP: 0px; PADDING-LEFT: 0px; MARGIN: 10px 0px 10px 30px; PADDING-RIGHT: 0px">
<LI style="LINE-HEIGHT: 1.4em; hyphens: auto">
<P style="MARGIN-BOTTOM: 0px; MARGIN-TOP: 0px; LINE-HEIGHT: 1.4em; hyphens: auto"><FONT class=extract>System calls are a better choice for a system-wide feature that is not tied to a physical device or constrained by the file system permissions of a character device node</FONT></P>
<LI style="LINE-HEIGHT: 1.4em; hyphens: auto">
<P style="MARGIN-BOTTOM: 0px; MARGIN-TOP: 0px; LINE-HEIGHT: 1.4em; hyphens: auto"><FONT class=extract>netlink is the preferred way of configuring any network related objects through sockets.</FONT></P>
<LI style="LINE-HEIGHT: 1.4em; hyphens: auto">
<P style="MARGIN-BOTTOM: 0px; MARGIN-TOP: 0px; LINE-HEIGHT: 1.4em; hyphens: auto"><FONT class=extract>debugfs is used for ad-hoc interfaces for debugging functionality that does not need to be exposed as a stable interface to applications.</FONT></P>
<LI style="LINE-HEIGHT: 1.4em; hyphens: auto">
<P style="MARGIN-BOTTOM: 0px; MARGIN-TOP: 0px; LINE-HEIGHT: 1.4em; hyphens: auto"><FONT class=extract>sysfs is a good way to expose the state of an in-kernel object that is not tied to a file descriptor.</FONT></P>
<LI style="LINE-HEIGHT: 1.4em; hyphens: auto">
<P style="MARGIN-BOTTOM: 0px; MARGIN-TOP: 0px; LINE-HEIGHT: 1.4em; hyphens: auto"><FONT class=extract>configfs can be used for more complex configuration than sysfs</FONT></P>
<LI style="LINE-HEIGHT: 1.4em; hyphens: auto">
<P style="MARGIN-BOTTOM: 0px; MARGIN-TOP: 0px; LINE-HEIGHT: 1.4em; hyphens: auto"><FONT class=extract>A custom file system can provide extra flexibility with a simple user interface but adds a lot of complexity to the implementation.</FONT></P></LI></UL></SECTION></SECTION></DIV></DIV></DIV>
<DIV class=clearer style="CLEAR: both"><FONT class=extract></FONT></DIV></DIV><BR class=Apple-interchange-newline>