<b> : </b>Structure layout<A title="Permalink to this heading" class=headerlink style="TEXT-DECORATION: none; COLOR: rgb(221,221,221); PADDING-BOTTOM: 0px; PADDING-TOP: 0px; PADDING-LEFT: 4px; PADDING-RIGHT: 4px; VISIBILITY: hidden" href="https://docs.kernel.org/driver-api/ioctl.html#structure-layout"></A></H3>
<P style="LINE-HEIGHT: 1.4em; hyphens: auto">Compatible data structures have the same layout on all architectures, avoiding all problematic members:</P>
<UL style="PADDING-BOTTOM: 0px; PADDING-TOP: 0px; PADDING-LEFT: 0px; MARGIN: 10px 0px 10px 30px; PADDING-RIGHT: 0px">
<LI style="LINE-HEIGHT: 1.4em; hyphens: auto">
<P style="MARGIN-TOP: 0px; LINE-HEIGHT: 1.4em; hyphens: auto"><CODE class="docutils literal notranslate" style='FONT-SIZE: 0.9em; FONT-FAMILY: Consolas, Menlo, "DejaVu Sans Mono", "Bitstream Vera Sans Mono", monospace; COLOR: rgb(34,34,34); BACKGROUND-COLOR: rgb(236,240,243)'><SPAN class=pre style="WHITE-SPACE: nowrap; hyphens: none">long</SPAN></CODE><SPAN>&nbsp;</SPAN>and<SPAN>&nbsp;</SPAN><CODE class="docutils literal notranslate" style='FONT-SIZE: 0.9em; FONT-FAMILY: Consolas, Menlo, "DejaVu Sans Mono", "Bitstream Vera Sans Mono", monospace; COLOR: rgb(34,34,34); BACKGROUND-COLOR: rgb(236,240,243)'><SPAN class=pre style="WHITE-SPACE: nowrap; hyphens: none">unsigned</SPAN><SPAN>&nbsp;</SPAN><SPAN class=pre style="WHITE-SPACE: nowrap; hyphens: none">long</SPAN></CODE><SPAN>&nbsp;</SPAN>are the size of a register, so they can be either 32-bit or 64-bit wide and cannot be used in portable data structures. Fixed-length replacements are<SPAN>&nbsp;</SPAN><CODE class="docutils literal notranslate" style='FONT-SIZE: 0.9em; FONT-FAMILY: Consolas, Menlo, "DejaVu Sans Mono", "Bitstream Vera Sans Mono", monospace; COLOR: rgb(34,34,34); BACKGROUND-COLOR: rgb(236,240,243)'><SPAN class=pre style="WHITE-SPACE: nowrap; hyphens: none">__s32</SPAN></CODE>,<SPAN>&nbsp;</SPAN><CODE class="docutils literal notranslate" style='FONT-SIZE: 0.9em; FONT-FAMILY: Consolas, Menlo, "DejaVu Sans Mono", "Bitstream Vera Sans Mono", monospace; COLOR: rgb(34,34,34); BACKGROUND-COLOR: rgb(236,240,243)'><SPAN class=pre style="WHITE-SPACE: nowrap; hyphens: none">__u32</SPAN></CODE>,<SPAN>&nbsp;</SPAN><CODE class="docutils literal notranslate" style='FONT-SIZE: 0.9em; FONT-FAMILY: Consolas, Menlo, "DejaVu Sans Mono", "Bitstream Vera Sans Mono", monospace; COLOR: rgb(34,34,34); BACKGROUND-COLOR: rgb(236,240,243)'><SPAN class=pre style="WHITE-SPACE: nowrap; hyphens: none">__s64</SPAN></CODE><SPAN>&nbsp;</SPAN>and<SPAN>&nbsp;</SPAN><CODE class="docutils literal notranslate" style='FONT-SIZE: 0.9em; FONT-FAMILY: Consolas, Menlo, "DejaVu Sans Mono", "Bitstream Vera Sans Mono", monospace; COLOR: rgb(34,34,34); BACKGROUND-COLOR: rgb(236,240,243)'><SPAN class=pre style="WHITE-SPACE: nowrap; hyphens: none">__u64</SPAN></CODE>.</P>
<LI style="LINE-HEIGHT: 1.4em; hyphens: auto">
<P style="LINE-HEIGHT: 1.4em; hyphens: auto">Pointers have the same problem, in addition to requiring the use of compat_ptr(). The best workaround is to use<SPAN>&nbsp;</SPAN><CODE class="docutils literal notranslate" style='FONT-SIZE: 0.9em; FONT-FAMILY: Consolas, Menlo, "DejaVu Sans Mono", "Bitstream Vera Sans Mono", monospace; COLOR: rgb(34,34,34); BACKGROUND-COLOR: rgb(236,240,243)'><SPAN class=pre style="WHITE-SPACE: nowrap; hyphens: none">__u64</SPAN></CODE><SPAN>&nbsp;</SPAN>in place of pointers, which requires a cast to<SPAN>&nbsp;</SPAN><CODE class="docutils literal notranslate" style='FONT-SIZE: 0.9em; FONT-FAMILY: Consolas, Menlo, "DejaVu Sans Mono", "Bitstream Vera Sans Mono", monospace; COLOR: rgb(34,34,34); BACKGROUND-COLOR: rgb(236,240,243)'><SPAN class=pre style="WHITE-SPACE: nowrap; hyphens: none">uintptr_t</SPAN></CODE><SPAN>&nbsp;</SPAN>in user space, and the use of u64_to_user_ptr() in the kernel to convert it back into a user pointer.</P>
<LI style="LINE-HEIGHT: 1.4em; hyphens: auto">
<P style="LINE-HEIGHT: 1.4em; hyphens: auto">On the x86-32 (i386) architecture, the alignment of 64-bit variables is only 32-bit, but they are naturally aligned on most other architectures including x86-64. This means a structure like:</P>
<DIV class="highlight-none notranslate" style="CLEAR: both; MARGIN: 1em 0px">
<DIV class=highlight style="BACKGROUND: rgb(255,255,255)"><PRE style='FONT-SIZE: 0.9em; FONT-FAMILY: Consolas, Menlo, "DejaVu Sans Mono", "Bitstream Vera Sans Mono", monospace; BACKGROUND: rgb(238,238,238); PADDING-BOTTOM: 7px; PADDING-TOP: 7px; PADDING-LEFT: 30px; CLEAR: both; MARGIN: 0px; LINE-HEIGHT: 1.3em; PADDING-RIGHT: 30px'><SPAN></SPAN>struct foo {
    __u32 a;
    __u64 b;
    __u32 c;
};
</PRE></DIV></DIV>
<P style="LINE-HEIGHT: 1.4em; hyphens: auto">has four bytes of padding between a and b on x86-64, plus another four bytes of padding at the end, but no padding on i386, and it needs a compat_ioctl conversion handler to translate between the two formats.</P>
<P style="LINE-HEIGHT: 1.4em; hyphens: auto">To avoid this problem, all structures should have their members naturally aligned, or explicit reserved fields added in place of the implicit padding. The<SPAN>&nbsp;</SPAN><CODE class="docutils literal notranslate" style='FONT-SIZE: 0.9em; FONT-FAMILY: Consolas, Menlo, "DejaVu Sans Mono", "Bitstream Vera Sans Mono", monospace; COLOR: rgb(34,34,34); BACKGROUND-COLOR: rgb(236,240,243)'><SPAN class=pre style="WHITE-SPACE: nowrap; hyphens: none">pahole</SPAN></CODE><SPAN>&nbsp;</SPAN>tool can be used for checking the alignment.</P>
<LI style="LINE-HEIGHT: 1.4em; hyphens: auto">
<P style="LINE-HEIGHT: 1.4em; hyphens: auto">On ARM OABI user space, structures are padded to multiples of 32-bit, making some structs incompatible with modern EABI kernels if they do not end on a 32-bit boundary.</P>
<LI style="LINE-HEIGHT: 1.4em; hyphens: auto">
<P style="LINE-HEIGHT: 1.4em; hyphens: auto">On the m68k architecture, struct members are not guaranteed to have an alignment greater than 16-bit, which is a problem when relying on implicit padding.</P>
<LI style="LINE-HEIGHT: 1.4em; hyphens: auto">
<P style="LINE-HEIGHT: 1.4em; hyphens: auto">Bitfields and enums generally work as one would expect them to, but some properties of them are implementation-defined, so it is better to avoid them completely in ioctl interfaces.</P>
<LI style="LINE-HEIGHT: 1.4em; hyphens: auto">
<P style="MARGIN-BOTTOM: 0px; LINE-HEIGHT: 1.4em; hyphens: auto"><CODE class="docutils literal notranslate" style='FONT-SIZE: 0.9em; FONT-FAMILY: Consolas, Menlo, "DejaVu Sans Mono", "Bitstream Vera Sans Mono", monospace; COLOR: rgb(34,34,34); BACKGROUND-COLOR: rgb(236,240,243)'><SPAN class=pre style="WHITE-SPACE: nowrap; hyphens: none">char</SPAN></CODE><SPAN>&nbsp;</SPAN>members can be either signed or unsigned, depending on the architecture, so the __u8 and __s8 types should be used for 8-bit integer values, though char arrays are clearer for fixed-length strings.</P></LI></UL></SECTION></SECTION><SECTION id=information-leaks>