<P style="FONT-SIZE: 14px; FONT-FAMILY: helvetica, arial, sans-serif; WHITE-SPACE: normal; WORD-SPACING: 0px; TEXT-TRANSFORM: none; FONT-WEIGHT: 400; COLOR: rgb(0,0,0); FONT-STYLE: normal; TEXT-ALIGN: left; ORPHANS: 2; WIDOWS: 2; MARGIN: 0.7ex; LETTER-SPACING: normal; LINE-HEIGHT: 1.4em; BACKGROUND-COLOR: transparent; TEXT-INDENT: 1em; font-variant-ligatures: normal; font-variant-caps: normal; -webkit-text-stroke-width: 0px; text-decoration-thickness: initial; text-decoration-style: initial; text-decoration-color: initial"><FONT class=extract>The idea we saw earlier of putting multiple set (list, hash table) elements together into large chunks that exploit locality can also be applied to trees. Binary search trees are not good for locality because a given node of the binary tree probably occupies only a fraction of any cache line.<SPAN>&nbsp;</SPAN><B>B-trees</B><SPAN>&nbsp;</SPAN>are a way to get better locality by putting multiple elements into each tree node.</FONT></P>
<P style="FONT-SIZE: 14px; FONT-FAMILY: helvetica, arial, sans-serif; WHITE-SPACE: normal; WORD-SPACING: 0px; TEXT-TRANSFORM: none; FONT-WEIGHT: 400; COLOR: rgb(0,0,0); FONT-STYLE: normal; TEXT-ALIGN: left; ORPHANS: 2; WIDOWS: 2; MARGIN: 0.7ex; LETTER-SPACING: normal; LINE-HEIGHT: 1.4em; BACKGROUND-COLOR: transparent; TEXT-INDENT: 1em; font-variant-ligatures: normal; font-variant-caps: normal; -webkit-text-stroke-width: 0px; text-decoration-thickness: initial; text-decoration-style: initial; text-decoration-color: initial"><FONT class=extract>B-trees were originally invented for storing data structures on disk, where locality is even more crucial than with memory. Accessing a disk location takes about 5ms = 5,000,000ns. Therefore, if you are storing a tree on disk, you want to make sure that a given disk read is as effective as possible. B-trees have a high branching factor, much larger than 2, which ensures that few disk reads are needed to navigate to the place where data is stored. B-trees may also useful for in-memory data structures because these days main memory is almost as slow relative to the processor as disk drives were to main memory when B-trees were first introduced!</FONT></P>
<P style="FONT-SIZE: 14px; FONT-FAMILY: helvetica, arial, sans-serif; WHITE-SPACE: normal; WORD-SPACING: 0px; TEXT-TRANSFORM: none; FONT-WEIGHT: 400; COLOR: rgb(0,0,0); FONT-STYLE: normal; TEXT-ALIGN: left; ORPHANS: 2; WIDOWS: 2; MARGIN: 0.7ex; LETTER-SPACING: normal; LINE-HEIGHT: 1.4em; BACKGROUND-COLOR: transparent; TEXT-INDENT: 1em; font-variant-ligatures: normal; font-variant-caps: normal; -webkit-text-stroke-width: 0px; text-decoration-thickness: initial; text-decoration-style: initial; text-decoration-color: initial"><FONT class=extract>A B-tree of order<SPAN>&nbsp;</SPAN><I class=math style='FONT-SIZE: 13pt; FONT-FAMILY: "Times New Roman", times, serif; COLOR: black; BACKGROUND-COLOR: transparent'>m</I><SPAN>&nbsp;</SPAN>is a search tree in which each nonleaf node has up to<SPAN>&nbsp;</SPAN><I class=math style='FONT-SIZE: 13pt; FONT-FAMILY: "Times New Roman", times, serif; COLOR: black; BACKGROUND-COLOR: transparent'>m</I><SPAN>&nbsp;</SPAN>children. The actual elements of the collection are stored in the leaves of the tree, and the nonleaf nodes contain only keys. Each leaf stores some number of elements; the maximum number may be greater or (typically) less than<SPAN>&nbsp;</SPAN><I class=m style='FONT-SIZE: 13pt; FONT-FAMILY: "Times New Roman", times, serif; COLOR: black; BACKGROUND-COLOR: transparent'>m</I>. The data structure satisfies several invariants:</FONT></P>
<OL style="FONT-SIZE: 14px; FONT-FAMILY: helvetica, arial, sans-serif; WHITE-SPACE: normal; WORD-SPACING: 0px; TEXT-TRANSFORM: none; FONT-WEIGHT: 400; COLOR: rgb(0,0,0); FONT-STYLE: normal; TEXT-ALIGN: left; ORPHANS: 2; WIDOWS: 2; LETTER-SPACING: normal; TEXT-INDENT: 0px; font-variant-ligatures: normal; font-variant-caps: normal; -webkit-text-stroke-width: 0px; text-decoration-thickness: initial; text-decoration-style: initial; text-decoration-color: initial">
<LI style="MARGIN: 4pt; LINE-HEIGHT: 2.3ex; BACKGROUND-COLOR: transparent; TEXT-INDENT: 0px"><FONT class=extract>Every path from the root to a leaf has the same length </FONT>
<LI style="MARGIN: 4pt; LINE-HEIGHT: 2.3ex; BACKGROUND-COLOR: transparent; TEXT-INDENT: 0px"><FONT class=extract>If a node has<SPAN>&nbsp;</SPAN><SPAN class=math style='FONT-SIZE: 13pt; FONT-FAMILY: "Times New Roman", times, serif; COLOR: black; BACKGROUND-COLOR: transparent'><I>n</I></SPAN><SPAN>&nbsp;</SPAN>children, it contains<SPAN>&nbsp;</SPAN><SPAN class=math style='FONT-SIZE: 13pt; FONT-FAMILY: "Times New Roman", times, serif; COLOR: black; BACKGROUND-COLOR: transparent'><I>n</I>&#8722;1</SPAN><SPAN>&nbsp;</SPAN>keys. </FONT>
<LI style="MARGIN: 4pt; LINE-HEIGHT: 2.3ex; BACKGROUND-COLOR: transparent; TEXT-INDENT: 0px"><FONT class=extract>Every node (except the root) is at least half full </FONT>
<LI style="MARGIN: 4pt; LINE-HEIGHT: 2.3ex; BACKGROUND-COLOR: transparent; TEXT-INDENT: 0px"><FONT class=extract>The elements stored in a given subtree all have keys that are between the keys in the parent node on either side of the subtree pointer. (This generalizes the BST invariant.) </FONT>
<LI style="MARGIN: 4pt; LINE-HEIGHT: 2.3ex; BACKGROUND-COLOR: transparent; TEXT-INDENT: 0px"><FONT class=extract>The root has at least two children if it is not a leaf.</FONT></LI></OL>
<P style="FONT-SIZE: 14px; FONT-FAMILY: helvetica, arial, sans-serif; WHITE-SPACE: normal; WORD-SPACING: 0px; TEXT-TRANSFORM: none; FONT-WEIGHT: 400; COLOR: rgb(0,0,0); FONT-STYLE: normal; TEXT-ALIGN: left; ORPHANS: 2; WIDOWS: 2; MARGIN: 0.7ex; LETTER-SPACING: normal; LINE-HEIGHT: 1.4em; BACKGROUND-COLOR: transparent; TEXT-INDENT: 1em; font-variant-ligatures: normal; font-variant-caps: normal; -webkit-text-stroke-width: 0px; text-decoration-thickness: initial; text-decoration-style: initial; text-decoration-color: initial"><FONT class=extract>For example, the following is an order-5 B-tree (<SPAN class=m style='FONT-SIZE: 13pt; FONT-FAMILY: "Times New Roman", times, serif; COLOR: black; BACKGROUND-COLOR: transparent'><I>m</I>=5</SPAN>) where the leaves have enough space to store up to 3 data records:</FONT></P>
<DIV style="FONT-SIZE: 14px; FONT-FAMILY: helvetica, arial, sans-serif; WHITE-SPACE: normal; WORD-SPACING: 0px; TEXT-TRANSFORM: none; FONT-WEIGHT: 400; COLOR: rgb(0,0,0); FONT-STYLE: normal; ORPHANS: 2; WIDOWS: 2; LETTER-SPACING: normal; TEXT-INDENT: 0px; font-variant-ligatures: normal; font-variant-caps: normal; -webkit-text-stroke-width: 0px; text-decoration-thickness: initial; text-decoration-style: initial; text-decoration-color: initial" align=center><FONT class=extract><IMG border=0 src="https://www.cs.cornell.edu/courses/cs3110/2012sp/recitations/rec25-B-trees/images/B-trees.gif" width=443 align=center height=129></FONT></DIV>
<P style="FONT-SIZE: 14px; FONT-FAMILY: helvetica, arial, sans-serif; WHITE-SPACE: normal; WORD-SPACING: 0px; TEXT-TRANSFORM: none; FONT-WEIGHT: 400; COLOR: rgb(0,0,0); FONT-STYLE: normal; TEXT-ALIGN: left; ORPHANS: 2; WIDOWS: 2; MARGIN: 0.7ex; LETTER-SPACING: normal; LINE-HEIGHT: 1.4em; BACKGROUND-COLOR: transparent; TEXT-INDENT: 1em; font-variant-ligatures: normal; font-variant-caps: normal; -webkit-text-stroke-width: 0px; text-decoration-thickness: initial; text-decoration-style: initial; text-decoration-color: initial"><FONT class=extract>Because the height of the tree is uniformly the same and every node is at least half full, we are guaranteed that the asymptotic performance is<SPAN>&nbsp;</SPAN><SPAN class=math style='FONT-SIZE: 13pt; FONT-FAMILY: "Times New Roman", times, serif; COLOR: black; BACKGROUND-COLOR: transparent'>O(lg<SPAN>&nbsp;</SPAN><I>n</I>)</SPAN><SPAN>&nbsp;</SPAN>where<SPAN>&nbsp;</SPAN><SPAN class=math style='FONT-SIZE: 13pt; FONT-FAMILY: "Times New Roman", times, serif; COLOR: black; BACKGROUND-COLOR: transparent'><I>n</I></SPAN><SPAN>&nbsp;</SPAN>is the size of the collection. The real win is in the constant factors, of course. We can choose<SPAN>&nbsp;</SPAN><SPAN class=math style='FONT-SIZE: 13pt; FONT-FAMILY: "Times New Roman", times, serif; COLOR: black; BACKGROUND-COLOR: transparent'><I>m</I></SPAN><SPAN>&nbsp;</SPAN>so that the pointers to the<SPAN>&nbsp;</SPAN><SPAN class=math style='FONT-SIZE: 13pt; FONT-FAMILY: "Times New Roman", times, serif; COLOR: black; BACKGROUND-COLOR: transparent'><I>m</I></SPAN><SPAN>&nbsp;</SPAN>children plus the<SPAN>&nbsp;</SPAN><SPAN class=math style='FONT-SIZE: 13pt; FONT-FAMILY: "Times New Roman", times, serif; COLOR: black; BACKGROUND-COLOR: transparent'><I>m</I>&#8722;1</SPAN><SPAN>&nbsp;</SPAN>elements fill out a cache line at the highest level of the memory hierarchy where we can expect to get cache hits. For example, if we are accessing a large disk database then our "cache lines" are memory blocks of the size that is read from disk.</FONT></P>
<P style="FONT-SIZE: 14px; FONT-FAMILY: helvetica, arial, sans-serif; WHITE-SPACE: normal; WORD-SPACING: 0px; TEXT-TRANSFORM: none; FONT-WEIGHT: 400; COLOR: rgb(0,0,0); FONT-STYLE: normal; TEXT-ALIGN: left; ORPHANS: 2; WIDOWS: 2; MARGIN: 0.7ex; LETTER-SPACING: normal; LINE-HEIGHT: 1.4em; BACKGROUND-COLOR: transparent; TEXT-INDENT: 1em; font-variant-ligatures: normal; font-variant-caps: normal; -webkit-text-stroke-width: 0px; text-decoration-thickness: initial; text-decoration-style: initial; text-decoration-color: initial"><FONT class=extract>Lookup in a B-tree is straightforward. Given a node to start from, we use a simple linear or binary search to find whether the desired element is in the node, or if not, which child pointer to follow from the current node.</FONT></P>
<P style="FONT-SIZE: 14px; FONT-FAMILY: helvetica, arial, sans-serif; WHITE-SPACE: normal; WORD-SPACING: 0px; TEXT-TRANSFORM: none; FONT-WEIGHT: 400; COLOR: rgb(0,0,0); FONT-STYLE: normal; TEXT-ALIGN: left; ORPHANS: 2; WIDOWS: 2; MARGIN: 0.7ex; LETTER-SPACING: normal; LINE-HEIGHT: 1.4em; BACKGROUND-COLOR: transparent; TEXT-INDENT: 1em; font-variant-ligatures: normal; font-variant-caps: normal; -webkit-text-stroke-width: 0px; text-decoration-thickness: initial; text-decoration-style: initial; text-decoration-color: initial"><FONT class=extract>Insertion and deletion from a B-tree are more complicated; in fact, they are notoriously difficult to implement correctly. For insertion, we first find the appropriate leaf node into which the inserted element falls (assuming it is not already in the tree). If there is already room in the node, the new element can be inserted simply. Otherwise the current leaf is already full and must be split into two leaves, one of which acquires the new element. The parent is then updated to contain a new key and child pointer. If the parent is already full, the process ripples upwards, eventually possibly reaching the root. If the root is split into two, then a new root is created with just two children, increasing the height of the tree by one.</FONT></P>
<P style="FONT-SIZE: 14px; FONT-FAMILY: helvetica, arial, sans-serif; WHITE-SPACE: normal; WORD-SPACING: 0px; TEXT-TRANSFORM: none; FONT-WEIGHT: 400; COLOR: rgb(0,0,0); FONT-STYLE: normal; TEXT-ALIGN: left; ORPHANS: 2; WIDOWS: 2; MARGIN: 0.7ex; LETTER-SPACING: normal; LINE-HEIGHT: 1.4em; BACKGROUND-COLOR: transparent; TEXT-INDENT: 1em; font-variant-ligatures: normal; font-variant-caps: normal; -webkit-text-stroke-width: 0px; text-decoration-thickness: initial; text-decoration-style: initial; text-decoration-color: initial"><FONT class=extract>For example, here is the effect of a series of insertions. The first insertion (13) merely affects a leaf. The second insertion (14) overflows the leaf and adds a key to an internal node. The third insertion propagates all the way to the root.</FONT></P>
<DIV style="FONT-SIZE: 14px; FONT-FAMILY: helvetica, arial, sans-serif; WHITE-SPACE: normal; WORD-SPACING: 0px; TEXT-TRANSFORM: none; FONT-WEIGHT: 400; COLOR: rgb(0,0,0); FONT-STYLE: normal; ORPHANS: 2; WIDOWS: 2; LETTER-SPACING: normal; TEXT-INDENT: 0px; font-variant-ligatures: normal; font-variant-caps: normal; -webkit-text-stroke-width: 0px; text-decoration-thickness: initial; text-decoration-style: initial; text-decoration-color: initial" align=center><FONT class=extract><IMG border=0 src="https://www.cs.cornell.edu/courses/cs3110/2012sp/recitations/rec25-B-trees/images/B-trees-insert.gif" width=454 height=166><BR><IMG border=0 src="https://www.cs.cornell.edu/courses/cs3110/2012sp/recitations/rec25-B-trees/images/B-trees-insert2.gif" width=489 height=166><BR><IMG border=0 src="https://www.cs.cornell.edu/courses/cs3110/2012sp/recitations/rec25-B-trees/images/B-trees-insert3.gif" width=508 height=166></FONT></DIV>
<P style="FONT-SIZE: 14px; FONT-FAMILY: helvetica, arial, sans-serif; WHITE-SPACE: normal; WORD-SPACING: 0px; TEXT-TRANSFORM: none; FONT-WEIGHT: 400; COLOR: rgb(0,0,0); FONT-STYLE: normal; TEXT-ALIGN: left; ORPHANS: 2; WIDOWS: 2; MARGIN: 0.7ex; LETTER-SPACING: normal; LINE-HEIGHT: 1.4em; BACKGROUND-COLOR: transparent; TEXT-INDENT: 1em; font-variant-ligatures: normal; font-variant-caps: normal; -webkit-text-stroke-width: 0px; text-decoration-thickness: initial; text-decoration-style: initial; text-decoration-color: initial"><FONT class=extract>Deletion works in the opposite way: the element is removed from the leaf. If the leaf becomes empty, a key is removed from the parent node. If that breaks invariant 3, the keys of the parent node and its immediate right (or left) sibling are reapportioned among them so that invariant 3 is satisfied. If this is not possible, the parent node can be combined with that sibling, removing a key another level up in the tree and possible causing a ripple all the way to the root. If the root has just two children, and they are combined, then the root is deleted and the new combined node becomes the root of the tree, reducing the height of the tree by one.</FONT>