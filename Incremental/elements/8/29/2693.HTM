<b> : </b><SPAN id=Maintaining_a_list_of_cache_servers class=ez-toc-section style="BOX-SIZING: border-box" ez-toc-data-id="#Maintaining_a_list_of_cache_servers"></SPAN>Maintaining a list of cache servers<SPAN class=ez-toc-section-end style="BOX-SIZING: border-box"></SPAN></H3><FIGURE class="wp-block-image size-large" style='BOX-SIZING: border-box; FONT-SIZE: 16px; FONT-FAMILY: system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", "Noto Sans", "Liberation Sans", Arial, sans-serif, "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol", "Noto Color Emoji"; WHITE-SPACE: normal; WORD-SPACING: 0px; TEXT-TRANSFORM: none; FONT-WEIGHT: 400; COLOR: rgb(33,37,41); FONT-STYLE: normal; ORPHANS: 2; WIDOWS: 2; MARGIN: 0px 0px 1px; LETTER-SPACING: normal; BACKGROUND-COLOR: rgb(255,255,255); TEXT-INDENT: 0px; font-variant-ligatures: normal; font-variant-caps: normal; -webkit-text-stroke-width: 0px; text-decoration-thickness: initial; text-decoration-style: initial; text-decoration-color: initial'><IMG class=wp-image-166 style="BOX-SIZING: border-box; MAX-WIDTH: 100%; HEIGHT: auto; VERTICAL-ALIGN: bottom" alt="" src="https://serhatgiydiren.com/wp-content/uploads/2022/10/image-4-1024x495.png" width=1024 height=495 sizes="(max-width: 1024px) 100vw, 1024px" srcset="https://serhatgiydiren.com/wp-content/uploads/2022/10/image-4-1024x495.png 1024w, https://serhatgiydiren.com/wp-content/uploads/2022/10/image-4-300x145.png 300w, https://serhatgiydiren.com/wp-content/uploads/2022/10/image-4-768x371.png 768w, https://serhatgiydiren.com/wp-content/uploads/2022/10/image-4.png 1259w" decoding="async" loading="lazy"></FIGURE>
<UL class=wp-block-list style='BOX-SIZING: border-box; FONT-SIZE: 16px; FONT-FAMILY: system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", "Noto Sans", "Liberation Sans", Arial, sans-serif, "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol", "Noto Color Emoji"; WHITE-SPACE: normal; WORD-SPACING: 0px; MARGIN-TOP: 0px; TEXT-TRANSFORM: none; FONT-WEIGHT: 400; COLOR: rgb(33,37,41); FONT-STYLE: normal; ORPHANS: 2; WIDOWS: 2; LETTER-SPACING: normal; BACKGROUND-COLOR: rgb(255,255,255); TEXT-INDENT: 0px; font-variant-ligatures: normal; font-variant-caps: normal; -webkit-text-stroke-width: 0px; text-decoration-thickness: initial; text-decoration-style: initial; text-decoration-color: initial'>
<LI style="BOX-SIZING: border-box">As you may see, list of cache hosts is the most important knowledge for clients. And what we need to understand, is how this list is created, maintained and shared among all the clients. Let&#8217;s discuss several options.</LI>
<LI style="BOX-SIZING: border-box">In the first option we store a list of cache hosts in a file and deploy this file to service hosts using some continuous deployment pipeline. We can use configuration management tools such as chef and puppet to deploy file to every service host. This is the simplest option. But not very flexible. Every time list changes we need to make a code change and deploy it out to every service host.</LI>
<LI style="BOX-SIZING: border-box">What if we keep the file, but simplify the deployment process? Specifically, we may put the file to the shared storage and make service hosts poll for the file periodically. This is exactly what the second option is about. All service hosts try to retrieve the file from some common location, for example S3 storage service. To implement this option, we may introduce a daemon process that runs on each service host and polls data from the storage once a minute or several minutes. The drawback of this approach is that we still need to maintain the file manually. Make changes and deploy it to the shared storage every time cache host dies or new host is added.</LI>
<LI style="BOX-SIZING: border-box">It would be great if we could somehow monitor cache server health and if something bad happens to the cache server, all service hosts are notified and stop sending any requests to the unavailable cache server. And if a new cache server is added, all service hosts are also notified and start sending requests to it. To implement this approach, we will need a new service, configuration service, whose purpose is to discover cache hosts and monitor their health. Each cache server registers itself with the configuration service and sends heartbeats to the configuration service periodically. As long as heartbeats come, server is keep registered in the system. If heartbeats stop coming, the configuration service unregisters a cache server that is no longer alive or inaccessible. And every cache client grabs the list of registered cache servers from the configuration service.</LI>
<LI style="BOX-SIZING: border-box">The third option is the hardest from implementation standpoint and its operational cost is higher. But it helps to fully automate the list maintenance. And in a couple of minutes you will see one other benefit of using configuration service for a distributed cache.</LI></UL>