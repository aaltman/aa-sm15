Abstract<BR>TensorFlow is a machine learning system that operates at large scale and in heterogeneous environments. Tensor- Flow uses dataflow graphs to represent computation, shared state, and the operations that mutate that state. It maps the nodes of a dataflow graph across many machines in a cluster, and within a machine across multiple com- putational devices, including multicore CPUs, general- purpose GPUs, and custom-designed ASICs known as Tensor Processing Units (TPUs). This architecture gives flexibility to the application developer: whereas in previ- ous &#8220;parameter server&#8221; designs the management of shared state is built into the system, TensorFlow enables develop- ers to experiment with novel optimizations and training al- gorithms. TensorFlow supports a variety of applications, with a focus on training and inference on deep neural net- works. Several Google services use TensorFlow in pro- duction, we have released it as an open-source project, and it has become widely used for machine learning research. In this paper, we describe the TensorFlow dataflow model and demonstrate the compelling performance that Tensor- Flow achieves for several real-world applications.</P>
<P>&nbsp;&nbsp;&nbsp; 1 Introduction<BR>In recent years, machine learning has driven advances in many different fields [3, 5, 24, 25, 29, 31, 42, 47, 50,<BR>52, 57, 67, 68, 72, 76]. We attribute this success to the invention of more sophisticated machine learning mod- els [44, 54], the availability of large datasets for tack- ling problems in these fields [9, 64], and the develop- ment of software platforms that enable the easy use of large amounts of computational resources for training such models on these large datasets [14, 20].<BR>We have developed the TensorFlow system for ex- perimenting with new models, training them on large<BR>datasets, and moving them into production. We have based TensorFlow on many years of experience with our first-generation system, DistBelief [20], both simplify- ing and generalizing it to enable researchers to explore a wider variety of ideas with relative ease. TensorFlow supports both large-scale training and inference: it effi- ciently uses hundreds of powerful (GPU-enabled) servers for fast training, and it runs trained models for inference in production on various platforms, ranging from large dis- tributed clusters in a datacenter, down to running locally on mobile devices. At the same time, it is flexible enough to support experimentation and research into new machine learning models and system-level optimizations.<BR>TensorFlow uses a unified dataflow graph to repre- sent both the computation in an algorithm and the state on which the algorithm operates. We draw inspiration from the high-level programming models of dataflow sys- tems [2, 21, 34] and the low-level efficiency of parame- ter servers [14, 20, 49]. Unlike traditional dataflow sys- tems, in which graph vertices represent functional compu- tation on immutable data, TensorFlow allows vertices to represent computations that own or update mutable state. Edges carry tensors (multi-dimensional arrays) between nodes, and TensorFlow transparently inserts the appropri- ate communication between distributed subcomputations. By unifying the computation and state management in a single programming model, TensorFlow allows program- mers to experiment with different parallelization schemes that, for example, offload computation onto the servers that hold the shared state to reduce the amount of network traffic. We have also built various coordination protocols, and achieved encouraging results with synchronous repli- cation, echoing recent results [10, 18] that contradict the commonly held belief that asynchronous replication is re- quired for scalable learning [14, 20, 49].<BR>Over the past year, more than 150 teams at Google have used TensorFlow, and we have released the system as an<BR>open-source project.1 Thanks to our large community of users we have gained experience with many different ma- chine learning applications. In this paper, we focus on neural network training as a challenging systems problem, and select two representative applications from this space: image classification and language modeling. These ap- plications stress computational throughput and aggregate model size respectively, and we use them both to demon- strate the extensibility of TensorFlow, and to evaluate the efficiency and scalability of our present implementation.</P>
<P>&nbsp;&nbsp;&nbsp; 2 Background &amp; motivation<BR>We begin by describing the limitations of our previous system (&#167;2.1) and outlining the design principles that we used in the development of TensorFlow (&#167;2.2).</P>
<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 2.1 Previous system: DistBelief<BR>TensorFlow is the successor to DistBelief, which is the distributed system for training neural networks that Google has used since 2011 [20]. DistBelief uses the pa- rameter server architecture, and here we criticize its lim- itations, but other systems based on this architecture have addressed these limitations in other ways [11, 14, 49]; we discuss those systems in Subsection 2.3.<BR>In the parameter server architecture, a job comprises two disjoint sets of processes: stateless worker processes that perform the bulk of the computation when training a model, and stateful parameter server processes that main- tain the current version of the model parameters. Dist- Belief&#8217;s programming model is similar to Caffe&#8217;s [38]: the user defines a neural network as a directed acyclic graph of layers that terminates with a loss function. A layer is a composition of mathematical operators: for example, a fully connected layer multiplies its input by a weight ma- trix, adds a bias vector, and applies a non-linear function (such as a sigmoid) to the result. A loss function is a scalar function that quantifies the difference between the pre- dicted value (for a given input data point) and the ground truth. In a fully connected layer, the weight matrix and bias vector are parameters, which a learning algorithm will update in order to minimize the value of the loss func- tion. DistBelief uses the DAG structure and knowledge of the layers&#8217; semantics to compute gradients for each of the model parameters, via backpropagation [63]. Be- cause the parameter updates in many algorithms are com- mutative and have weak consistency requirements [61], the worker processes can compute updates independently</P>
<P>1Software available from <A href="https://tensorflow.org">https://tensorflow.org</A>.<BR>and write back &#8220;delta&#8221; updates to each parameter server, which combines the updates with its current state.<BR>Although DistBelief has enabled many Google prod- ucts to use deep neural networks and formed the basis of many machine learning research projects, we soon began to feel its limitations. Its Python-based scripting interface for composing pre-defined layers was adequate for users with simple requirements, but our more advanced users sought three further kinds of flexibility:<BR>Defining new layers For efficiency, we implemented DistBelief layers as C++ classes. Using a separate, less familiar programming language for implementing layers is a barrier for machine learning researchers who seek to experiment with new layer architectures, such as sampled softmax classifiers [37] and attention modules [53].<BR>Refining the training algorithms Many neural net- works are trained using stochastic gradient descent (SGD), which iteratively refines the parameters of the net- work by moving them in the direction that maximally de- creases the value of the loss function. Several refinements to SGD accelerate convergence by changing the update rule [23, 66]. Researchers often want to experiment with new optimization methods, but doing that in DistBelief involves modifying the parameter server implementation. Moreover, the get() and put() interface for the pa- rameter server is not ideal for all optimization methods: sometimes a set of related parameters must be updated atomically, and in many cases it would be more efficient to offload computation onto the parameter server, and thereby reduce the amount of network traffic.<BR>Defining new training algorithms DistBelief workers follow a fixed execution pattern: read a batch of input data and the current parameter values, compute the loss func- tion (a forward pass through the network), compute gra- dients for each of the parameter (a backward pass), and write the gradients back to the parameter server. This pat- tern works for training simple feed-forward neural net- works, but fails for more advanced models, such as recur- rent neural networks, which contain loops [39]; adversar- ial networks, in which two related networks are trained al- ternately [26]; and reinforcement learning models, where the loss function is computed by some agent in a separate system, such as a video game emulator [54]. Moreover, there are many other machine learning algorithms&#8212;such as expectation maximization, decision forest training, and latent Dirichlet allocation&#8212;that do not fit the same mold as neural network training, but could also benefit from a common, well-optimized distributed runtime.<BR>In addition, we designed DistBelief with a single plat- form in mind: a large distributed cluster of multicore<BR># 1. Construct a graph representing the model.<BR>x = tf.placeholder(tf.float32, [BATCH_SIZE, 784]) # Placeholder for input. y = tf.placeholder(tf.float32, [BATCH_SIZE, 10])&nbsp;# Placeholder for labels.</P>
<P>W_1 = tf.Variable(tf.random_uniform([784, 100]))&nbsp;# 784x100 weight matrix. b_1 = tf.Variable(tf.zeros([100]))&nbsp;# 100-element bias vector. layer_1 = tf.nn.relu(tf.matmul(x, W_1) + b_2)&nbsp;# Output of hidden layer.</P>
<P>W_2 = tf.Variable(tf.random_uniform([100, 10]))&nbsp;# 100x10 weight matrix. b_2 = tf.Variable(tf.zeros([10]))&nbsp;# 10-element bias vector. layer_2 = tf.matmul(layer_1, W_2) + b_2&nbsp;# Output of linear layer.</P>
<P># 2. Add nodes that represent the optimization algorithm. loss = tf.nn.softmax_cross_entropy_with_logits(layer_2, y) train_op = tf.train.AdagradOptimizer(0.01).minimize(loss)</P>
<P># 3. Execute the graph on batches of input data.<BR>with tf.Session() as sess:&nbsp;# Connect to the TF runtime. sess.run(tf.initialize_all_variables())&nbsp;# Randomly initialize weights.<BR>for step in range(NUM_STEPS):&nbsp;# Train iteratively for NUM_STEPS. x_data, y_data = ...&nbsp;# Load one batch of input data. sess.run(train_op, {x: x_data, y: y_data})&nbsp;# Perform one training step.<BR>Figure 1: An image classifier written using TensorFlow&#8217;s Python API. This program is a simple solution to the MNIST digit classification problem [48], with 784-pixel images and 10 output classes.</P>
<P>servers [20]. We were able to add support for GPU ac- celeration, when it became clear that this acceleration would be crucial for executing convolutional kernels effi- ciently [44], but DistBelief remains a heavyweight system that is geared for training deep neural networks on huge datasets, and is difficult to scale down to other environ- ments. In particular, many users want to hone their model locally on a GPU-powered workstation, before scaling the same code to train on a much larger dataset. After train- ing a model on a cluster, the next step is to push the model into production, which might involve integrating the model into an online service, or deploying it onto a mobile device for offline execution. Each of these tasks has some common computational structure, but our col- leagues found it necessary to use or create separate sys- tems that satisfy the different performance and resource requirements of each platform. TensorFlow provides a single programming model and runtime system for all of these environments.</P>
<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 2.2 Design principles<BR>We designed TensorFlow to be much more flexible than DistBelief, while retaining its ability to satisfy the de- mands of Google&#8217;s production machine learning work- loads. TensorFlow provides a simple dataflow-based pro- gramming abstraction that allows users to deploy appli-<BR>cations on distributed clusters, local workstations, mo- bile devices, and custom-designed accelerators. A high- level scripting interface (Figure 1) wraps the construction of dataflow graphs and enables users to experiment with different model architectures and optimization algorithms without modifying the core system. In this subsection, we briefly highlight TensorFlow&#8217;s core design principles:<BR>Dataflow graphs of primitive operators Both Tensor- Flow and DistBelief use a dataflow representation for their models, but the most striking difference is that a Dist- Belief model comprises relatively few complex &#8220;layers&#8221;, whereas the corresponding TensorFlow model represents individual mathematical operators (such as matrix mul- tiplication, convolution, etc.) as nodes in the dataflow graph. This approach makes it easier for users to com- pose novel layers using a high-level scripting interface. Many optimization algorithms require each layer to have defined gradients, and building layers out of simple oper- ators makes it easy to differentiate these models automat- ically (&#167;4.1). In addition to the functional operators, we represent mutable state, and the operations that update it, as nodes in the dataflow graph, thus enabling experimen- tation with different update rules.<BR>Deferred execution A typical TensorFlow application has two distinct phases: the first phase defines the pro- gram (e.g., a neural network to be trained and the update rules) as a symbolic dataflow graph with placeholders for<BR>the input data and variables that represent the state; and the second phase executes an optimized version of the program on the set of available devices. By deferring the execution until the entire program is available, Tensor- Flow can optimize the execution phase by using global information about the computation. For example, Tensor- Flow achieves high GPU utilization by using the graph&#8217;s dependency structure to issue a sequence of kernels to the GPU without waiting for intermediate results. While this design choice makes execution more efficient, we have had to push more complex features&#8212;such as dynamic control flow (&#167;3.4)&#8212;into the dataflow graph, so that mod- els using these features enjoy the same optimizations.<BR>Common abstraction for heterogeneous accelerators In addition to general-purpose devices such as multicore CPUs and GPUs, special-purpose accelerators for deep learning can achieve significant performance improve- ments and power savings. At Google, our colleagues have built the Tensor Processing Unit (TPU) specifically for machine learning; TPUs yield an order of magnitude improvement in performance-per-watt compared to alter- native state-of-the-art technology [40]. To support these accelerators in TensorFlow, we define a common abstrac- tion for devices. At a minimum, a device must implement methods for (i) issuing a kernel for execution, (ii) allocat- ing memory for inputs and outputs, and (iii) transferring buffers to and from host memory. Each operator (e.g., matrix multiplication) can have multiple specialized im- plementations for different devices. As a result, the same program can easily target GPUs, TPUs, or mobile CPUs as required for training, serving, and offline inference.<BR>TensorFlow uses tensors of primitive values as a com- mon interchange format that all devices understand. At the lowest level, all tensors in TensorFlow are dense; sparse tensors can be represented in terms of dense ones (&#167;3.1). This decision ensures that the lowest levels of the system have simple implementations for memory alloca- tion and serialization, thus reducing the framework over- head. Tensors also enable other optimizations for memory management and communication, such as RDMA and di- rect GPU-to-GPU transfer.<BR>The main consequence of these principles is that in TensorFlow there is no such thing as a parameter server. On a cluster, we deploy TensorFlow as a set of tasks (named processes that can communicate over a network) that each export the same graph execution API and con- tain one or more devices. Typically a subset of those tasks assumes the role that a parameter server plays in other systems [11, 14, 20, 49], and we therefore call them PS tasks; the others are worker tasks. However, since a PS task is capable of running arbitrary TensorFlow graphs,<BR>it is more flexible than a conventional parameter server: users can program it with the same scripting interface that they use to define models. This flexibility is the key dif- ference between TensorFlow and contemporary systems, and in the rest of the paper we will discuss some of the applications that this flexibility enables.</P>
<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 2.3 Related work<BR>Single-machine frameworks Many machine learning researchers carry out their work on a single&#8212;often GPU- equipped&#8212;computer [43, 44], and several single-machine frameworks support this scenario. Caffe [38] is a high- performance framework for training declaratively speci- fied neural networks on multicore CPUs and GPUs. As discussed above, its programming model is similar to DistBelief (&#167;2.1), so it is easy to compose models from existing layers, but relatively difficult to add new layers or optimizers. Theano [2] allows programmers to express a model as a dataflow graph of primitive operators, and generates efficient compiled code for training that model. Its programming model is closest to TensorFlow, and it provides much of the same flexibility in a single machine. Unlike Caffe, Theano, and TensorFlow, Torch [17] of- fers a powerful imperative programming model for sci- entific computation and machine learning. It allows fine- grained control over the execution order and memory uti- lization, which enables power users to optimize the per- formance of their programs. While this flexibility is use- ful for research, Torch lacks the advantages of a dataflow graph as a portable representation across small-scale ex-<BR>perimentation, production training, and deployment.<BR>Batch dataflow systems Starting with MapRe- duce [21], batch dataflow systems have been applied to a large number of machine learning algorithms [70], and more recent systems have focused on increasing expressivity and performance. DryadLINQ [74] adds a high-level query language that supports more sophisti- cated algorithms than MapReduce. Spark [75] extends DryadLINQ with the ability to cache previously com- puted datasets in memory, and is therefore better suited to iterative machine learning algorithms (such as k-means clustering and logistic regression) when the input data fit in memory. Dandelion extends DryadLINQ with code generation for GPUs [62] and FPGAs [16].<BR>The principal limitation of a batch dataflow system is that it requires the input data to be immutable, and all of the subcomputations to be deterministic, so that the system can re-execute subcomputations when machines in the cluster fail. This feature&#8212;which is beneficial for many conventional workloads&#8212;makes updating a ma-</P>
<P><BR>Figure 2: A schematic TensorFlow dataflow graph for a training pipeline, containing subgraphs for reading input data, preprocessing, training, and checkpointing state.</P>
<P>chine learning model an expensive operation. For ex- ample, the SparkNet system for training deep neural net- works on Spark takes 20 seconds to broadcast weights and collect updates from five workers [55]. As a result, in these systems, each model update step must process larger batches, slowing convergence [8]. We show in Subsec- tion 6.3 that TensorFlow can train larger models on larger clusters with step times as short as 2 seconds.<BR>Parameter servers As we discuss in Subsection 2.1, a parameter server architecture uses a set of servers to man- age shared state that is updated by a set of parallel work- ers. This architecture emerged in work on scalable topic modeling [65], and DistBelief showed how it can apply to deep neural network training. Project Adam [14] fur- ther applied this architecture for the efficient training of convolutional neural networks; and Li et al.&#8217;s &#8220;Parame- ter Server&#8221; [49] added innovations in consistency mod- els, fault tolerance, and elastic rescaling. Despite earlier skepticism that parameter servers would be compatible with GPU acceleration [14], Cui et al. recently showed that a parameter server specialized for use with GPUs can achieve speedups on small clusters [18].<BR>MXNet [11] is perhaps the closest system in design to TensorFlow. It uses a dataflow graph to represent the computation at each worker, and uses a parameter server to scale training across multiple machines. The MXNet parameter server exports a key-value store interface that supports aggregating updates sent from multiple devices in each worker, and using an arbitrary user-provided func- tion to combine incoming updates with the current value. The MXNet key-value store interface [22] does not cur- rently allow sparse gradient updates within a single value, which are crucial for the distributed training of large mod- els (&#167;4.2), and adding this feature would require modifi- cations to the core system.<BR>The parameter server architecture meets many of our requirements, and with sufficient engineering effort it would be possible to build most of the features that we describe in this paper into a parameter server. For Tensor-<BR>Flow we sought a high-level programming model that al- lows users to customize the code that runs in all parts of the system, so that the cost of experimentation with new optimization algorithms and model architectures is lower. In the next section, we describe the building blocks of a TensorFlow program in more detail.</P>
<P>&nbsp;&nbsp;&nbsp; 3 TensorFlow execution model<BR>TensorFlow uses a single dataflow graph to represent all computation and state in a machine learning algo- rithm, including the individual mathematical operations, the parameters and their update rules, and the input pre- processing (Figure 2). The dataflow graph expresses the communication between subcomputations explicitly, thus making it easy to execute independent computations in parallel and to partition computations across multiple de- vices. TensorFlow differs from batch dataflow systems (&#167;2.3) in two respects:</P>
<P>&nbsp;&nbsp;&nbsp; &#8226; The model supports multiple concurrent executions on overlapping subgraphs of the overall graph.<BR>&nbsp;&nbsp;&nbsp; &#8226; Individual vertices may have mutable state that can be shared between different executions of the graph.</P>
<P>The key observation in the parameter server architec- ture [14, 20, 49] is that mutable state is crucial when training very large models, because it becomes possible to make in-place updates to very large parameters, and prop- agate those updates to parallel training steps as quickly as possible. Dataflow with mutable state enables Tensor- Flow to mimic the functionality of a parameter server, but with additional flexibility, because it becomes pos- sible to execute arbitrary dataflow subgraphs on the ma- chines that host the shared model parameters. As a re- sult, our users have been able to experiment with different optimization algorithms, consistency schemes, and paral- lelization strategies.<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 3.1 Dataflow graph elements<BR>In a TensorFlow graph, each vertex represents a unit of local computation, and each edge represents the output from, or input to, a vertex. We refer to the computation at vertices as operations, and the values that flow along edges as tensors. In this subsection, we describe the com- mon types of operations and tensors.<BR>Tensors In TensorFlow, we model all data as tensors (n-dimensional arrays) with the elements having one of a small number of primitive types, such as int32, float32, or string (where string can represent ar- bitrary binary data). Tensors naturally represent the inputs to and results of the common mathematical operations in many machine learning algorithms: for example, a matrix multiplication takes two 2-D tensors and produces a 2-D tensor; and a batch 2-D convolution takes two 4-D tensors and produces another 4-D tensor.<BR>At the lowest level, all TensorFlow tensors are dense, for the reasons we discuss in Subsection 2.2. TensorFlow offers two alternatives for representing sparse data: either encode the data into variable-length string elements of a dense tensor, or use a tuple of dense tensors (e.g., an n-D sparse tensor with m non-zero elements can be rep- resented in coordinate-list format as an m &#215; n matrix of coordinates and a length-m vector of values). The shape of a tensor can vary in one or more of its dimensions, which makes it possible to represent sparse tensors with differing numbers of elements.<BR>Operations An operation takes m &#8805; 0 tensors as input and produces n &#8805; 0 tensors as output. An operation has a named &#8220;type&#8221; (such as Const, MatMul, or Assign) and may have zero or more compile-time attributes that determine its behavior. An operation can be polymorphic and variadic at compile-time: its attributes determine both the expected types and arity of its inputs and outputs.<BR>For example, the simplest operation Const has no in- puts and a single output; its value is a compile-time at- tribute. For example, AddN sums multiple tensors of the same element type, and it has a type attribute T and an integer attribute N that define its type signature.<BR>Stateful operations: variables An operation can con- tain mutable state that is read and/or written each time it executes. A Variable operation owns a mutable buffer that may be used to store the shared parameters of a model as it is trained. A Variable has no inputs, and produces a reference handle, which acts as a typed capability for reading and writing the buffer. A Read operation takes a reference handle r as input, and out- puts the value of the variable (State[r]) as a dense ten- sor. Other operations modify the underlying buffer: for<BR>example, AssignAdd takes a reference handle r and a tensor value x, and when executed performs the update<BR>&#8242;<BR>State [r] &#8594; State[r] + x. Subsequent Read(r) opera-<BR>&#8242;<BR>tions produce the value State [r].<BR>Stateful operations: queues TensorFlow includes sev- eral queue implementations, which support more ad- vanced forms of coordination. The simplest queue is FIFOQueue, which owns an internal queue of tensors, and allows concurrent access in first-in-first-out order. Other types of queues dequeue tensors in random and pri- ority orders, which ensure that input data are sampled ap- propriately. Like a Variable, the FIFOQueue opera- tion produces a reference handle that can be consumed by one of the standard queue operations, such as Enqueue and Dequeue. These operations push their input onto the tail of the queue and, respectively, pop the head element and output it. Enqueue will block if its given queue is full, and Dequeue will block if its given queue is empty. When queues are used in an input preprocessing pipeline, this blocking provides backpressure; it also supports syn- chronization (&#167;4.4). The combination of queues and dy- namic control flow (&#167;3.4) can also implement a form of streaming computation between subgraphs.</P>
<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 3.2 Partial and concurrent execution<BR>TensorFlow uses a dataflow graph to represent all possible computations in a particular application. The API for ex- ecuting a graph allows the client to specify declaratively the subgraph that should be executed. The client selects zero or more edges to feed input tensors into the dataflow, and one or more edges to fetch output tensors from the dataflow; the runtime then prunes the graph to contain the necessary set of operations. Each invocation of the API is called a step, and TensorFlow supports multiple concur- rent steps on the same graph. Stateful operations allow steps to share data and synchronize when necessary.<BR>Figure 2 shows a typical training application, with multiple subgraphs that execute concurrently and interact through shared variables and queues. The core training subgraph depends on a set of model parameters and on in- put batches from a queue. Many concurrent steps of the training subgraph update the model based on different in- put batches, to implement data-parallel training. To fill the input queue, concurrent preprocessing steps transform individual input records (e.g., decoding images and apply- ing random distortions), and a separate I/O subgraph reads records from a distributed file system. A checkpointing subgraph runs periodically for fault tolerance (&#167;4.3).<BR>Partial and concurrent execution is responsible for much of TensorFlow&#8217;s flexibility. Adding mutable state<BR>and coordination via queues makes it possible to spec- ify a wide variety of model architectures in user-level code, which enables advanced users to experiment with- out modifying the internals of the TensorFlow runtime. By default, concurrent executions of a TensorFlow sub- graph run asynchronously with respect to one another. This asynchrony makes it straightforward to implement machine learning algorithms with weak consistency re- quirements [61], which include many neural network training algorithms [20]. As we discuss later, TensorFlow also provides the primitives needed to synchronize work- ers during training (&#167;4.4), which has led to promising re- sults on some learning tasks (&#167;6.3).</P>
<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 3.3 Distributed execution<BR>Dataflow simplifies distributed execution, because it makes communication between subcomputations explicit. It enables the same TensorFlow program to be deployed to a cluster of GPUs for training, a cluster of TPUs for serving, and a cellphone for mobile inference.<BR>Each operation resides on a particular device, such as a CPU or GPU in a particular task. A device is responsible for executing a kernel for each operation assigned to it. TensorFlow allows multiple kernels to be registered for a single operation, with specialized implementations for a particular device or data type (see &#167;5 for details). For many operations, such as element-wise operators (Add, Sub, etc.), we can compile a single kernel implementation for CPU and GPU using different compilers.<BR>The TensorFlow runtime places operations on devices, subject to implicit or explicit constraints in the graph. The placement algorithm computes a feasible set of de- vices for each operation, calculates the sets of operations that must be colocated, and selects a satisfying device for each colocation group. It respects implicit colocation con- straints that arise because each stateful operation and its state must be placed on the same device. In addition, the user may specify partial device preferences such as &#8220;any device in a particular task&#8221;, or &#8220;a GPU in any task&#8221;, and the runtime will respect these constraints. A typical training application will use client-side programming con- structs to add constraints such that, for example, parame- ters are distributed among a set of &#8220;PS&#8221; tasks (&#167;4.2).<BR>TensorFlow thus permits great flexibility in how opera- tions in the dataflow graph are mapped to devices. While simple heuristics yield adequate performance for novice users, expert users can optimize performance by manually placing operations to balance the computation, memory, and network requirements across multiple tasks and mul- tiple devices within those tasks. An open question is how<BR>input = ... # A sequence of tensors state = 0&nbsp;# Initial state<BR>w = ...&nbsp;# Trainable weights</P>
<P>for i in range(len(input)):<BR>state, out[i] = f(state, w, input[i])</P>
<P>Figure 3: Pseudocode for an abstract RNN (&#167;3.4). The function f typically comprises differentiable operations such as matrix multiplications and convolutions [32]. TensorFlow implements the loop in its dataflow graph.</P>
<P>TensorFlow can automatically determine placements that achieve close to optimal performance on a given set of de- vices, thus freeing users from this concern. Even without such automation, it may be worthwhile to separate place- ment directives from other aspects of model definitions, so that, for example, it would be trivial to modify place- ments after a model has been trained.<BR>Once the operations in a graph have been placed, and the partial subgraph has been computed for a step (&#167;3.2), TensorFlow partitions the operations into per-device sub- graphs. A per-device subgraph for device d contains all of the operations that were assigned to d, with additional Send and Recv operations that replace edges across de- vice boundaries. Send transmits its single input to a spec- ified device as soon as the tensor is available, using a ren- dezvous key to name the value. Recv has a single output, and blocks until the value for a specified rendezvous key is available locally, before producing that value. Send and Recv have specialized implementations for several device-type pairs; we describe some of these in Section 5. We optimized TensorFlow for executing large sub- graphs repeatedly with low latency. Once the graph for a step has been pruned, placed, and partitioned, its sub- graphs are cached in their respective devices. A client session maintains the mapping from step definitions to cached subgraphs, so that a distributed step on a large graph can be initiated with one small message to each par- ticipating task. This model favors static, reusable graphs, but it can support dynamic computations using dynamic<BR>control flow, as the next subsection describes.</P>
<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 3.4 Dynamic control flow<BR>TensorFlow supports advanced machine learning algo- rithms that contain conditional and iterative control flow. For example, a recurrent neural network (RNN) [39] such as an LSTM [32] can generate predictions from sequential data. Google&#8217;s Neural Machine Translation system uses TensorFlow to train a deep LSTM that achieves state-of-<BR>the-art performance on many translation tasks [73]. The core of an RNN is a recurrence relation, where the output for sequence element i is a function of some state that ac- cumulates across the sequence (Figure 3). In this case, dy- namic control flow enables iteration over sequences that have variable lengths, without unrolling the computation to the length of the longest sequence.<BR>As we discussed in Subsection 2.2, TensorFlow uses deferred execution via the dataflow graph to offload larger chunks of work to accelerators. Therefore, to imple- ment RNNs and other advanced algorithms, we add con- ditional (if statement) and iterative (while loop) program- ming constructs in the dataflow graph itself. We use these primitives to build higher-order constructs, such as map(), fold(), and scan() [2].<BR>For this purpose, we borrow the Switch and Merge primitives from classic dynamic dataflow archi- tectures [4]. Switch is a demultiplexer: it takes a data input and a control input, and uses the control input to select which of its two outputs should produce a value.<BR>The Switch output not taken receives a special dead value, which propagates recursively through the rest of the graph until it reaches a Merge operation. Merge is a multiplexer: it forwards at most one non-dead input to its output, or produces a dead output if both of its inputs are dead. The conditional operator uses Switch to ex- ecute one of two branches based on the runtime value of a boolean tensor, and Merge to combine the outputs of the branches. The while loop is more complicated, and uses Enter, Exit, and NextIteration operators to ensure that the loop is well-formed [56].<BR>The execution of iterations can overlap, and Tensor- Flow can also partition conditional branches and loop bodies across multiple devices and processes. The par- titioning step adds logic to coordinate the start and ter- mination of each iteration on each device, and to decide the termination of the loop. As we will see in Subsec- tion 4.1, TensorFlow also supports automatic differenti- ation of control flow constructs. Automatic differentia- tion adds the subgraphs for computing gradients to the dataflow graph, which TensorFlow partitions across po- tentially distributed devices to compute the gradients in parallel.</P>
<P>&nbsp;&nbsp;&nbsp; 4 Extensibility case studies<BR>By choosing a unified representation for all computation in TensorFlow, we enable users to experiment with fea- tures that were hard-coded into the DistBelief runtime. In this section, we discuss four extensions that we have built using dataflow primitives and &#8220;user-level&#8221; code.<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 4.1 Differentiation and optimization<BR>Many learning algorithms train a set of parameters using some variant of SGD, which entails computing the gradi- ents of a loss function with respect to those parameters, then updating the parameters based on those gradients. TensorFlow includes a user-level library that differentiates a symbolic expression for a loss function and produces a new symbolic expression representing the gradients. For example, given a neural network as a composition of lay- ers and a loss function, the library will automatically de- rive the backpropagation code.<BR>The differentiation algorithm performs breadth-first search to identify all of the backwards paths from the tar- get operation (e.g., a loss function) to a set of parameters, and sums the partial gradients that each path contributes. Our users frequently specialize the gradients for some op- erations, and they have implemented optimizations like batch normalization [33] and gradient clipping [60] to ac- celerate training and make it more robust. We have ex- tended the algorithm to differentiate conditional and it- erative subcomputations (&#167;3.4) by adding nodes to the graph that record the control flow decisions in the for- ward pass, and replaying those decisions in reverse during the backward pass. Differentiating iterative computations over long sequences can lead to a large amount of inter- mediate state being accumulated in memory, and we have developed techniques for managing limited GPU memory on these computations.<BR>TensorFlow users can also experiment with a wide range of optimization algorithms, which compute new values for the parameters in each training step. SGD is easy to implement in a parameter server: for each param-<BR>eter W , gradient &#8706;L/&#8706;W , and learning rate &#945;, the update rule is W &#8242; &#8594; W &#8722; &#945; &#215; &#8706;L/&#8706;W . A parameter server can implement SGD by using -= as the write operation, and writing &#945; &#215; &#8706;L/&#8706;W to each W after a training step.<BR>However, there are many more advanced optimization schemes that are difficult to express as a single write op- eration. For example, the Momentum algorithm accumu- lates a &#8220;velocity&#8221; for each parameter based on its gradi- ent over multiple iterations, then computes the parameter update from that accumulation; and many refinements to this algorithm have been proposed [66]. Implementing Momentum in DistBelief [20], required modifications to the parameter server implementation to change the rep- resentation of parameter data, and execute complex logic in the write operation; such modifications are challeng- ing for many users. Optimization algorithms are the topic of active research, and researchers have implemented sev- eral on top of TensorFlow, including Momentum, Ada- Grad, AdaDelta, RMSProp, Adam, and L-BFGS. These</P>
<P><BR>Figure 4: Schematic dataflow for an embedding layer (&#167;4.2) with a two-way sharded embedding matrix.</P>
<P>can be built in TensorFlow using Variable operations and primitive mathematical operations without modifying the underlying system, so it is easy to experiment with new algorithms as they emerge.</P>
<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 4.2 Training very large models<BR>To train a model on high-dimensional data, such as words in a corpus of text [7], it is common to use a distributed representation, which embeds a training example as a pat- tern of activity across several neurons, and which can be learned by backpropagation [30]. For example, in a lan- guage model, a training example might be a sparse vector with non-zero entries corresponding to the IDs of words in a vocabulary, and the distributed representation for each word will be a lower-dimensional vector [6]. &#8220;Wide and deep learning&#8221; creates distributed representations from cross-product transformations on categorical features, and the implementation on TensorFlow is used to power the Google Play app store recommender system [12].<BR>Inference begins by multiplying a batch of b sparse vec- tors against an n &#215; d embedding matrix, where n is the number of words in the vocabulary, and d is the desired dimensionality, to produce a much smaller b &#215; d dense matrix representation; for training, most optimization al- gorithms modify only the rows of the embedding matrix that were read by the sparse multiplication. In TensorFlow models that process sparse data, n &#215; d can amount to gi- gabytes of parameters: e.g., a large language model may use over 109 parameters with a vocabulary of 800,000 words [41], and we have experience with document mod- els [19] where the parameters occupy several terabytes. Such models are too large to copy to a worker on every use, or even to store in RAM on a single host.<BR>We implement sparse embedding layers in the Tensor- Flow graph as a composition of primitive operations. Fig- ure 4 shows a simplified graph for an embedding layer that is split across two parameter server tasks. The core operation of this subgraph is Gather, which extracts a sparse set of rows from a tensor, and TensorFlow colo-<BR>cates this operation with the variable on which it operates. The dynamic partition (Part) operation divides the in- coming indices into variable-sized tensors that contain the indices destined for each shard, and the dynamic stitching (Stitch) operation reassembles the partial results from each shard into a single result tensor. Each of these op- erations has a corresponding gradient, so it supports au- tomatic differentiation (&#167;4.1), and the result is a set of sparse update operations that act on just the values that were originally gathered from each of the shards.<BR>Users writing a TensorFlow model typically do not con- struct graphs like Figure 4 manually. Instead TensorFlow includes libraries that expose the abstraction of a sharded parameter, and build appropriate graphs of primitive op- erations based on the desired degree of distribution.<BR>While sparse reads and updates are possible in a pa- rameter server [49], TensorFlow adds the flexibility to offload arbitrary computation onto the devices that host the shared parameters. For example, classification mod- els typically use a softmax classifier that multiplies the final output by a weight matrix with c columns, where c is the number of possible classes; for a language model, c is the size of the vocabulary, which can be large. Our users have experimented with several schemes to accel- erate the softmax calculation. The first is similar to an optimization in Project Adam [14], whereby the weights are sharded across several tasks, and the multiplication and gradient calculation are colocated with the shards. More efficient training is possible using a sampled soft- max [37], which performs a sparse multiplication based on the true class for an example and a set of randomly sampled false classes. We compare the performance of these two schemes in &#167;6.4.</P>
<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 4.3 Fault tolerance<BR>Training a model can take several hours or days, even us- ing a large number of machines [14, 20]. We often need to train a model using non-dedicated resources, for example using the Borg cluster manager [71], which does not guar- antee availability of the same resources for the duration of the training process. Therefore, a long-running Tensor- Flow job is likely to experience failure or pre-emption, and we require some form of fault tolerance. It is un- likely that tasks will fail so often that individual opera- tions need fault tolerance, so a mechanism like Spark&#8217;s RDDs [75] would impose significant overhead for little benefit. There is no need to make every write to the pa- rameter state durable, because we can recompute any up- date from the input data, and many learning algorithms do not require strong consistency [61].<BR>&nbsp;&nbsp;</P>
<P><BR>Figure 5: Three synchronization schemes for parallel SGD. Each color represents a different starting parameter value; a white square is a parameter update. In (c), a dashed rectangle represents a backup worker whose result is discarded.</P>
<P>We implement user-level checkpointing for fault tol- erance, using two operations in the graph (Figure 2): Save writes one or more tensors to a checkpoint file, and Restore reads one or more tensors from a checkpoint file. Our typical configuration connects each Variable in a task to the same Save operation, with one Save per task, to maximize the I/O bandwidth to a distributed file system. The Restore operations read named tensors from a file, and a standard Assign stores the restored value in its respective variable. During training, a typi- cal client runs all of the Save operations periodically to produce a new checkpoint; when the client starts up, it attempts to Restore the latest checkpoint.<BR>TensorFlow includes a client library for constructing the appropriate graph structure and for invoking Save and Restore as necessary. This behavior is customiz- able: the user can apply different policies to subsets of the variables in a model, or customize the checkpoint reten- tion scheme. For example, many users retain checkpoints with the highest score in a custom evaluation metric. The implementation is also reusable: it may be used for model fine-tuning and unsupervised pre-training [45, 47], which are forms of transfer learning, in which the parameters of a model trained on one task (e.g., recognizing general im- ages) are used as the starting point for another task (e.g., recognizing breeds of dog). Having checkpoint and pa- rameter management as programmable operations in the graph gives users the flexibility to implement schemes like these and others that we have not anticipated.<BR>The checkpointing library does not attempt to produce consistent checkpoints: if training and checkpointing ex- ecute concurrently, the checkpoint may include none, all, or some of the updates from the training step. This be- havior is compatible with the relaxed guarantees of asyn- chronous SGD [20]. Consistent checkpoints require ad- ditional synchronization to ensure that update operations do not interfere with checkpointing; if desired, one can use the scheme in the next subsection to take a checkpoint after the synchronous update step.<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 4.4 Synchronous replica coordination<BR>SGD is robust to asynchrony [61], and many systems train deep neural networks using asynchronous parame- ter updates [14, 20], which are believed scalable because they maintain high throughput in the presence of strag- glers. The increased throughput comes at the cost of us- ing stale parameter values in training steps. Some have recently revisited the assumption that synchronous train- ing does not scale [10, 18]. Since GPUs enable training with hundreds&#8212;rather than thousands [47]&#8212;of machines, synchronous training may be faster (in terms of time to quality) than asynchronous training on the same platform.<BR>Though we originally designed TensorFlow for asyn- chronous training, we have begun experimenting with synchronous methods. The TensorFlow graph enables users to change how parameters are read and written when training a model, and we implement three alternatives. In the asynchronous case (Figure 5(a)), each worker reads the current values of parameters when each step begins, and applies its gradient to the (possibly different) current values at the end: this approach ensures high utilization, but the individual steps use stale parameter values, making each step less effective. We implement the synchronous version using queues (&#167;3.1) to coordinate execution: a blocking queue acts as a barrier to ensure that all workers read the same parameter values, and a per-variable queue accumulates gradient updates from all workers in order to apply them atomically. The simple synchronous version (Figure 5(b)) accumulates updates from all workers before applying them, but slow workers limit overall throughput.<BR>To mitigate stragglers, we implement backup work- ers (Figure 5(c), [10]), which are similar to MapReduce backup tasks [21]. Whereas MapReduce starts backup tasks reactively&#8212;after detecting a straggler&#8212;our backup workers run proactively, and the aggregation takes the first m of n updates produced. We exploit the fact that SGD samples training data randomly at each step, so each worker processes a different random batch, and it is not a</P>
<P><BR>&nbsp; </P>
<P>&nbsp;</P>
<P><BR>Figure 6: The layered TensorFlow architecture.</P>
<P>problem if a particular batch is ignored. In &#167;6.3 we show how backup workers improve throughput by up to 10%.</P>
<P>&nbsp;&nbsp;&nbsp; 5 Implementation<BR>The TensorFlow runtime is a cross-platform library. Fig- ure 6 illustrates its architecture: a C API separates user- level code in different languages from the core runtime.<BR>The core TensorFlow library is implemented in C++ for portability and performance: it runs on several operating systems including Linux, Mac OS X, Windows, Android, and iOS; the x86 and various ARM-based CPU architec- tures; and NVIDIA&#8217;s Kepler, Maxwell, and Pascal GPU microarchitectures. The implementation is open-source, and we have accepted several external contributions that enable TensorFlow to run on other architectures.<BR>The distributed master translates user requests into ex- ecution across a set of tasks. Given a graph and a step def- inition, it prunes (&#167;3.2) and partitions (&#167;3.3) the graph to obtain subgraphs for each participating device, and caches these subgraphs so that they may be re-used in subsequent steps. Since the master sees the overall computation for a step, it applies standard optimizations such as common subexpression elimination and constant folding; pruning is a form of dead code elimination. It then coordinates ex- ecution of the optimized subgraphs across a set of tasks.<BR>The dataflow executor in each task handles requests from the master, and schedules the execution of the ker- nels that comprise a local subgraph. We optimize the dataflow executor for running large graphs with low over- head. Our current implementation can execute 10,000 subgraphs per second (&#167;6.2), which enables a large num- ber of replicas to make rapid, fine-grained training steps. The dataflow executor dispatches kernels to local devices and runs kernels in parallel when possible, for example by using multiple CPU cores or GPU streams.<BR>The runtime contains over 200 standard operations, in- cluding mathematical, array manipulation, control flow, and state management operations. Many of the operation kernels are implemented using Eigen::Tensor [36], which uses C++ templates to generate efficient parallel code for multicore CPUs and GPUs; however, we liberally use li- braries like cuDNN [13] where a more efficient kernel implementation is possible. We have also implemented quantization, which enables faster inference in environ- ments such as mobile devices and high-throughput data- center applications, and use the gemmlowp low-precision matrix library [35] to accelerate quantized computation.<BR>We specialize Send and Recv operations for each pair of source and destination device types. Trans- fers between local CPU and GPU devices use the cudaMemcpyAsync() API to overlap computation and data transfer; transfers between two local GPUs use DMA to relieve pressure on the host. For transfers be- tween tasks, TensorFlow uses multiple protocols, includ- ing gRPC over TCP, and RDMA over Converged Ether- net. We are also investigating optimizations for GPU-to- GPU communication that use collective operations [59].<BR>Section 4 describes features that we implement com- pletely above the C API, in user-level code. Typically, users compose standard operations to build higher-level abstractions, such as neural network layers, optimization algorithms (&#167;4.1), and sharded embedding computations (&#167;4.2). TensorFlow supports multiple client languages, and we have prioritized Python and C++, because our in- ternal users are most familiar with these languages. As features become more established, we typically port them to C++, so that users can access an optimized implemen- tation from all client languages.<BR>If it is difficult or inefficient to represent a subcom- putation as a composition of operations, users can reg- ister additional kernels that provide an efficient imple- mentation written in C++. We have found it profitable to hand-implement fused kernels for some performance critical operations, such as the ReLU and Sigmoid acti- vation functions and their corresponding gradients. We are currently investigating automatic kernel fusion using a compilation-based approach.<BR>In addition to the core runtime, our colleagues have built several tools that aid users of TensorFlow. These include serving infrastructure for inference in produc- tion [27], a visualization dashboard that enables users to follow the progress of a training run, a graph visualizer that helps users to understand the connections in a model, and a distributed profiler that traces the execution of a computation across multiple devices and tasks. We de- scribe these tools in an extended whitepaper [1].<BR>&nbsp;&nbsp;&nbsp; 6 Evaluation</P>
<P>10000</P>
<P>In this section, we evaluate the performance of Tensor- Flow on several synthetic and realistic workloads. Unless otherwise stated, we run all experiments on a shared pro- duction cluster, and all figures plot median values with error bars showing the 10th and 90th percentiles.<BR>In this paper we focus on system performance met- rics, rather than learning objectives like time to accu- racy. TensorFlow is a system that allows machine learn- ing practitioners and researchers to experiment with new techniques, and this evaluation demonstrates that the sys- tem (i) has little overhead, and (ii) can employ large amounts of computation to accelerate real-world applica-</P>
<P><BR>1000</P>
<P><BR>100</P>
<P><BR>10</P>
<P><BR>1</P>
<P>&nbsp;</P>
<P>&nbsp;</P>
<P>&nbsp;</P>
<P>&nbsp;</P>
<P>&nbsp;</P>
<P>&nbsp;</P>
<P>&nbsp;</P>
<P>1&nbsp;2&nbsp;5&nbsp;10&nbsp;25&nbsp;50&nbsp; 100<BR>Number of workers</P>
<P>&nbsp;</P>
<P>Scalar Sparse 1GB Sparse 16GB Dense 100M Dense 1GB<BR>tions. While techniques like synchronous replication can enable some models to converge in fewer steps overall, we defer the analysis of such improvements to other papers.</P>
<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 6.1 Single-machine benchmarks<BR>Although TensorFlow is a system for &#8220;large-scale&#8221; ma- chine learning, it is imperative that scalability does not mask poor performance at small scales [51]. Table 1 con- tains results from Chintala&#8217;s benchmark of convolutional models on TensorFlow and three single-machine frame- works [15]. All frameworks use a six-core Intel Core i7- 5930K CPU at 3.5 GHz and an NVIDIA Titan X GPU.</P>
<P>Library<BR>Training<BR>step time (ms)</P>
<P>AlexNet<BR>Overfeat<BR>OxfordNet<BR>GoogleNet<BR>Caffe [38]<BR>324<BR>823<BR>1068<BR>1935<BR>Neon [58]<BR>87<BR>211<BR>320<BR>270<BR>Torch [17]<BR>81<BR>268<BR>529<BR>470<BR>TensorFlow<BR>81<BR>279<BR>540<BR>445<BR>Table 1: Step times for training four convolutional models with different libraries, using one GPU. All results are for training with 32-bit floats. The fastest time for each model is shown in bold.</P>
<P>Table 1 shows that TensorFlow achieves shorter step times than Caffe [38], and performance within 6% of the latest version of Torch [17]. We attribute the similar per- formance of TensorFlow and Torch to the fact that both use the same version of the cuDNN library [13], which implements the convolution and pooling operations on the critical path for training; Caffe uses open-source im- plementations for these operations that are simpler but less efficient than cuDNN. The Neon library [58] outper- forms TensorFlow on three of the models, by using hand- optimized convolutional kernels [46] implemented in as- sembly language; in principle, we could follow the same approach in TensorFlow, but we have not yet done so.<BR>Figure 7: Baseline throughput for synchronous replication<BR>with a null model. Sparse accesses enable TensorFlow to handle larger models, such as embedding matrices (&#167;4.2).</P>
<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 6.2 Synchronous replica microbenchmark<BR>The performance of our coordination implementation (&#167;4.4) is the main limiting factor for scaling with addi- tional machines. Figure 7 shows that number of null train- ing steps that TensorFlow performs per second for vary- ing model sizes, and increasing numbers of synchronous workers. In a null training step, a worker fetches the shared model parameters from 16 PS tasks, performs a trivial computation, and sends updates to the parameters.<BR>The Scalar curve in Figure 7 shows the best perfor- mance that we could expect for a synchronous training step, because only a single 4-byte value is fetched from each PS task. The median step time is 1.8 ms using a sin- gle worker, growing to 8.8 ms with 100 workers. These times measure the overhead of the synchronization mech- anism, and capture some of the noise that we expect when running on a shared cluster.<BR>The Dense curves show the performance of a null step when the worker fetches the entire model. We repeat the experiment with models of size 100 MB and 1 GB, with the parameters sharded equally over 16 PS tasks. The me- dian step time for 100 MB increases from 147 ms with one worker to 613 ms with 100 workers. For 1 GB, it increases from 1.01 s with one worker to 7.16 s with 100 workers.<BR>For large models, a typical training step accesses only a subset of the parameters, and the Sparse curves show the throughput of the embedding lookup operation from Subsection 4.2. Each worker reads 32 randomly selected entries from a large embedding matrix containing 1 GB or 16 GB of data. As expected, the step times do not vary with the size of the embedding, and TensorFlow achieves step times ranging from 5 to 20 ms.<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (a) Baseline performance vs. MXNet<BR>30<BR>25<BR>20<BR>15<BR>10<BR>5</P>
<P>3000<BR>2500<BR>2000<BR>1500<BR>1000<BR>500<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (b) Coordination scalability</P>
<P>2.5<BR>2.4<BR>2.3<BR>2.2<BR>2.1<BR>2.0<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (c) Backup worker effectiveness</P>
<P><BR>1.10</P>
<P>1.08</P>
<P>1.06</P>
<P>1.04</P>
<P>1.02<BR>0<BR>1 4 8&nbsp;16&nbsp;32&nbsp;50<BR>Number of workers<BR>0<BR>25&nbsp; 50&nbsp;100&nbsp;200<BR>Number of workers<BR>1.9</P>
<P><BR>0&nbsp;1&nbsp;2&nbsp;3&nbsp;4&nbsp;5<BR>Number of backup workers<BR>1.00</P>
<P>Figure 8: Results of the performance evaluation for Inception-v3 training (&#167;6.3). (a) TensorFlow achieves slightly better throughput than MXNet for asynchronous training. (b) Asynchronous and synchronous training throughput increases with up to 200 workers. (c) Adding backup workers to a 50-worker training job can reduce the overall step time, and improve performance even when normalized for resource consumption.</P>
<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 6.3 Image classification<BR>Deep neural networks have achieved breakthrough perfor- mance on computer vision tasks such as recognizing ob- jects in photographs [44], and these tasks are a key ap- plication for TensorFlow at Google. Training a network to high accuracy requires a large amount of computa- tion, and we use TensorFlow to scale out this computation across a cluster of GPU-enabled servers. In these experi- ments, we focus on Google&#8217;s Inception-v3 model, which achieves 78.8% accuracy in the ILSVRC 2012 image clas- sification challenge [69]; the same techniques apply to other deep convolutional models&#8212;such as ResNet [28]&#8212; implemented on TensorFlow. We investigate the scalabil- ity of training Inception-v3 using multiple replicas. We configure TensorFlow with 7 PS tasks, and vary the num- ber of worker tasks using two different clusters.<BR>For the first experiment, we compare the performance training Inception using asynchronous SGD on Tensor- Flow and MXNet, a contemporary system using a pa- rameter server architecture. For this experiment we use Google Compute Engine virtual machines running on In- tel Xeon E5 servers with NVIDIA K80 GPUs, config- ured with 8 vCPUs, 16Gbps of network bandwidth, and one GPU per VM. Both systems use 7 PS tasks running on separate VMs with no GPU. Figure 8(a) shows that TensorFlow achieves performance that is marginally bet- ter than MXNet. As expected, the results are largely de- termined by single-GPU performance, and both systems use cuDNN version 5.1, so they have access to the same optimized GPU kernels.<BR>Using a larger internal cluster (with NVIDIA K40 GPUs, and a shared datacenter network), we investigate the effect of coordination (&#167;4.4) on training performance. Ideally, with efficient synchronous training, a model such<BR>as Inception-v3 will train in fewer steps, and converge to a higher accuracy than with asynchronous training [10]. Training throughput improves to 2,300 images per sec- ond as we increase the number of workers to 200, but with diminishing returns (Figure 8(b)). As we add more workers, the step time increases, because there is more contention on the PS tasks, both at the network interface and in the aggregation of updates. As expected, for all configurations, synchronous steps are longer than asyn- chronous steps, because all workers must wait for the slowest worker to catch up before starting the next step. While the median synchronous step is approximately 10% longer than an asynchronous step with the same workers, above the 90th percentile the synchronous performance degrades sharply, because stragglers disproportionately impact tail latency.<BR>To mitigate tail latency, we add backup workers so that a step completes when the first m of n tasks produce gra- dients. Figure 8(c) shows the effect of adding backup workers to a 50-worker Inception training job. Each addi- tional backup worker up to and including the fourth re- duces the median step time, because the probability of a straggler affecting the step decreases. Adding a fifth backup worker slightly degrades performance, because the 51st worker (i.e., the first whose result is discarded) is more likely to be a non-straggler that generates more incoming traffic for the PS tasks. Figure 8(c) also plots the normalized speedup for each configuration, defined as t(b)/t(0) &#215; 50/(50 + b) (where t(b) is the median step time with b backup workers), and which discounts the speedup by the fraction of additional resources consumed. Although adding 4 backup workers achieves the shortest overall step time (1.93 s), adding 3 achieves the highest normalized speedup (9.5%), and hence uses less aggre- gate GPU-time to reach the same quality.</P>
<P><BR>105</P>
<P>104</P>
<P>103</P>
<P>102</P>
<P>101</P>
<P>&nbsp;&nbsp;&nbsp; (a) Full softmax</P>
<P>1&nbsp;2&nbsp;4&nbsp;8&nbsp;16&nbsp; 32<BR>Number of PS tasks</P>
<P><BR>105</P>
<P>104</P>
<P>103</P>
<P>102</P>
<P>101</P>
<P>&nbsp;&nbsp;&nbsp; (b) Sampled softmax</P>
<P>1&nbsp;2&nbsp;4&nbsp;8&nbsp;16&nbsp; 32<BR>Number of PS tasks<BR>&nbsp;&nbsp;&nbsp; 7 Conclusions<BR>We have described the TensorFlow system and its pro- gramming model. TensorFlow&#8217;s dataflow representation subsumes existing work on parameter server systems, and offers a set of uniform abstractions that allow users to harness large-scale heterogeneous systems, both for pro- duction tasks and for experimenting with new approaches. We have shown several examples of how the TensorFlow programming model facilitates experimentation (&#167;4) and demonstrated that the resulting implementations are per-<BR>Figure 9: Increasing the number of PS tasks leads to in-<BR>creased throughput for language model training, by par- allelizing the softmax computation. Sampled softmax in- creases throughput by performing less computation.</P>
<P>6.4&nbsp;Language modeling<BR>Given a sequence of words, a language model predicts the most probable next word [6]. Therefore, language mod- els are integral to predictive text, speech recognition, and translation applications. In this experiment, we investi- gate how TensorFlow can train a recurrent neural network (viz. LSTM-512-512 [41]) to model the text in the One Billion Word Benchmark [9]. The vocabulary size |V | limits the performance of training, because the final layer must decode the output state into probabilities for each of<BR>|V | classes [37]. The resulting parameters can be large (|V | &#215; d for output state dimension d) so we use the tech- niques for handling large models from Subsection 4.2. We<BR>use a restricted vocabulary of the most common 40,000 words&#8212;instead of the full 800,000 words [9]&#8212;in order to experiment with smaller configurations.<BR>Figure 9 shows the training throughput, measured in words per second, for varying numbers of PS and worker tasks, and two softmax implementations. The full softmax (Figure 9(a)) multiplies each output by a 512 &#215; 40,000 weight matrix sharded across the PS tasks. Adding more PS tasks increases the throughput, because TensorFlow can exploit distributed model parallelism [20, 43] and per- form the multiplication and gradient calculation on the PS tasks, as in Project Adam [14]. Adding a second PS task is more effective than increasing from 4 to 32, or 32 to 256 workers. Eventually the throughput saturates, as the LSTM calculations dominate the training step.<BR>The sampled softmax (Figure 9(b)) reduces the data transferred and the computation performed on the PS tasks [37]. Instead of a dense weight matrix, it multiplies the output by a random sparse matrix containing weights for the true class and a random sample of false classes. We sample 512 classes for each batch, thus reducing the softmax data transfer and computation by a factor of 78.<BR>formant and scalable (&#167;6).<BR>Our initial experience with TensorFlow is encourag- ing. A large number of groups at Google have deployed TensorFlow in production, and TensorFlow is helping our research colleagues to make new advances in machine learning. Since we released TensorFlow as open-source software, more than 14,000 people have forked the source code repository, the binary distribution has been down- loaded over one million times, and dozens of machine learning models that use TensorFlow have been published. TensorFlow is a work in progress. Its flexible dataflow representation enables power users to achieve excellent performance, but we have not yet determined default policies that work well for all users. Further research on automatic optimization should bridge this gap. On the system level, we are actively developing algorithms for automatic placement, kernel fusion, memory manage- ment, and scheduling. While the current implementations of mutable state and fault tolerance suffice for applica- tions with weak consistency requirements, we expect that some TensorFlow applications will require stronger con- sistency, and we are investigating how to build such poli- cies at user-level. Finally, some users have begun to chafe at the limitations of a static dataflow graph, especially for algorithms like deep reinforcement learning [54]. There- fore, we face the intriguing problem of providing a sys- tem that transparently and efficiently uses distributed re- sources, even when the structure of the computation un-<BR>folds dynamically.</P>
<P>Acknowledgments<BR>We gratefully acknowledge contributions from our col- leagues within Google, and from members of the wider machine learning community. In particular, we appreci- ate the feedback we have received from the rest of the Google Brain team and the many users of DistBelief and TensorFlow. We thank the anonymous OSDI reviewers and our shepherd KyoungSoo Park for their suggestions, which greatly improved the presentation of this paper.