<P class="CDt4Ke zfr3Q" style='BOX-SIZING: border-box; FONT-SIZE: 11pt; TEXT-DECORATION: ; FONT-FAMILY: "Open Sans"; POSITION: relative; COLOR: rgb(33,33,33); OUTLINE-WIDTH: medium; OUTLINE-STYLE: none; MARGIN: 15px 0px 0px; OUTLINE-COLOR: invert; LINE-HEIGHT: 1.6; font-variant-ligatures: none' dir=ltr>By giving up on total consistency I mean a distributed design (on a par with the distributed work-stealing Cilk-like scheduler). That is, each thread has it's own CPQ, a thread enqueues and dequeues elements from the own queue, and if it is empty he tries to steal a high priority element (or a batch of elements) from another thread. Such design is naturally distributed (=scalable). However, of course, threads will work on not the globally highest priority elements. As to whether it is a problem for a particuar system or not depends.</P>
<P class="CDt4Ke zfr3Q" style='BOX-SIZING: border-box; FONT-SIZE: 11pt; TEXT-DECORATION: ; FONT-FAMILY: "Open Sans"; POSITION: relative; COLOR: rgb(33,33,33); OUTLINE-WIDTH: medium; OUTLINE-STYLE: none; MARGIN: 15px 0px 0px; OUTLINE-COLOR: invert; LINE-HEIGHT: 1.6; font-variant-ligatures: none' dir=ltr>By specialized CPQ design I mean the following. A lot of systems are Ok with only, say, 5 or even 3 priorities - low, normal, high. So, you can just setup 3 concurrent queues - one for each priority level, and threads will poll the queues starting from high prio queue to low prio queue (checking few empty high prio queues is not a big deal performance-wise). Such design allows a lot of flexibility. For example, if you have single-producer/single-consumer (SPSC) scenario you can setup SPSC queues (which are a way faster and more scalable that general MPMC queues) (similarly for multi-producer/single-consumer and single-producer/multi-consumer scenarios). Or you can use array-based queues, or linked-list based queues, or whatever queues are the most suitable for you in a particular situation.