<b> : </b><A name=Conclusion></A><SPAN style="LETTER-SPACING: -0.1pt">Conclusion</SPAN></H1></LI></OL>
<P class=western style="MARGIN-TOP: 0.1in; MARGIN-LEFT: 0.22in; LINE-HEIGHT: 98%; MARGIN-RIGHT: 0.56in" align=justify>In this paper, we introduce scalable version-aware data placement as an efficient approach for accelerating version searching in in-memory MVCC databases. We pre- sented a suite of techniques to reduce the cost and maintenance overheads of version timestamp partitioning-based data placement techniques and to alleviate memory allocation contention, avoid transaction abort, and eliminate write amplification. Scal- able<SPAN style="LETTER-SPACING: -0.4pt"> </SPAN>version-aware<SPAN style="LETTER-SPACING: -0.4pt"> </SPAN>data<SPAN style="LETTER-SPACING: -0.4pt"> </SPAN>placement<SPAN style="LETTER-SPACING: -0.4pt"> </SPAN>works<SPAN style="LETTER-SPACING: -0.4pt"> </SPAN>well<SPAN style="LETTER-SPACING: -0.4pt"> </SPAN>for<SPAN style="LETTER-SPACING: -0.4pt"> </SPAN>transactional<SPAN style="LETTER-SPACING: -0.4pt"> </SPAN>workloads<SPAN style="LETTER-SPACING: -0.4pt"> </SPAN>since<SPAN style="LETTER-SPACING: -0.4pt"> </SPAN>tables&#8217; current tuple versions are partitioned into leaf nodes, allowing index-only visibility check and data access. It is particularly beneficial for heterogeneous workloads since long chains of versions exist due to the mix of short-lived update transactions and<SPAN style="LETTER-SPACING: 2pt"> </SPAN>long-running queries. Both range partitioning and epoch partitioning improve the query latency. We integrated our design into the existing in-memory MVCC engine<SPAN style="LETTER-SPACING: 4pt"> </SPAN>and showed that the system with scalable version-aware data placement improved its throughput performance.