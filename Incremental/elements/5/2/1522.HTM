<b> : </b><A name="Epoch Partitioning"></A><FONT face="Georgia, serif">Epoch</FONT><FONT face="Georgia, serif"><SPAN style="LETTER-SPACING: 1.4pt"> </SPAN></FONT><FONT face="Georgia, serif"><SPAN style="LETTER-SPACING: -0.1pt">Partitioning</SPAN></FONT></H3></LI></OL></OL></OL>
<P class=western style="MARGIN-TOP: 0.09in; MARGIN-LEFT: 0.56in; LINE-HEIGHT: 98%; MARGIN-RIGHT: 0.22in" align=justify>The second scheme is epoch-based partitioning, where tuple versions are assigned to the<SPAN style="LETTER-SPACING: -0.6pt"> </SPAN>current<SPAN style="LETTER-SPACING: -0.6pt"> </SPAN>epoch<SPAN style="LETTER-SPACING: -0.6pt"> </SPAN>memory<SPAN style="LETTER-SPACING: -0.6pt"> </SPAN>management.<SPAN style="LETTER-SPACING: -0.6pt"> </SPAN>In<SPAN style="LETTER-SPACING: -0.6pt"> </SPAN>an<SPAN style="LETTER-SPACING: -0.6pt"> </SPAN>epoch-based<SPAN style="LETTER-SPACING: -0.6pt"> </SPAN>system,<SPAN style="LETTER-SPACING: -0.6pt"> </SPAN>when<SPAN style="LETTER-SPACING: -0.6pt"> </SPAN>a<SPAN style="LETTER-SPACING: -0.6pt"> </SPAN>transaction starts, it registers itself in the current epoch by entering the epoch. When the trans- action finishes, it adds committed tuple versions and version timestamp information<SPAN style="LETTER-SPACING: 2pt"> </SPAN>to the access-friendly data structures.</P>
<P class=western style="MARGIN-TOP: 0in; MARGIN-LEFT: 0.56in; LINE-HEIGHT: 98%; MARGIN-RIGHT: 0.22in; TEXT-INDENT: 0.21in" align=justify>As shown in Figure <A href="file:///C:/SuperMemo/systems/Incremental/temp/HTMLFile.htm#_bookmark9"><FONT color=#0000ff>9</FONT></A>, it implements the data structure as a hash table. Each entry<SPAN style="LETTER-SPACING: 2pt"> </SPAN>in<SPAN style="LETTER-SPACING: -0.1pt"> </SPAN>the<SPAN style="LETTER-SPACING: -0.1pt"> </SPAN>hash<SPAN style="LETTER-SPACING: -0.1pt"> </SPAN>table<SPAN style="LETTER-SPACING: -0.1pt"> </SPAN>includes<SPAN style="LETTER-SPACING: -0.1pt"> </SPAN>the<SPAN style="LETTER-SPACING: -0.1pt"> </SPAN>tuple<SPAN style="LETTER-SPACING: -0.1pt"> </SPAN>identifier<SPAN style="LETTER-SPACING: -0.1pt"> </SPAN>(key=10),<SPAN style="LETTER-SPACING: -0.1pt"> </SPAN>the<SPAN style="LETTER-SPACING: -0.1pt"> </SPAN>version<SPAN style="LETTER-SPACING: -0.1pt"> </SPAN>timestamps<SPAN style="LETTER-SPACING: -0.1pt"> </SPAN>(V(130, 140)),<SPAN style="LETTER-SPACING: -0.4pt"> </SPAN>the<SPAN style="LETTER-SPACING: -0.4pt"> </SPAN>version<SPAN style="LETTER-SPACING: -0.4pt"> </SPAN>data<SPAN style="LETTER-SPACING: -0.4pt"> </SPAN>(10,<SPAN style="LETTER-SPACING: -0.4pt"> </SPAN>115),<SPAN style="LETTER-SPACING: -0.4pt"> </SPAN>and<SPAN style="LETTER-SPACING: -0.4pt"> </SPAN>the<SPAN style="LETTER-SPACING: -0.4pt"> </SPAN>next<SPAN style="LETTER-SPACING: -0.4pt"> </SPAN>pointer,<SPAN style="LETTER-SPACING: -0.4pt"> </SPAN>where<SPAN style="LETTER-SPACING: -0.4pt"> </SPAN>the<SPAN style="LETTER-SPACING: -0.4pt"> </SPAN>next<SPAN style="LETTER-SPACING: -0.4pt"> </SPAN>pointer<SPAN style="LETTER-SPACING: -0.4pt"> </SPAN>points<SPAN style="LETTER-SPACING: -0.4pt"> </SPAN>to the older version in the list if it exists or a null pointer to mark list termination. When<SPAN style="LETTER-SPACING: 4pt"> </SPAN>a background thread advances the global epoch, a new epoch partition is created, and the following committed tuple versions are partitioned into this new partition. The default epoch threshold in our implementation is 100 ms.</P>
<P class=western style="MARGIN-TOP: 0in; MARGIN-LEFT: 0.56in; LINE-HEIGHT: 98%; MARGIN-RIGHT: 0.22in; TEXT-INDENT: 0.21in" align=justify>Each tuple holds a queue to track the epoch partitions generated by transactions. When a transaction commits a new tuple version of a tuple, it appends the current epoch to the tuple&#8217;s epoch partition queue. The subsequent transactions would read this tuple-local epoch queue to determine the visible maximum epoch partition. This partitioning enables version traversal at the epoch level instead of the version level.</P>
<OL>
<OL start=3>
<LI>