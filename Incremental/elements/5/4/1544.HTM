Abstract&#8212;The Raft consensus protocol naturally fits time series databases, owing to the resemblance between its continuous log and the time series data. While the serialization of appending en- tries reduces the state space for ease design and implementation, it blocks the subsequent requests and thus limits the parallelism and throughput of Raft. Intuitively, once an entry arrives the follower, we may notice the leader and the client to unblock the subsequent as early, rather than waiting for its appending and committing. In this way, more requests can be processed in parallel, and thus the throughput increases, essential for IoT applications often with&nbsp; vast&nbsp; sensors&nbsp; and&nbsp; fast&nbsp; data&nbsp; ingestion. Of course, with higher parallelism, the risk of persistence for in-processing entries increases. It is a worthwhile trade-off in the IoT scenario since tiny data loss&nbsp; during&nbsp; leader&nbsp; failure&nbsp; is more acceptable than shutting out most data due to a low throughput. Our Non-Blocking Raft (NB-Raft) is implemented as the consensus protocol of Apache IoTDB, a commodity time series database management system, supporting various applications in Alibaba Cloud. Extensive evaluation shows that the throughput is improved by about 30% using our NB-Raft compared to the original Raft, a considerable amount of further data saved.<BR>Index Terms&#8212;distributed system, IoT, consensus protocol</P>
<P>&nbsp;&nbsp;&nbsp; I. INTRODUCTION</P>
<P>Consensus protocols are essential in efficiently keeping replicas consistent in distributed systems. While there are alternatives, such as the Paxos family [1], [2], [3], [4], [5], [6], [7], we choose to employ Raft [8] for Apache IoTDB [9], a time series database for Internet of Things (IoT). The reason is that Raft models data as a continuous log without holes. It makes the state space smaller than other protocols, and thus easier to understand and maintain. Most importantly, the continuous log naturally resembles time series, where each log entry with a monotonically increasing index corresponds to a series point ordered by timestamp.<BR>Unfortunately, the log serialization scheme of Raft limits its parallelism and consequently the throughput (see the mo- tivation example below). A typical IoT application manages thousands of devices, samples millions of time series, and generates tens of GBs data every second [9], [10]. Directly applying Raft to IoT scenarios pushes the protocol throughput to its limits, and thus potentially shut out data from the system.</P>
<P>Shaoxu Song (<A href="https://sxsong.github.io/">https://sxsong.github.io/</A>) is the corresponding author.</P>
<P>&nbsp;</P>
<P><BR>Fig. 1. Raft in (a) blocks the subsequent entry E3 till the commit of the preceding E2 from the same client, while our NB-Raft in (b) introduces an early return to unblock E3 as soon as possible and thus increases throughput.</P>
<P><BR>&nbsp;&nbsp;&nbsp; A. Motivation<BR>Raft introduces serialization by assigning two unique and monotonically increasing numbers, log index and term, to each command. Followers must append and apply commands in the order of index. A term identifies uniquely the generator of a log entry. Figure 1(a) briefly shows the process of replicating entries from the leader to a follower. The leader first indexes a request as a log entry, e.g., E1, and sends it to the follower. Then, the follower appends the entry locally. After that, the leader commits the entry (assuming only one follower).<BR>When an entry reaches the follower, some previous entries may still be appending or even not received yet. It thus cannot be appended and must wait till the previous entry is appended. For example, there is a long gap between &#8220;Receive E2&#8221; and &#8220;Append E2&#8221; in Figure 1(a), waiting for &#8220;Append E1&#8221;. As a client connection can issue only one request a time, the subsequent requests are also blocked. For instance, E3 in Figure 1(a) cannot be issued until the previous E2 from the same client is committed.<BR>In short, owing to the serialization scheme of Raft log, the requests of a client are blocked and cannot be processed in