<B>: </B>Background 
<H1></H1>
<P style="TEXT-ALIGN: left">There is memory and there is disk (these days it is SSD, back in the old days it was a rotating hard disk). Memory is fast, but not persistent. Disk is durable, but slow.<BR><BR>We want both fast and durable.<BR><BR>We might execute and commit a transaction in-memory to achieve fast execution, but a committed transaction should also be durable. Flushing each transaction to the disk would add long I/O stalls before each commit. So it looks like we are caught between a rock and a hard place.<BR><BR>What is the solution?<SPAN>&nbsp;</SPAN><B style="FONT-WEIGHT: bold">WAL: Write Ahead Log</B><BR><BR><FONT class=extract>WAL is somewhat similar to the sticky notes and photos in<SPAN>&nbsp;</SPAN>the movie Memento; it helps recover the current state after working memory is wiped.</FONT><BR><BR><FONT class=extract>We may force each WAL update (record of which operation we execute) to the disk, for durability. This is smaller than forcing the entire state or physical block to the disk. But flushing every WAL update (or at least WAL updates for a transaction before commit) adds stall. Can we do better? What is the most performant (avoiding I/O stalls) way that we can still achieve durability?<BR><BR>ARIES gets us there. It doesn't leave anything on the table.</FONT><BR><BR>Here is some additional setup before we can appreciate how this is done.<BR><BR>There is the WAL keeping logical record of operations and there is the buffer pool keeping pages/blocks (physical effects).<BR></P>
<TABLE class=tr-caption-container style="BORDER-COLLAPSE: collapse; MARGIN-LEFT: auto; BORDER-SPACING: 0px; MARGIN-RIGHT: auto" cellSpacing=0 cellPadding=0 align=center>
<TBODY>
<TR>
<TD style="PADDING-BOTTOM: 0px; TEXT-ALIGN: center; PADDING-TOP: 0px; PADDING-LEFT: 0px; PADDING-RIGHT: 0px"><A style="TEXT-DECORATION: none; BACKGROUND: none transparent scroll repeat 0% 0%; COLOR: rgb(33,150,243); MARGIN-LEFT: auto; MARGIN-RIGHT: auto" href="https://blogger.googleusercontent.com/img/a/AVvXsEjpeHbH-zRm26xhtPsaH3jYT--NkbPa7lpLWfrWeRBJtFfYqGyx8o7cdy5KoCOfLmb9x5Y1eFErmfcNVFY2-fbR9KN1FAPV2gSuIG4_e3uR8ZKl5tpZepsFtqAMz_b9ZsoOGto0BDmutZuta7PHSHRHOJCqM11O_zIVDCaDQRE-swAJdUFptStW8Zsd"><IMG style="MAX-WIDTH: 100%; BORDER-TOP: 0px; BORDER-RIGHT: 0px; BORDER-BOTTOM: 0px; BORDER-LEFT: 0px" alt="" src="https://blogger.googleusercontent.com/img/a/AVvXsEjpeHbH-zRm26xhtPsaH3jYT--NkbPa7lpLWfrWeRBJtFfYqGyx8o7cdy5KoCOfLmb9x5Y1eFErmfcNVFY2-fbR9KN1FAPV2gSuIG4_e3uR8ZKl5tpZepsFtqAMz_b9ZsoOGto0BDmutZuta7PHSHRHOJCqM11O_zIVDCaDQRE-swAJdUFptStW8Zsd=w640-h302" width=640 height=302 data-original-height="1520" data-original-width="3224"></A></TD></TR>
<TR>
<TD class=tr-caption style="PADDING-BOTTOM: 0px; TEXT-ALIGN: center; PADDING-TOP: 0px; PADDING-LEFT: 0px; PADDING-RIGHT: 0px">(from<SPAN>&nbsp;</SPAN><A style="TEXT-DECORATION: none; BACKGROUND: none transparent scroll repeat 0% 0%; COLOR: rgb(33,150,243)" href="https://www.youtube.com/watch?v=4VGkRXVM5fk">Andy Pavlo's lecture on ARIES</A>)</TD></TR></TBODY></TABLE><BR><BR><FONT class=extract>The most performant approach to flushing WAL writes we can get is with<SPAN>&nbsp;</SPAN><B style="FONT-WEIGHT: bold">Steal</B><SPAN>&nbsp;</SPAN>and<SPAN>&nbsp;</SPAN><B style="FONT-WEIGHT: bold">No-Force</B><SPAN>&nbsp;</SPAN>policy.<BR></FONT>
<P></P>
<UL style="TEXT-ALIGN: left">
<LI><FONT class=extract>Steal says: A transaction can steal pages from the buffer to do work. This allows Transaction C's dirty pages to be written to disk before it completes so that there's room for Transaction B to do work. </FONT>
<LI><FONT class=extract>No-Force says: Dirty pages for finished transactions can be flushed to disk whenever convenient. They don't have to flush to disk before we can commit the transaction.</FONT></LI></UL>
<P style="TEXT-ALIGN: left"><BR><FONT class=extract>We want our WAL and recovery protocols to support a Steal and No-Force policy for the buffer pool, in order not to throttle the performance while we ensure durability. Given the Steal and No-Force constraints, ARIES goes the extra mile: It tries to get the WAL flushing to be almost async, to avoid any stalls from the WAL flushing as well. Of course for correctness, there needs to be&nbsp; tiny bit of dependency/synchronization in flushing of the WAL. We will discuss this next under Principle 1.</FONT>