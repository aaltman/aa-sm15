<DIV id=post-body-9010836299109988905 class="post-body entry-content float-container" style="COLOR: rgb(117,117,117); FONT: 17px/1.6em Roboto, sans-serif; MARGIN: 1.5em 0px 2em; DISPLAY: block">
<H1 style="FONT-SIZE: 2em; TEXT-ALIGN: left; MARGIN: 0.67em 0px"><FONT class=extract>Background</FONT></H1>
<P style="TEXT-ALIGN: left"><FONT class=extract>There is memory and there is disk (these days it is SSD, back in the old days it was a rotating hard disk). Memory is fast, but not persistent. Disk is durable, but slow.<BR><BR>We want both fast and durable.<BR><BR>We might execute and commit a transaction in-memory to achieve fast execution, but a committed transaction should also be durable. Flushing each transaction to the disk would add long I/O stalls before each commit. So it looks like we are caught between a rock and a hard place.<BR><BR>What is the solution?<SPAN>&nbsp;</SPAN><B style="FONT-WEIGHT: bold">WAL: Write Ahead Log</B><BR><BR>WAL is somewhat similar to the sticky notes and photos in<SPAN>&nbsp;</SPAN></FONT><A style="TEXT-DECORATION: none; BACKGROUND: none transparent scroll repeat 0% 0%; COLOR: rgb(33,150,243)" href="https://en.wikipedia.org/wiki/Memento_(film)"><FONT class=extract>the movie Memento (2000)</FONT></A><FONT class=extract>; it helps recover the current state after working memory is wiped.<BR><BR>We may force each WAL update (record of which operation we execute) to the disk, for durability. This is smaller than forcing the entire state or physical block to the disk. But flushing every WAL update (or at least WAL updates for a transaction before commit) adds stall. Can we do better? What is the most performant (avoiding I/O stalls) way that we can still achieve durability?<BR><BR>ARIES gets us there. It doesn't leave anything on the table.<BR><BR>Here is some additional setup before we can appreciate how this is done.<BR><BR>There is the WAL keeping logical record of operations and there is the buffer pool keeping pages/blocks (physical effects).<BR></FONT></P>
<TABLE class=tr-caption-container style="BORDER-COLLAPSE: collapse; MARGIN-LEFT: auto; BORDER-SPACING: 0px; MARGIN-RIGHT: auto" cellSpacing=0 cellPadding=0 align=center>
<TBODY>
<TR>
<TD style="PADDING-BOTTOM: 0px; TEXT-ALIGN: center; PADDING-TOP: 0px; PADDING-LEFT: 0px; PADDING-RIGHT: 0px"><A style="TEXT-DECORATION: none; BACKGROUND: none transparent scroll repeat 0% 0%; COLOR: rgb(33,150,243); MARGIN-LEFT: auto; MARGIN-RIGHT: auto" href="https://blogger.googleusercontent.com/img/a/AVvXsEjpeHbH-zRm26xhtPsaH3jYT--NkbPa7lpLWfrWeRBJtFfYqGyx8o7cdy5KoCOfLmb9x5Y1eFErmfcNVFY2-fbR9KN1FAPV2gSuIG4_e3uR8ZKl5tpZepsFtqAMz_b9ZsoOGto0BDmutZuta7PHSHRHOJCqM11O_zIVDCaDQRE-swAJdUFptStW8Zsd"><FONT class=extract><IMG style="MAX-WIDTH: 100%; BORDER-TOP: 0px; BORDER-RIGHT: 0px; BORDER-BOTTOM: 0px; BORDER-LEFT: 0px" alt="" src="https://blogger.googleusercontent.com/img/a/AVvXsEjpeHbH-zRm26xhtPsaH3jYT--NkbPa7lpLWfrWeRBJtFfYqGyx8o7cdy5KoCOfLmb9x5Y1eFErmfcNVFY2-fbR9KN1FAPV2gSuIG4_e3uR8ZKl5tpZepsFtqAMz_b9ZsoOGto0BDmutZuta7PHSHRHOJCqM11O_zIVDCaDQRE-swAJdUFptStW8Zsd=w640-h302" width=640 height=302 data-original-height="1520" data-original-width="3224"></FONT></A></TD></TR>
<TR>
<TD class=tr-caption style="PADDING-BOTTOM: 0px; TEXT-ALIGN: center; PADDING-TOP: 0px; PADDING-LEFT: 0px; PADDING-RIGHT: 0px"><FONT class=extract>(from<SPAN>&nbsp;</SPAN></FONT><A style="TEXT-DECORATION: none; BACKGROUND: none transparent scroll repeat 0% 0%; COLOR: rgb(33,150,243)" href="https://www.youtube.com/watch?v=4VGkRXVM5fk"><FONT class=extract>Andy Pavlo's lecture on ARIES</FONT></A><FONT class=extract>)</FONT></TD></TR></TBODY></TABLE><BR><BR><FONT class=extract>The most performant we can get is with<SPAN>&nbsp;</SPAN><B style="FONT-WEIGHT: bold">Steal</B><SPAN>&nbsp;</SPAN>and<SPAN>&nbsp;</SPAN><B style="FONT-WEIGHT: bold">No-Force</B><SPAN>&nbsp;</SPAN>policy.<BR></FONT>
<P></P>
<UL style="TEXT-ALIGN: left">
<LI><FONT class=extract>Steal says: A transaction can steal pages from the buffer to do work. This allows Transaction C's dirty pages to be written to disk before it completes so that there's room for Transaction B to do work. </FONT>
<LI><FONT class=extract>No-Force says: Dirty pages for finished transactions can be flushed to disk whenever convenient. They don't have to flush to disk before we can commit the transaction.</FONT></LI></UL>
<P style="TEXT-ALIGN: left"><BR><FONT class=extract>We want our WAL and recovery protocols to support a Steal and No-Force policy for the buffer pool, in order not to throttle the performance while we ensure durability. Given the Steal and No-Force constraints, ARIES goes the extra mile: It tries to get the WAL flushing to be almost async, to avoid any stalls from the WAL flushing as well. Of course for correctness, there needs to be&nbsp; tiny bit of dependency/synchronization in flushing of the WAL. We will discuss this next under Principle 1.<BR><BR></FONT></P>
<H1 style="FONT-SIZE: 2em; TEXT-ALIGN: left; MARGIN: 0.67em 0px"><FONT class=extract>The principles<BR></FONT></H1>
<P style="TEXT-ALIGN: left"><FONT class=extract><B style="FONT-WEIGHT: bold">Principle 1.</B><SPAN>&nbsp;</SPAN>Write-ahead logging: Any change to an object is first recorded in the log, and the log must be written to the stable storage *before changes to the object are written to disk.*<BR><BR>Note that, this doesn't mean that WAL records need to be flushed immediately. This actually gives us a lot of flexibility, and allow us to flush WAL records in batches and asynchronously most of the time. The only exception is when the buffer pool is writing a dirty page back to disk whose WAL is not flushed already. That is the only case where we need to do the WAL flushing before we can write the page back to the disk.<BR><BR>This was the most important principle. I will not go through to the full protocol. I will mention the other two basic principles, and refer you to two good resources on this.<BR><BR><B style="FONT-WEIGHT: bold">Principle 2.</B><SPAN>&nbsp;</SPAN>Repeating history during Redo: On restart after a crash, ARIES retraces the actions of a database before the crash and brings the system back to the exact state that it was in before the crash. Then it undoes the transactions that were still active at crash time, because these transactions did not get to commit and need to be rollback. &nbsp;<BR><BR><B style="FONT-WEIGHT: bold">Principle 3.</B><SPAN>&nbsp;</SPAN>Logging changes during Undo: Changes made to the database while undoing transactions are logged to ensure such an action isn't repeated in the event of repeated restarts.<BR><BR></FONT><A style="TEXT-DECORATION: none; BACKGROUND: none transparent scroll repeat 0% 0%; COLOR: rgb(33,150,243)" href="https://www.youtube.com/watch?v=4VGkRXVM5fk"><FONT class=extract>Andy Pavlo's lecture explains ARIES really well.</FONT></A><FONT class=extract><SPAN>&nbsp;</SPAN>Watching this is time very well spent.&nbsp;<BR><BR></FONT><A style="TEXT-DECORATION: none; BACKGROUND: none transparent scroll repeat 0% 0%; COLOR: rgb(33,150,243)" href="https://en.m.wikipedia.org/wiki/Algorithms_for_Recovery_and_Isolation_Exploiting_Semantics"><FONT class=extract>This wikipedia page</FONT></A><FONT class=extract><SPAN>&nbsp;</SPAN>provides a succinct summary of ARIES.<BR><BR></FONT><A style="TEXT-DECORATION: none; BACKGROUND: none transparent scroll repeat 0% 0%; COLOR: rgb(33,150,243)" href="https://www.shreya-shankar.com/aries/"><FONT class=extract>This blog post from Shreya</FONT></A><FONT class=extract><SPAN>&nbsp;</SPAN>explains things in a very accessible way.<BR><BR></FONT><A style="TEXT-DECORATION: none; BACKGROUND: none transparent scroll repeat 0% 0%; COLOR: rgb(33,150,243)" href="https://twitter.com/PatHelland/status/1642346268138799106"><FONT class=extract>My dear friend Pat Helland mentions that</FONT></A><FONT class=extract><SPAN>&nbsp;</SPAN>at Tandem Franco Putzolu implemented&nbsp; ARIES style WAL-based performant transactional recovery in the 1980s (outlined in the crash recovery section of<SPAN>&nbsp;</SPAN></FONT><A style="TEXT-DECORATION: none; BACKGROUND: none transparent scroll repeat 0% 0%; COLOR: rgb(33,150,243)" href="https://www.vldb.org/conf/1984/P445.PDF"><FONT class=extract>this VLDB 1984 paper</FONT></A><FONT class=extract>), but they had not published about it. The thread is a good read.<BR><BR>MySQL's implementation of ARIES principles is discussed<SPAN>&nbsp;</SPAN></FONT><A style="TEXT-DECORATION: none; BACKGROUND: none transparent scroll repeat 0% 0%; COLOR: rgb(33,150,243)" href="https://twitter.com/quangtung2912/status/1643776112034734080"><FONT class=extract>in this thread</FONT></A><FONT class=extract>.<BR><BR></FONT></P>
<H1 style="FONT-SIZE: 2em; TEXT-ALIGN: left; MARGIN: 0.67em 0px"><FONT class=extract>Formal modeling of ARIES</FONT></H1>
<P style="TEXT-ALIGN: left"><FONT class=extract>After we understand the principles/invariants, ARIES is not a complicated protocol. But, database recovery is a tricky business, and unavoidably the ARIES protocol has a lot of details. It is easy to get things wrong in the implementation, and it is hard to test that our implementation does recovery correctly. There are several reasons for why this is the case. The recovery code doesn't get exercised frequently (hopefully your database doesn't crash all the time). The state space for recovery is huge, so it is hard to model check things. Verification approaches need to consider timing of the crash, and ensure recovery from any ill-timed crash. This is a hard problem and only recently we started seeing verification work address this.<BR><BR>There are also bugs at the seams between different layers.<SPAN>&nbsp;</SPAN></FONT><A style="TEXT-DECORATION: none; BACKGROUND: none transparent scroll repeat 0% 0%; COLOR: rgb(33,150,243)" href="https://www.usenix.org/conference/fast18/presentation/alagappan"><FONT class=extract>A FAST'18 paper</FONT></A><FONT class=extract><SPAN>&nbsp;</SPAN>shows that many bugs still existed in recovery for consensus-based storage. What about lower layer implementation? Are you sure<SPAN>&nbsp;</SPAN></FONT><A style="TEXT-DECORATION: none; BACKGROUND: none transparent scroll repeat 0% 0%; COLOR: rgb(33,150,243)" href="https://twitter.com/AlexMillerDB/status/1635315294158594048"><FONT class=extract>fsync is flushing correctly</FONT></A><FONT class=extract>?<BR><BR><BR>Anyways. I am getting ahead of myself. I would just be happy to have with a TLA+ model of ARIES recovery protocol. A TLA+ model would not only be useful to ensure we get the protocol right, but it would also help us to grok the protocol. In the model, we can add more labels to reduce the atomicity and see when the correctness breaks, so we can reduce the protocol to its smallest atomic primitives. This model would also be a good place to start when we want to customize recovery protocol for our system implementation.<BR><BR>I searched but couldn't find a TLA model of ARIES. There are WAL models for some systems, but as far as I could see they were not doing transactional recovery&nbsp; like ARIES. Alan Fekete sent me<SPAN>&nbsp;</SPAN></FONT><A style="TEXT-DECORATION: none; BACKGROUND: none transparent scroll repeat 0% 0%; COLOR: rgb(33,150,243)" href="https://dl.acm.org/doi/pdf/10.1145/236711.236712"><FONT class=extract>this I/O automata modeling of ARIES</FONT></A><FONT class=extract><SPAN>&nbsp;</SPAN>by one of his students. It would be nice if someone can create a TLA+ modeling of the ARIES protocol starting from that model.<BR><BR>On a related note,<SPAN>&nbsp;</SPAN></FONT><A style="TEXT-DECORATION: none; BACKGROUND: none transparent scroll repeat 0% 0%; COLOR: rgb(33,150,243)" href="https://ahelwer.ca/post/2023-04-05-checkpoint-coordination/"><FONT class=extract>recent post from Andrew Helwer</FONT></A><FONT class=extract><SPAN>&nbsp;</SPAN>about how he used TLA+ to validate the design of a snapshot coordination system for Microsoft Azure Ring Master is a good read.<BR><BR></FONT></P>
<H1 style="FONT-SIZE: 2em; TEXT-ALIGN: left; MARGIN: 0.67em 0px"><FONT class=extract>NewSQL and ARIES<BR></FONT></H1>
<P style="TEXT-ALIGN: left"><FONT class=extract>ARIES is for single node transactional log recovery. For a multiple node system like NewSQL systems using Paxos groups per partitions, other considerations apply. In those systems, log-based recovery can leverage help from other nodes. (</FONT><A style="TEXT-DECORATION: none; BACKGROUND: none transparent scroll repeat 0% 0%; COLOR: rgb(33,150,243)" href="https://muratbuffalo.blogspot.com/2021/11/whats-really-new-with-newsql.html"><FONT class=extract>The NewSQL paper from Andy Pavlo</FONT></A><FONT class=extract><SPAN>&nbsp;</SPAN>has a short section on crash recovery considerations.) When a primary of a Paxos group crashes in such a database, another node in the group&nbsp; will take over as the primary, to reduce any unavailability period until the crashed node recovers and potentially rejoins the group. The new primary is still tasked with trying to forward recover a transaction or to abort it. These edges of the system are complicated, and I think prone to be buggy. I think some papers mention the work done here, but it would be good to see a more detailed exposition of recovery.<BR></FONT></P></DIV>
<DIV class=post-bottom style="DISPLAY: flex; -webkit-box-align: center; align-items: center; flex-wrap: wrap">
<DIV class="post-footer float-container" style="COLOR: ; CLEAR: left; MARGIN: 0px; flex-wrap: wrap; -webkit-box-flex: 1; flex: 1 1 auto; -webkit-box-ordinal-group: 2; order: 1">
<DIV class="post-footer-line post-footer-line-1" style="FONT-SIZE: 15px; FONT-FAMILY: Roboto, sans-serif; WHITE-SPACE: normal; WORD-SPACING: 0px; TEXT-TRANSFORM: none; FONT-WEIGHT: 400; COLOR: ; FONT-STYLE: normal; ORPHANS: 2; WIDOWS: 2; LETTER-SPACING: normal; BACKGROUND-COLOR: rgb(255,255,255); TEXT-INDENT: 0px; -webkit-box-flex: 0; flex: 0 1 auto; font-variant-ligatures: normal; font-variant-caps: normal; -webkit-text-stroke-width: 0px; text-decoration-thickness: initial; text-decoration-style: initial; text-decoration-color: initial"><SPAN class="byline post-icons" style="VERTICAL-ALIGN: top; MARGIN-TOP: 8px; COLOR: ; DISPLAY: inline-block; LINE-HEIGHT: 24px; MARGIN-RIGHT: 1em"><SPAN class=item-action><A title="Email Post" style="TEXT-DECORATION: none; BACKGROUND: none transparent scroll repeat 0% 0%; COLOR: rgb(33,150,243)" href="https://www.blogger.com/email-post.g?blogID=8436330762136344379&amp;postID=9010836299109988905"><SVG class="svg-icon-24 touch-icon sharing-icon"><USE xlink:href="/responsive/sprite_v1_6.css.svg#ic_24_email_dark" xmlns:xlink="http://www.w3.org/1999/xlink"></USE></SVG><FONT class=extract></FONT></A></SPAN></SPAN></DIV><BR class=Apple-interchange-newline></DIV></DIV>