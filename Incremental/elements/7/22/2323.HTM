Several papers have investigated the difficulty of creating wait-free algorithms. For example, it has been shown<SUP id=cite_ref-cond-sync_17-0 class=reference style="FONT-SIZE: 12px; WHITE-SPACE: nowrap; FONT-WEIGHT: normal; FONT-STYLE: normal; LINE-HEIGHT: 1"><A style="TEXT-DECORATION: none; BACKGROUND: none transparent scroll repeat 0% 0%; COLOR: ; border-radius: 2px; overflow-wrap: break-word" href="https://en.wikipedia.org/wiki/Non-blocking_algorithm#cite_note-cond-sync-17"><FONT style="BACKGROUND-COLOR: #ffffff" face=Arial>[17]</FONT></A></SUP><SPAN>&nbsp;</SPAN>that the widely available atomic<SPAN>&nbsp;</SPAN><I>conditional</I><SPAN>&nbsp;</SPAN>primitives,<SPAN>&nbsp;</SPAN><A title=Compare-and-swap style="TEXT-DECORATION: none; BACKGROUND: none transparent scroll repeat 0% 0%; COLOR: ; border-radius: 2px; overflow-wrap: break-word" href="https://en.wikipedia.org/wiki/Compare-and-swap">CAS</A><SPAN>&nbsp;</SPAN>and<SPAN>&nbsp;</SPAN><A title=Load-link/store-conditional style="TEXT-DECORATION: none; BACKGROUND: none transparent scroll repeat 0% 0%; COLOR: ; border-radius: 2px; overflow-wrap: break-word" href="https://en.wikipedia.org/wiki/Load-link/store-conditional">LL/SC</A>, cannot provide starvation-free implementations of many common data structures without memory costs growing linearly in the number of threads.