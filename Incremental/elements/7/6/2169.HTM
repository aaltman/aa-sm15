<b> : </b>Latency test<A tabIndex=-1 aria-hidden=true style="BOX-SIZING: border-box; TEXT-DECORATION: none; COLOR: rgb(37,123,215); BACKGROUND-COLOR: transparent" href="https://developer.confluent.io/learn/kafka-performance/#latency-test" data-original-href="#latency-test"><SPAN class=header-link style="BOX-SIZING: border-box; FONT-SIZE: 14px; MARGIN-LEFT: 5px; opacity: 0"></SPAN></A></H2>
<P style="BOX-SIZING: border-box; FONT-SIZE: 16px; FONT-FAMILY: Inter-Regular, Arial, sans-serif; WHITE-SPACE: normal; WORD-SPACING: 0px; TEXT-TRANSFORM: none; FONT-WEIGHT: 400; COLOR: rgb(21,32,43); FONT-STYLE: normal; ORPHANS: 2; WIDOWS: 2; MARGIN: 15px 0px; LETTER-SPACING: normal; BACKGROUND-COLOR: rgb(255,255,255); TEXT-INDENT: 0px; font-variant-ligatures: normal; font-variant-caps: normal; -webkit-text-stroke-width: 0px; text-decoration-thickness: initial; text-decoration-style: initial; text-decoration-color: initial">Given the ever-growing popularity of stream processing and event-driven architectures, another key aspect of messaging systems is end-to-end latency for a message to traverse the pipeline from the producer through the system to the consumer. A useful experiment is therefore to measure the highest stable throughput that Kafka can sustain without showing any signs of over-utilization.</P>
<P style="BOX-SIZING: border-box; FONT-SIZE: 16px; FONT-FAMILY: Inter-Regular, Arial, sans-serif; WHITE-SPACE: normal; WORD-SPACING: 0px; TEXT-TRANSFORM: none; FONT-WEIGHT: 400; COLOR: rgb(21,32,43); FONT-STYLE: normal; ORPHANS: 2; WIDOWS: 2; MARGIN: 15px 0px; LETTER-SPACING: normal; BACKGROUND-COLOR: rgb(255,255,255); TEXT-INDENT: 0px; font-variant-ligatures: normal; font-variant-caps: normal; -webkit-text-stroke-width: 0px; text-decoration-thickness: initial; text-decoration-style: initial; text-decoration-color: initial">To optimize for latency, the producer configuration was configured to batch messages up to a maximum of 1 ms only (versus the 10 ms used for throughput tests), and to also leave Kafka at its default recommended configuration while ensuring high availability. Kafka was configured to use its default fsync settings (i.e., fsync off). Based on repeated runs, it was decided to measure Kafka&#8217;s latency at<SPAN>&nbsp;</SPAN><STRONG style="BOX-SIZING: border-box; FONT-WEIGHT: bolder">200K messages/s</STRONG><SPAN>&nbsp;</SPAN>or<SPAN>&nbsp;</SPAN><STRONG style="BOX-SIZING: border-box; FONT-WEIGHT: bolder">200 MB/s</STRONG>, which is below the single disk throughput limit of 300 MB/s on this testbed.</P>
<DIV style="BOX-SIZING: border-box; FONT-SIZE: 16px; FONT-FAMILY: Inter-Regular, Arial, sans-serif; WHITE-SPACE: normal; WORD-SPACING: 0px; TEXT-TRANSFORM: none; FONT-WEIGHT: 400; COLOR: rgb(21,32,43); FONT-STYLE: normal; ORPHANS: 2; WIDOWS: 2; LETTER-SPACING: normal; BACKGROUND-COLOR: rgb(255,255,255); TEXT-INDENT: 0px; font-variant-ligatures: normal; font-variant-caps: normal; -webkit-text-stroke-width: 0px; text-decoration-thickness: initial; text-decoration-style: initial; text-decoration-color: initial"><IMG style="BORDER-TOP-STYLE: none; BOX-SIZING: border-box; CURSOR: zoom-in; MAX-WIDTH: 100%; BORDER-LEFT-STYLE: none; WIDTH: auto; BORDER-BOTTOM-STYLE: none; POSITION: relative; BORDER-RIGHT-STYLE: none; LEFT: 0px; MIN-HEIGHT: 200px; MARGIN: auto; DISPLAY: block; transform: translateX(-50%)" alt="Kafka Latency" src="https://images.contentful.com/gt6dp23g0g38/1iUk2oJgsnFE37Dvu1OpZQ/cbc161daac1009ddd9ac49154d206815/unnamed-10.png"></DIV>
<P style="BOX-SIZING: border-box; FONT-SIZE: 16px; FONT-FAMILY: Inter-Regular, Arial, sans-serif; WHITE-SPACE: normal; WORD-SPACING: 0px; TEXT-TRANSFORM: none; FONT-WEIGHT: 400; COLOR: rgb(21,32,43); FONT-STYLE: normal; ORPHANS: 2; WIDOWS: 2; MARGIN: 15px 0px; LETTER-SPACING: normal; BACKGROUND-COLOR: rgb(255,255,255); TEXT-INDENT: 0px; font-variant-ligatures: normal; font-variant-caps: normal; -webkit-text-stroke-width: 0px; text-decoration-thickness: initial; text-decoration-style: initial; text-decoration-color: initial"><EM style="BOX-SIZING: border-box">Figure 4. End-to-end latency for Kafka, measured at 200K messages/s (1 KB message size). See the<SPAN>&nbsp;</SPAN><A style="BOX-SIZING: border-box; TEXT-DECORATION: none; COLOR: rgb(37,123,215); BACKGROUND-COLOR: transparent" href="https://github.com/confluentinc/openmessaging-benchmark/tree/master/blog/results/kafka/latency" rel="nofollow noopener noreferrer" target=_blank data-original-href="https://github.com/confluentinc/openmessaging-benchmark/tree/master/blog/results/kafka/latency">raw results</A><SPAN>&nbsp;</SPAN>for details. Note: Latency (ms)&#8212;lower is better.</EM></P>
<P style="BOX-SIZING: border-box; FONT-SIZE: 16px; FONT-FAMILY: Inter-Regular, Arial, sans-serif; WHITE-SPACE: normal; WORD-SPACING: 0px; TEXT-TRANSFORM: none; FONT-WEIGHT: 400; COLOR: rgb(21,32,43); FONT-STYLE: normal; ORPHANS: 2; WIDOWS: 2; MARGIN: 15px 0px; LETTER-SPACING: normal; BACKGROUND-COLOR: rgb(255,255,255); TEXT-INDENT: 0px; font-variant-ligatures: normal; font-variant-caps: normal; -webkit-text-stroke-width: 0px; text-decoration-thickness: initial; text-decoration-style: initial; text-decoration-color: initial">Kafka consistently delivered low latencies. Since the experiment was deliberately set up so that consumers were always able to keep up with the producers, all of the reads were served off of the cache.</P>
<P style="BOX-SIZING: border-box; FONT-SIZE: 16px; FONT-FAMILY: Inter-Regular, Arial, sans-serif; WHITE-SPACE: normal; WORD-SPACING: 0px; TEXT-TRANSFORM: none; FONT-WEIGHT: 400; COLOR: rgb(21,32,43); FONT-STYLE: normal; ORPHANS: 2; WIDOWS: 2; MARGIN: 15px 0px; LETTER-SPACING: normal; BACKGROUND-COLOR: rgb(255,255,255); TEXT-INDENT: 0px; font-variant-ligatures: normal; font-variant-caps: normal; -webkit-text-stroke-width: 0px; text-decoration-thickness: initial; text-decoration-style: initial; text-decoration-color: initial">Much of Kafka&#8217;s performance can be attributed to a heavily optimized read implementation for consumers, built on efficient data organization, without any additional overheads like data skipping. Kafka deeply leverages the Linux page cache and<SPAN>&nbsp;</SPAN><A style="BOX-SIZING: border-box; TEXT-DECORATION: none; COLOR: rgb(37,123,215); BACKGROUND-COLOR: transparent" href="https://www.linuxjournal.com/article/6345" rel="nofollow noopener noreferrer" target=_blank data-original-href="https://www.linuxjournal.com/article/6345">zero-copy</A><SPAN>&nbsp;</SPAN>mechanism to avoid copying data into user space. Typically many systems, like databases, have built out application-level caches that give them more flexibility to support random read/write workloads. However, for a messaging system, relying on the page cache is a great choice because typical workloads do sequential read/writes. The Linux kernel has been optimized for many years to be smart about detecting these patterns and employ techniques like readahead to vastly improve read performance. Similarly, building on top of the page cache allows Kafka to employ<SPAN>&nbsp;</SPAN><A style="BOX-SIZING: border-box; TEXT-DECORATION: none; COLOR: rgb(37,123,215); BACKGROUND-COLOR: transparent" href="https://man7.org/linux/man-pages/man2/sendfile.2.html" rel="nofollow noopener noreferrer" target=_blank data-original-href="https://man7.org/linux/man-pages/man2/sendfile.2.html">sendfile-based</A><SPAN>&nbsp;</SPAN>network transfers that avoid additional data copies.