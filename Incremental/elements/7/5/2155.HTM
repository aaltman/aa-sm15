<H3 class="post-title entry-title" style="WHITE-SPACE: normal; WORD-SPACING: 0px; TEXT-TRANSFORM: none; FLOAT: left; COLOR: rgb(33,33,33); FONT: bold 30px Roboto, sans-serif; ORPHANS: 2; WIDOWS: 2; MARGIN: 0px 0px 8px; LETTER-SPACING: normal; BACKGROUND-COLOR: rgb(255,255,255); TEXT-INDENT: 0px; -webkit-text-stroke-width: 0px; text-decoration-thickness: initial; text-decoration-style: initial; text-decoration-color: initial"><FONT class=extract>Scalable OLTP in the Cloud: What&#8217;s the BIG DEAL?</FONT></H3>
<DIV class="post-share-buttons post-share-buttons-top" style="FONT-SIZE: 15px; FONT-FAMILY: Roboto, sans-serif; WHITE-SPACE: normal; WORD-SPACING: 0px; POSITION: relative; TEXT-TRANSFORM: none; FLOAT: right; FONT-WEIGHT: 400; COLOR: rgb(117,117,117); FONT-STYLE: normal; MARGIN-LEFT: 0px; ORPHANS: 2; WIDOWS: 2; LETTER-SPACING: normal; BACKGROUND-COLOR: rgb(255,255,255); TEXT-INDENT: 0px; -webkit-text-stroke-width: 0px; text-decoration-thickness: initial; text-decoration-style: initial; text-decoration-color: initial; font-variant-ligatures: normal; font-variant-caps: normal">
<DIV class="byline post-share-buttons goog-inline-block" style="WIDTH: 24px; VERTICAL-ALIGN: top; MARGIN-TOP: 0px; POSITION: relative; COLOR: ; MARGIN-LEFT: 0px; DISPLAY: inline-block; LINE-HEIGHT: 24px; MARGIN-RIGHT: 0px">
<DIV class=sharing style="FLOAT: right" aria-owns=sharing-popup-Blog1-byline-7021699056598219221 data-title="Scalable OLTP in the Cloud: What&#8217;s the BIG DEAL?">
<DIV class=share-buttons-container><FONT class=extract></FONT></DIV></DIV></DIV></DIV>
<DIV class=post-header style="FONT-SIZE: 15px; FONT-FAMILY: Roboto, sans-serif; WHITE-SPACE: normal; WORD-SPACING: 0px; TEXT-TRANSFORM: none; FONT-WEIGHT: 400; COLOR: ; FONT-STYLE: normal; CLEAR: left; ORPHANS: 2; WIDOWS: 2; MARGIN: 0px; LETTER-SPACING: normal; BACKGROUND-COLOR: rgb(255,255,255); TEXT-INDENT: 0px; -webkit-text-stroke-width: 0px; text-decoration-thickness: initial; text-decoration-style: initial; text-decoration-color: initial; font-variant-ligatures: normal; font-variant-caps: normal">
<DIV class=post-header-line-1><SPAN class="byline post-timestamp" style="VERTICAL-ALIGN: top; MARGIN-TOP: 8px; COLOR: ; DISPLAY: inline-block; LINE-HEIGHT: 24px; MARGIN-RIGHT: 0px"><FONT class=extract>-<SPAN>&nbsp;</SPAN></FONT><A title="permanent link" class=timestamp-link style="TEXT-DECORATION: ; BACKGROUND: none transparent scroll repeat 0% 0%; COLOR: " href="https://muratbuffalo.blogspot.com/2024/01/scalable-oltp-in-cloud-whats-big-deal.html" rel=bookmark><TIME title=2024-01-17T20:21:00-05:00 class=published datetime="2024-01-17T20:21:00-05:00"><FONT class=extract>January 17, 2024</TIME></FONT></A></SPAN></DIV></DIV>
<DIV id=post-body-7021699056598219221 class="post-body entry-content float-container" style="WHITE-SPACE: normal; WORD-SPACING: 0px; TEXT-TRANSFORM: none; COLOR: rgb(117,117,117); FONT: 400 17px/1.6em Roboto, sans-serif; ORPHANS: 2; WIDOWS: 2; MARGIN: 1.5em 0px 2em; DISPLAY: block; LETTER-SPACING: normal; BACKGROUND-COLOR: rgb(255,255,255); TEXT-INDENT: 0px; -webkit-text-stroke-width: 0px; text-decoration-thickness: initial; text-decoration-style: initial; text-decoration-color: initial">
<P><A style="TEXT-DECORATION: none; BACKGROUND: none transparent scroll repeat 0% 0%; COLOR: rgb(33,150,243)" href="https://www.cidrdb.org/cidr2024/papers/p63-helland.pdf"><FONT class=extract>This paper</FONT></A><FONT class=extract><SPAN>&nbsp;</SPAN>is from Pat Helland, the apostate philosopher of database systems, overall a superb person, and a good friend of mine. The paper appeared this week at CIDR'24. (Check out<SPAN>&nbsp;</SPAN></FONT><A style="TEXT-DECORATION: none; BACKGROUND: none transparent scroll repeat 0% 0%; COLOR: rgb(33,150,243)" href="https://www.cidrdb.org/cidr2024/program.html"><FONT class=extract>the program</FONT></A><FONT class=extract><SPAN>&nbsp;</SPAN>for other interesting papers). The motivating question behind this work is: "<B style="FONT-WEIGHT: bold">What are the asymptotic limits to scale for cloud OLTP (OnLine Transaction Processing) systems?</B>" Pat says that the CIDR 2023 paper<SPAN>&nbsp;</SPAN></FONT><A style="TEXT-DECORATION: none; BACKGROUND: none transparent scroll repeat 0% 0%; COLOR: rgb(33,150,243)" href="https://muratbuffalo.blogspot.com/2023/01/is-scalable-oltp-in-cloud-solved.html"><FONT class=extract>"Is Scalable OLTP in the Cloud a Solved Problem?"</FONT></A><FONT class=extract><SPAN>&nbsp;</SPAN>prompted this question.&nbsp;</FONT></P>
<P><FONT class=extract>The answer to the question? Pat says that the answer lies in the joint responsibility of database and the application. If you know of Pat's work, which I have summarized<SPAN>&nbsp;</SPAN></FONT><A style="TEXT-DECORATION: none; BACKGROUND: none transparent scroll repeat 0% 0%; COLOR: rgb(33,150,243)" href="https://muratbuffalo.blogspot.com/search?q=Helland"><FONT class=extract>several in this blog</FONT></A><FONT class=extract>, you would know that Pat has been advocating along these lines before. But this paper provides a very crisp, specific, concrete answer. Read on for my summary of the paper.</FONT></P>
<P><FONT class=extract>Disclaimer: This is a wisdom and technical information/detail packed 13-page paper, so I will try my best to summarize the salient points. I will be using text from the paper to explain/summarize it. (Don't taze me bro!)&nbsp;</FONT></P>
<P><FONT class=extract><BR></FONT></P>
<H1 style="FONT-SIZE: 2em; TEXT-ALIGN: left; MARGIN: 0.67em 0px"><FONT class=extract>Snapshot Isolation (SI) is a BIG DEAL</FONT></H1>
<P><FONT class=extract>The database and the application have a BIG DEAL: their isolation semantics! In particular, snapshot isolation (SI) is the sweet spot. At this point, I got a nice database history lesson on how the isolation semantics evolved. I would have guessed the semantics had become more strict over time. No, on the contrary, they evolved to be more relaxed to meet performance and scalability expectations. And SI does hit a sweet point in that it still provides the user good isolation guarantees without jeopardizing the scaling behavior of the database by requiring it to serialize everything.&nbsp;</FONT></P>
<DIV class=separator style="TEXT-ALIGN: center; CLEAR: both"><A style="TEXT-DECORATION: none; BACKGROUND: none transparent scroll repeat 0% 0%; COLOR: rgb(33,150,243); MARGIN-LEFT: 1em; MARGIN-RIGHT: 1em" href="https://blogger.googleusercontent.com/img/a/AVvXsEixuW5RhqakvtCihi8JM91NYzNa7Ud6z3G2SM7D2fS4z1B60hF8w8pZOtnL7TW6n5HJHu9Uap4RNJO9lBCCy5LlXR2FaLterr1EOyZo7cNy7G2hvI0Z82BNQFdPywPLidWFFa76aPyaiVGg5G7ZdpneCtiDASM2uDZZZcLYmMhOW-tlJJVi4FdTMs7tMBI"><FONT class=extract><IMG style="MAX-WIDTH: 100%; BORDER-TOP: 0px; BORDER-RIGHT: 0px; BORDER-BOTTOM: 0px; BORDER-LEFT: 0px" alt="" src="https://blogger.googleusercontent.com/img/a/AVvXsEixuW5RhqakvtCihi8JM91NYzNa7Ud6z3G2SM7D2fS4z1B60hF8w8pZOtnL7TW6n5HJHu9Uap4RNJO9lBCCy5LlXR2FaLterr1EOyZo7cNy7G2hvI0Z82BNQFdPywPLidWFFa76aPyaiVGg5G7ZdpneCtiDASM2uDZZZcLYmMhOW-tlJJVi4FdTMs7tMBI=w375-h400" width=375 height=400 data-original-height="722" data-original-width="676"></FONT></A></DIV>
<P><FONT class=extract>In the rest of the paper, keep in mind that, an OLTP system is defined as a domain-specific application using a<SPAN>&nbsp;</SPAN><B style="FONT-WEIGHT: bold">RCSI (READ COMMITTED SNAPSHOT ISOLATION) SQL database</B><SPAN>&nbsp;</SPAN>to provide transactions across many concurrent users.</FONT></P>
<P><FONT class=extract>The BIG DEAL splits the scaling responsibilities between the database and the application.</FONT></P>
<P><FONT class=extract></FONT></P>
<UL style="TEXT-ALIGN: left">
<LI><FONT class=extract><B style="FONT-WEIGHT: bold"><U>Scalable DBs don&#8217;t coordinate across disjoint TXs updating different keys.</U></B> </FONT>
<LI><B style="FONT-WEIGHT: bold"><U><FONT class=extract>Scalable apps don&#8217;t concurrently update the same key.</FONT></U></B></LI></UL>
<P><FONT class=extract></FONT></P>
<P><FONT class=extract>The big deal provides guarantees from the DB to the App. A scalable application can read all it wants. Updates to disjoint records don&#8217;t coordinate across TXs. Row-locks on disjoint records don&#8217;t coordinate across TXs.</FONT></P>
<P><FONT class=extract>Applications must tolerate these big deal disclaimers. Reads return snapshots: Records have no "current" value. There is no NOW in a BIG DEAL database! Transactions may abort any time but not too often. SELECT with SKIP LOCKED may subset the set of qualifying records as it returns results.</FONT></P>
<P><FONT class=extract>This means applications should change business behavior in order to scale. They can only provide a fuzzy/blurry view of the "current" state/changes. So, apps introduce ambiguity in biz domain specific ways: online retail makes ambiguous promises such as "Usually ships in 24 hours". And apps provide delayed truth: finances of a large company may take days to summarize. Many OLTP apps aggregate values synchronously as they interact with humans. Public TPC benchmarks (e.g., TPC-A, TPC-B, and TPC-C) mandated synchronous aggregations. But, as applications scale they should rethink concentrating the aggregated values of business state in dedicated records. By slowly &nbsp;and asynchronously aggregating these business state, the application can scale in a domain-specific manner.</FONT></P>
<P><FONT class=extract><BR></FONT></P>
<H1 style="FONT-SIZE: 2em; TEXT-ALIGN: left; MARGIN: 0.67em 0px"><FONT class=extract>Today's OLTP databases don't scale</FONT></H1>
<P><FONT class=extract>Before suggesting a hypothetical scalable database that satisfies the database side of the big deal, Pat shows us why today&#8217;s databases don&#8217;t scale!</FONT></P>
<DIV class=separator style="TEXT-ALIGN: center; CLEAR: both"><A style="TEXT-DECORATION: none; BACKGROUND: none transparent scroll repeat 0% 0%; COLOR: rgb(33,150,243); MARGIN-LEFT: 1em; MARGIN-RIGHT: 1em" href="https://blogger.googleusercontent.com/img/a/AVvXsEha3LKPdGbzAgf0z8Gr8UwOfZIE5gviSpIYJl7gan52cd7k-tmgXKuzJbXt_je7-vnRpsi_TNc_61xbOZuP5hlRFPPyYdawO4ldh4tXQdCAZH_qH7ehfd-C9Y_t2WJbnrRgLIaNO11wTXITw-yvVn03mjkqR92P3qgcfQ56BRi-5yEAG9EvEs-8oSjyRKs"><FONT class=extract><IMG style="MAX-WIDTH: 100%; BORDER-TOP: 0px; BORDER-RIGHT: 0px; BORDER-BOTTOM: 0px; BORDER-LEFT: 0px" alt="" src="https://blogger.googleusercontent.com/img/a/AVvXsEha3LKPdGbzAgf0z8Gr8UwOfZIE5gviSpIYJl7gan52cd7k-tmgXKuzJbXt_je7-vnRpsi_TNc_61xbOZuP5hlRFPPyYdawO4ldh4tXQdCAZH_qH7ehfd-C9Y_t2WJbnrRgLIaNO11wTXITw-yvVn03mjkqR92P3qgcfQ56BRi-5yEAG9EvEs-8oSjyRKs=s16000" data-original-height="306" data-original-width="1528"></FONT></A></DIV>
<P><FONT class=extract>In today's MVCC databases, reads &amp; writes fight to access the "current" value of a record. The current version has a<SPAN>&nbsp;</SPAN><B style="FONT-WEIGHT: bold">home</B>&nbsp;location (a partition, server, or a B+ tree) holding the most recently committed version of the record or perhaps an uncommitted version. To update a record, exclusive access to the record's home is required. This causes infighting, contention, and coordination between the updating TX and any concurrent reading TXs.</FONT></P>
<P><FONT class=extract>Even reads contend with each other, since these implementations force MVCC readers to start out looking at the latest version of a key first. Coordination may also be needed to access neighboring records. Accessing key-ranges in B+Trees or similar data structures that may be changing needs cross-transaction coordination.</FONT></P>
<P><FONT class=extract>Readers coordinate with writers. Writers coordinate with readers. Readers coordinate with other readers!</FONT></P>
<P><FONT class=extract>Having a home for a record also makes online repartitioning/sharding (which is required for scalability) very difficult. Moving record keys from one partition to another is complex and impacts application availability.</FONT></P>
<P><FONT class=extract>To address these challenges, Pat proposes a prototype design. The database is structured so that there is no pre-assigned home for a record per key. Unlike partitioned DBs, this allows the database to seamlessly adapt to workload changes.</FONT></P>
<P><FONT class=extract>I liken this to the<SPAN>&nbsp;</SPAN></FONT><A style="TEXT-DECORATION: none; BACKGROUND: none transparent scroll repeat 0% 0%; COLOR: rgb(33,150,243)" href="https://en.wikipedia.org/wiki/Everything_Is_Miscellaneous"><FONT class=extract>miscellaneous manifesto</FONT></A><FONT class=extract><SPAN>&nbsp;</SPAN>or how instead of neatly organizing/allocating everything a place (which inevitably fails, requiring incessant re-orgs), embracing the messiness and using a search engine to get to information quickly.</FONT></P>
<P><FONT class=extract><BR></FONT></P>
<H1 style="FONT-SIZE: 2em; TEXT-ALIGN: left; MARGIN: 0.67em 0px"><FONT class=extract>Rethinking OLTP databases</FONT></H1>
<P><FONT class=extract>The architecture is based on<SPAN>&nbsp;</SPAN></FONT><A style="TEXT-DECORATION: none; BACKGROUND: none transparent scroll repeat 0% 0%; COLOR: rgb(33,150,243)" href="https://muratbuffalo.blogspot.com/2022/01/decoupled-transactions-low-tail-latency.html"><FONT class=extract>a design Pat explored in a previous work</FONT></A><FONT class=extract>. The work is very technical, and I missed the nuance and contributions of it because I didn't read through the appendix about details.</FONT></P>
<DIV class=separator style="TEXT-ALIGN: center; CLEAR: both"><A style="TEXT-DECORATION: none; BACKGROUND: none transparent scroll repeat 0% 0%; COLOR: rgb(33,150,243); MARGIN-LEFT: 1em; MARGIN-RIGHT: 1em" href="https://blogger.googleusercontent.com/img/a/AVvXsEgBmeGMqsLQWCyBjr7ikas0mIkFdZ-6nVculH07Da5GPn2-TZ7B2XNXNvM_7Ux11JAAAWOR_nbOV98pZr72ILraXKqnhoIGV9n8Kr_rXX8F4Hge4Qj5Z5-GZowCyH6Fg25yoejZlQNgUTfQcDVGL-ELNaeE4eATUrT-3Go1hAPgzlnFsEBXkQE3ZBiRngo"><FONT class=extract><IMG style="MAX-WIDTH: 100%; BORDER-TOP: 0px; BORDER-RIGHT: 0px; BORDER-BOTTOM: 0px; BORDER-LEFT: 0px" alt="" src="https://blogger.googleusercontent.com/img/a/AVvXsEgBmeGMqsLQWCyBjr7ikas0mIkFdZ-6nVculH07Da5GPn2-TZ7B2XNXNvM_7Ux11JAAAWOR_nbOV98pZr72ILraXKqnhoIGV9n8Kr_rXX8F4Hge4Qj5Z5-GZowCyH6Fg25yoejZlQNgUTfQcDVGL-ELNaeE4eATUrT-3Go1hAPgzlnFsEBXkQE3ZBiRngo=s16000" data-original-height="502" data-original-width="832"></FONT></A></DIV>
<P><FONT class=extract><B style="FONT-WEIGHT: bold">Owner servers</B>&nbsp;verify that concurrent transactions have not created any conflicting updates for each key row-locked or updated by the TX that optimistically hopes to commit. Owner servers partitioned by both key-range and time-range. Repartitioning happens dynamically to accommodate scale.&nbsp;</FONT></P>
<P><FONT class=extract><B style="FONT-WEIGHT: bold">Worker servers</B>&nbsp;are also horizontally scalable, and each have their own transaction log. As TX load increases, workers are added. Each TX happens at a single worker server. The worker servers accept connections from app servers, perform transactions &amp; their queries, commit transactions to their per-worker log, and periodically flush committed new record-versions to the<SPAN>&nbsp;</SPAN></FONT><A style="TEXT-DECORATION: none; BACKGROUND: none transparent scroll repeat 0% 0%; COLOR: rgb(33,150,243)" href="https://en.wikipedia.org/wiki/Log-structured_merge-tree"><FONT class=extract>LSM (log structured merge tree)</FONT></A><FONT class=extract>.</FONT></P>
<P><FONT class=extract><B style="FONT-WEIGHT: bold">LSM servers</B>&nbsp;accept flushes from workers and incorporate them into the orderly past stored in the LSM. Record-versions are organized first by time, second by key. Each LSM layer contains record-versions for a band of time. With an LSM, the past scales without coordinating across disjoint transactions reading and updating!</FONT></P>
<DIV class=separator style="TEXT-ALIGN: center; CLEAR: both"><A style="TEXT-DECORATION: none; BACKGROUND: none transparent scroll repeat 0% 0%; COLOR: rgb(33,150,243); MARGIN-LEFT: 1em; MARGIN-RIGHT: 1em" href="https://blogger.googleusercontent.com/img/a/AVvXsEhyhoxQSRPZsc1QWeYCex7Gm209SlW0kQMH53tGgHyt5YwnwXwOdDyPbOgYCk8dtiVP-pSxdK_xCI1tS4JCdDukqtg_-TvgwRCHoRFIcHWBs7mITLcdpkmqsx5fwMuOAU9xdweo7NHRS6V11VNBnLVlU_fH6iD1DBLVCSr6bk6oI9E23xoqwLe_FtNzAos"><FONT class=extract><IMG style="MAX-WIDTH: 100%; BORDER-TOP: 0px; BORDER-RIGHT: 0px; BORDER-BOTTOM: 0px; BORDER-LEFT: 0px" alt="" src="https://blogger.googleusercontent.com/img/a/AVvXsEhyhoxQSRPZsc1QWeYCex7Gm209SlW0kQMH53tGgHyt5YwnwXwOdDyPbOgYCk8dtiVP-pSxdK_xCI1tS4JCdDukqtg_-TvgwRCHoRFIcHWBs7mITLcdpkmqsx5fwMuOAU9xdweo7NHRS6V11VNBnLVlU_fH6iD1DBLVCSr6bk6oI9E23xoqwLe_FtNzAos=w400-h170" width=400 height=170 data-original-height="354" data-original-width="832"></FONT></A></DIV>
<P><FONT class=extract><BR></FONT></P>
<H1 style="FONT-SIZE: 2em; TEXT-ALIGN: left; MARGIN: 0.67em 0px"><FONT class=extract>Transaction execution and commit</FONT></H1>
<P><FONT class=extract>We now deep dive to workers and owners as they are the most significant components in this OLTP architecture. The owners do the concurrency control (the adjudication of transactions with respect to other concurrent transactions), but the workers do the actual work of the transaction. The transaction is centralized in the worker's log. The workers' logs are ingested by LSM servers for later consumption and durability.</FONT></P>
<P><FONT class=extract>The worker will accept incoming connections from application servers, and plan/execute SQL statements: Reading with snapshots by key or key-range, acquiring row-locks using their unique record key, and updating records by their unique key. The worker will guess a future time to hopefully commit after being verified that updates and row-locks don&#8217;t conflict with concurrent TXs. The worker will then log the transaction&#8217;s updates &amp; commit record in its local transaction log, which will then be fed into LSM servers.</FONT></P>
<P><FONT class=extract>As a commit-time for a transaction is guessed by the worker, every update and row-lock must be verified for no conflicting updates from snapshot to commit by the owner servers. As incoming proposed-updates and verify-locks arrive, they include a proposed-commit-time. Owner-servers align commit-time for records &amp; workers. An incoming request from a worker hopefully arrives at the owner-server before its local clock has reached the proposed-commit-time. If it arrives after commit-time, owner-server returns an error and the TX aborts. If it arrives before commit-time, the owner-server waits until its local clock reaches commit-time.</FONT></P>
<P><FONT class=extract>What are row-locks you ask?</FONT></P>
<P><FONT class=extract>Row-locks allow the application to ask the database for help with concurrency across transactions. Traffic cops provide pessimistic concurrency control. They will stall later transactions if they acquire a row-lock held by an earlier transaction. This pessimistic ordering of transactions may be violated when failures happen. Competing transactions usually wait to allow the lock holder to go first but that may be flawed. So correctness will be enforced by OCC prior to commit. Of course, row-locks are moot when scalable apps avoid concurrent updates to the same records. But if the app experience concurrent updates to the same records, row-locks can help with the liveness of transactions when the DB uses them to function as a traffic cop.</FONT></P>
<P><FONT class=extract>Ok, let's wrap up the transaction execution discussion by talking about how owners can be horizontally scaled. Owners can close for new business and direct new proposed-updates elsewhere. An owner closed for new business only accept worker requests for snapshot reads in their rectangle of key &amp; time ranges, proposed updates, and notifications of transaction outcome. In contrast an owner open for new business also allow new proposed-updates, and new verify-locks.</FONT></P>
<P><FONT class=extract><BR></FONT></P>
<H1 style="FONT-SIZE: 2em; TEXT-ALIGN: left; MARGIN: 0.67em 0px"><FONT class=extract>Massive Scale: It&#8217;s About Time!</FONT></H1>
<P><FONT class=extract>As we have seen, the DB leverages time to provide snapshots, commits, and external consistency. External Consistency ensures new incoming requests see all previously exposed data, even by other database connections. That means, snapshot reads from new incoming work must be after all committed work previously visible outside the database.</FONT></P>
<P><FONT class=extract>By using current time, T-now, as the snapshot time, this is easy. But this would get trickier and more complex as the geographic scope of a DB grows past a single datacenter.</FONT></P>
<P><FONT class=extract>Overall, this prototype database architecture is a big vindication for using time in systems. (Some of these ideas have been explored in Pat's earlier paper, under seniority and retirement.) Everything in the database is versioned by the record-version commit time. The database organizes data by its creation time to achieve scaling. Reads are old record-versions as of a past snapshot. Row-locks ensure locked records unchanged until commit time. And updates materialize as new record-versions for later snapshots.</FONT></P></DIV>