<b> : </b>Introduction</H2>
<P style="BOX-SIZING: border-box; MARGIN: 0px 0px 10px">In our previous study, we have done a lot of detailed analysis of basic operations for the red-black trees based on the traditional sequential algorithm. In this project, I am going to use parallel algorithm to implement red-black tree's<SPAN>&nbsp;</SPAN><I style="BOX-SIZING: border-box">search</I><SPAN>&nbsp;</SPAN>and<SPAN>&nbsp;</SPAN><I style="BOX-SIZING: border-box">insertion</I><SPAN>&nbsp;</SPAN>operations. I will implement these two operations by both lock-based and lock-free synchronization in parallel algorithm, and then compare the performance of these two methods.</P>
<P style="BOX-SIZING: border-box; MARGIN: 0px 0px 10px">The red-black tree is a balanced binary search tree with height O(log<SPAN>&nbsp;</SPAN><I style="BOX-SIZING: border-box">n</I>), and efficient search, insertion, and deletion operations, which makes it a better choice than regular binary search in search-intensive applications. And it only requires few rotations to rebalance the tree and keep it red-black properties.</P>
<P style="BOX-SIZING: border-box; MARGIN: 0px 0px 10px">As we known, it takes O(log<SPAN>&nbsp;</SPAN><I style="BOX-SIZING: border-box">n</I>) for red-black tree's search and insertion operations by sequential algorithms. As for using parallel algorithms, the search and insertion time would be O(log<SPAN>&nbsp;</SPAN><I style="BOX-SIZING: border-box">n</I><SPAN>&nbsp;</SPAN>+ log<I style="BOX-SIZING: border-box">k</I>), where<SPAN>&nbsp;</SPAN><I style="BOX-SIZING: border-box">k</I><SPAN>&nbsp;</SPAN>is the number threads/concurrents. Although they both have the upper bound O(log<SPAN>&nbsp;</SPAN><I style="BOX-SIZING: border-box">n</I>), and parallel algorithm even have another add-on term<SPAN>&nbsp;</SPAN><I style="BOX-SIZING: border-box">log k</I>, parallel algorithms would provide a smaller coefficient for the big-O notation. And in my project, I will do experiments to compare the performance on lock-based and lock-free parallel algorithms, and I will claim that lock-free synchronization has a better performance than lock-based.</P></DIV></DIV>
<DIV class=container style='BOX-SIZING: border-box; FONT-SIZE: 16px; FONT-FAMILY: "Helvetica Neue", Helvetica, Arial, sans-serif; WIDTH: 1170px; WHITE-SPACE: normal; WORD-SPACING: 0px; TEXT-TRANSFORM: none; FONT-WEIGHT: 400; COLOR: rgb(51,51,51); FONT-STYLE: normal; PADDING-LEFT: 15px; MARGIN-LEFT: auto; ORPHANS: 2; WIDOWS: 2; LETTER-SPACING: normal; PADDING-RIGHT: 15px; MARGIN-RIGHT: auto; TEXT-INDENT: 0px; font-variant-ligatures: normal; font-variant-caps: normal; -webkit-text-stroke-width: 0px; text-decoration-thickness: initial; text-decoration-style: initial; text-decoration-color: initial'>
<DIV class=row style="BOX-SIZING: border-box; MARGIN-LEFT: -15px; MARGIN-RIGHT: -15px">