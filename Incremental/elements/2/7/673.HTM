<A href="https://www.usenix.org/system/files/conference/atc16/atc16_paper-falsafi.pdf">https://www.usenix.org/system/files/conference/atc16/atc16_paper-falsafi.pdf</A>
<P>Figure 5 includes the power of busy waiting with monitor/mwait. These instructions can reduce power consumption over conventional spinning up to 1.5x. However, similarly to DVFS, using monitor/mwait has two shortcomings. First, monitor/mwait can be only used in kernel space. The overloaded file operation takes roughly 700 cycles. The best case wake-up latency from mwait, with just one core &#8220;sleeping,&#8221; is 1600 cycles. In comparison, &#8220;waking up&#8221; a locally-spinning thread takes two cache-line transfers (i.e., 280 cycles). Second, programming with monitor/mwait on Intel processors can be elaborate and limiting. The mwait instruction blocks the hardware context until the thread is awaken. In oversubscribed environments (i.e., more threads than hardware contexts), monitor/mwait will likely exacerbate the &#8220;livelock&#8221; issues of spinlocks (see &#167;6). Blocked threads might occupy most hardware contexts, thus preventing other threads from performing useful work.