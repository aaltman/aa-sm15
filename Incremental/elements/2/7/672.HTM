<A href="https://www.usenix.org/system/files/conference/atc16/atc16_paper-falsafi.pdf">https://www.usenix.org/system/files/conference/atc16/atc16_paper-falsafi.pdf</A> 
<P></P>
<P>Unlocking Energy Babak Falsafi Rachid Guerraoui Javier Picorel Vasileios Trigonakis &#8727; {first.last}@epfl.ch EcoCloud, EPFL</P>
<P><FONT class=extract>In general, the reason behind the very low CPI of local spinning is the aggressive execution mechanisms of modern processors that allow instructions to execute both speculatively and out of the program order. This results in one out of three of the retired operations being a memory load (the other two are a test and a conditional jump). Without appropriate pausing, the spin loop retires one memory load per cycle.</FONT> 
<P><FONT class=extract>A way to avoid the speculative execution of the load is to insert a full, or a load, memory barrier. That way, the loads only execute once the previous load retires and the instructions that depend on it, test and jump, are stalled as well. The results (local-mbar) show that the barrier reduces the power consumption of local spinning to the point that becomes less expensive than global spinning (global). Additionally, local-mbar consumes up to 7% less power than local-pause. It is worth noting that localmbar consumes less power than local-pause even for low thread counts (e.g., 5% on 10 threads). In the rest of the paper, we use a memory barrier for pausing in spin loops.</FONT>