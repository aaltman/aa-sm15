Figure 6 further includes two interesting points. First, for low delays between the two calls, the wake-up call is more expensive as it waits behind a kernel lock for the completion of the sleep call. Second, when the delay between the calls is very large (&gt;600K cycles), the turnaround latency explodes, because the hardware context sleeps in a deeper idle state [41]. 
<P></P>
<P>Finally, the results in Figure 6 use just two threads and thus represent the best-case latencies, with minimal or no contention at the kernel level. With more threads, a wake-up invocation is likely to contend with futex sleep calls, all serialized using a single kernel lock. Implications. futex operations have high latencies and consume energy, as a non-negligible number of instructions are executed. Handing over a lock with a futex wake-up call requires at least 7000 cycles. Even on rather lengthy critical sections (e.g., 10000 cycles), this latency is prohibitive; it almost doubles the execution time of the critical section. In this case, the energy benefits of sleeping will not easily compensate the performance losses. In short critical sections, invoking futex calls will have detrimental effects on performance.</P>
<P><A href="https://www.usenix.org/system/files/conference/atc16/atc16_paper-falsafi.pdf">https://www.usenix.org/system/files/conference/atc16/atc16_paper-falsafi.pdf</A></P>
<P>&nbsp;