<b> : </b>Conclusion and Future Work</H2>
<P style="BOX-SIZING: border-box; MARGIN: 0px 0px 10px">Based on my implementation and experiment results, we can reach the conclusion that lock-free algorithms have a better performance on<SPAN>&nbsp;</SPAN><I style="BOX-SIZING: border-box">search</I><SPAN>&nbsp;</SPAN>and<SPAN>&nbsp;</SPAN><I style="BOX-SIZING: border-box">insertion</I><SPAN>&nbsp;</SPAN>operations on relatively large red-black tree. From the line charts, we can conclude that when the tree gets larger, the performance difference would be more obvious. For future work, I think we can work on finding the hidden constant in the Big-O notation for these two algorithms, so that we can compare the performance of these two algorithms theoretically. The other thing we can work on is to implement lock-free algorithm for<SPAN>&nbsp;</SPAN><I style="BOX-SIZING: border-box">deletion</I><SPAN>&nbsp;</SPAN>operation. Since red-black trees store information not only on leaf nodes but also on internal nodes,<SPAN>&nbsp;</SPAN><I style="BOX-SIZING: border-box">deletion</I><SPAN>&nbsp;</SPAN>operation for red-black trees would result in a more complex structural change, which makes the implementation much harder. Another thing we can do in the future is to find a way to visualize the process for lock-free insertion, which could give users a more straightforward demonstration on how these concurrents work. In addition, in Kim's paper, he proposed an improved version on Ma's algorithm, which needs fewer CAS operations by defining a larger "local area". We might try out his method, and compare its performance with the original Ma's algorithm. We can also study the better concurrent control method "wait-free" to improve the performance for lock-free synchronization.</P></DIV></DIV>
<DIV class=container style="BOX-SIZING: border-box; WIDTH: 1170px; PADDING-LEFT: 15px; MARGIN-LEFT: auto; PADDING-RIGHT: 15px; MARGIN-RIGHT: auto">
<DIV class=row style="BOX-SIZING: border-box; MARGIN-LEFT: -15px; MARGIN-RIGHT: -15px">