We show two problems with futex-based sleeping: (i) high turnaround latencies, and (ii) frequent sleeps and wake ups do not reduce power consumption. To fix both problems simultaneously, we recognize the following trade-off: We can let some threads sleep for long periods, while the rest coordinate with busy waiting. If the communication is mostly done via busy waiting, we almost remove the futex wake-up calls from the critical path. Additionally, we let threads sleep for long periods, a requirement for reducing power consumption in sleeping.
<P></P>This optimization comes at the expense of fairness. The longer a thread sleeps while some others progress, the more unfair the lock becomes. We experiment with the extreme case where only two threads communicate via busy waiting, while the rest sleep. Each active thread has a &#8220;quota&#8221; T of busy-waiting repetitions, after which it wakes up another thread to take its turn. Figure 7 shows the power and the communication rate (similar to a lock handover) of sleeping, busy waiting, and spin-then-sleep (ss-T) with various Ts on a single futex. T is the ratio of busy-waiting over futex handovers. 
<P>Figure 7 clearly shows that the more unfair an execution (i.e., for large Ts), the better the energy efficiency. First, larger values of T result in lower power, because the sleep and wake-up futex calls become infrequent, hence the sleeping threads sleep for a long duration. For example, on 10 threads with T = 1000, threads sleep for about 2M cycles. In comparison, with only sleeping, the sleep duration is less than 90000 cycles. Second, spin handovers face minimal contention, as only two threads attempt to &#8220;acquire&#8221; the cache line. Consequently, because most handovers (99.9%) happen with spinning, the latency is very low, resulting in high throughput.