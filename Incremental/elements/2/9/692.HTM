<b> : </b>Sample Output for visualization</H3>I modified the TreeGUI.java code from GitHub to visualize red-black trees I got from my experiments. Due to the visualization code limits, it can only layout and display well for small trees. In my project, I applied the code to display trees with less than 20 nodes. I generated 20 random nodes from 0 to 1000. Then I ran lock-based insertion and lock-free insertion on the same dataset. As we known, different insertion order could result in different red-black trees. Here are one sample output from my experiment. Each figure demonstrates the red-black tree built by their own algorithm and concurrents flow. You can click to enlarge the figures.<BR style="BOX-SIZING: border-box">
<TABLE class="table borderless" style="BOX-SIZING: border-box; MARGIN-BOTTOM: 20px; MAX-WIDTH: 100%; WIDTH: 1170px; BORDER-COLLAPSE: collapse; BORDER-SPACING: 0px; BACKGROUND-COLOR: transparent">
<TBODY style="BOX-SIZING: border-box">
<TR style="BOX-SIZING: border-box">
<TD style="BOX-SIZING: border-box; BORDER-TOP: rgb(221,221,221) 1px solid; BORDER-RIGHT: medium none; VERTICAL-ALIGN: top; BORDER-BOTTOM: medium none; PADDING-BOTTOM: 8px; PADDING-TOP: 8px; PADDING-LEFT: 8px; BORDER-LEFT: medium none; LINE-HEIGHT: 1.4285; PADDING-RIGHT: 8px; border-image: initial"><B style="BOX-SIZING: border-box; FONT-WEIGHT: 700">Lock-Based Algorithm Output</B></TD>
<TD style="BOX-SIZING: border-box; BORDER-TOP: rgb(221,221,221) 1px solid; BORDER-RIGHT: medium none; VERTICAL-ALIGN: top; BORDER-BOTTOM: medium none; PADDING-BOTTOM: 8px; PADDING-TOP: 8px; PADDING-LEFT: 8px; BORDER-LEFT: medium none; LINE-HEIGHT: 1.4285; PADDING-RIGHT: 8px; border-image: initial"><B style="BOX-SIZING: border-box; FONT-WEIGHT: 700">Lock-Free Algorithm Output</B></TD></TR>
<TR style="BOX-SIZING: border-box">
<TD style="BOX-SIZING: border-box; BORDER-TOP: rgb(221,221,221) 1px solid; BORDER-RIGHT: medium none; VERTICAL-ALIGN: top; BORDER-BOTTOM: medium none; PADDING-BOTTOM: 8px; PADDING-TOP: 8px; PADDING-LEFT: 8px; BORDER-LEFT: medium none; LINE-HEIGHT: 1.4285; PADDING-RIGHT: 8px; border-image: initial"><A aria-haspopup=true aria-expanded=false class=ui-link style="BOX-SIZING: border-box; TEXT-DECORATION: none; FONT-WEIGHT: 700; COLOR: rgb(51,136,204); BACKGROUND-COLOR: transparent" aria-owns=locked-tree href="https://xuezhaokun.github.io/150-algorithm/#locked-tree" data-position-to="window" data-rel="popup"><IMG style="BOX-SIZING: border-box; BORDER-TOP: 0px; BORDER-RIGHT: 0px; WIDTH: 284px; VERTICAL-ALIGN: middle; BORDER-BOTTOM: 0px; BORDER-LEFT: 0px" alt="lock based tree demo" src="https://xuezhaokun.github.io/150-algorithm/img/lock_based_tree_drawer.png"></A></TD>
<TD style="BOX-SIZING: border-box; BORDER-TOP: rgb(221,221,221) 1px solid; BORDER-RIGHT: medium none; VERTICAL-ALIGN: top; BORDER-BOTTOM: medium none; PADDING-BOTTOM: 8px; PADDING-TOP: 8px; PADDING-LEFT: 8px; BORDER-LEFT: medium none; LINE-HEIGHT: 1.4285; PADDING-RIGHT: 8px; border-image: initial"><A aria-haspopup=true aria-expanded=false class=ui-link style="BOX-SIZING: border-box; TEXT-DECORATION: none; FONT-WEIGHT: 700; COLOR: rgb(51,136,204); BACKGROUND-COLOR: transparent" aria-owns=lock-free-tree href="https://xuezhaokun.github.io/150-algorithm/#lock-free-tree" data-position-to="window" data-rel="popup"><IMG style="BOX-SIZING: border-box; BORDER-TOP: 0px; BORDER-RIGHT: 0px; WIDTH: 284px; VERTICAL-ALIGN: middle; BORDER-BOTTOM: 0px; BORDER-LEFT: 0px" alt="lock free tree demo" src="https://xuezhaokun.github.io/150-algorithm/img/lock_based_tree_drawer.png"></A></TD></TR></TBODY></TABLE><BR style="BOX-SIZING: border-box">Then I did experiments for comparing the performance of these two kinds of synchronizations. For every experiment, I ran my program 10 times. I collected results from eclipse console output, and imported the data to excel. Finally I calculated the averages and plotted the line charts in excel.