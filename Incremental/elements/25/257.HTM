<P class="CDt4Ke zfr3Q" style='BOX-SIZING: border-box; FONT-SIZE: 11pt; FONT-FAMILY: "Open Sans"; WHITE-SPACE: pre-wrap; WORD-SPACING: 0px; POSITION: relative; TEXT-TRANSFORM: none; FONT-WEIGHT: 400; COLOR: rgb(33,33,33); OUTLINE-WIDTH: medium; FONT-STYLE: normal; OUTLINE-STYLE: none; ORPHANS: 2; WIDOWS: 2; MARGIN: 15px 0px 0px; LETTER-SPACING: normal; OUTLINE-COLOR: invert; LINE-HEIGHT: 1.6; TEXT-INDENT: 0px; font-variant-ligatures: none; text-decoration-line: inherit; text-decoration-thickness: initial; text-decoration-style: initial; text-decoration-color: initial; font-variant-caps: normal; -webkit-text-stroke-width: 0px' dir=ltr>So what are the scalability prerequisites?</P>
<P class="CDt4Ke zfr3Q" style='BOX-SIZING: border-box; FONT-SIZE: 11pt; FONT-FAMILY: "Open Sans"; WHITE-SPACE: pre-wrap; WORD-SPACING: 0px; POSITION: relative; TEXT-TRANSFORM: none; FONT-WEIGHT: 400; COLOR: rgb(33,33,33); OUTLINE-WIDTH: medium; FONT-STYLE: normal; OUTLINE-STYLE: none; ORPHANS: 2; WIDOWS: 2; MARGIN: 15px 0px 0px; LETTER-SPACING: normal; OUTLINE-COLOR: invert; LINE-HEIGHT: 1.6; TEXT-INDENT: 0px; font-variant-ligatures: none; text-decoration-line: inherit; text-decoration-thickness: initial; text-decoration-style: initial; text-decoration-color: initial; font-variant-caps: normal; -webkit-text-stroke-width: 0px' dir=ltr>First, <SPAN style='BOX-SIZING: border-box; FONT-FAMILY: "Open Sans"'><STRONG style="BOX-SIZING: border-box; FONT-WEIGHT: bold; -webkit-font-smoothing: antialiased">no mutexes on fast-paths</STRONG></SPAN> ever (for slow-paths they are Ok, and even recommended because of the usage simplicity). There are several problems with mutexes. Mutexes limit and sacrifice concurrency to provide simplicity (anti-threads, sort of). Then, they provoke write-sharing (cache-coherence traffic) on every operation (even otherwise read-only). So, they just does not scale, forget about them.</P>
<P class="CDt4Ke zfr3Q" style='BOX-SIZING: border-box; FONT-SIZE: 11pt; FONT-FAMILY: "Open Sans"; WHITE-SPACE: pre-wrap; WORD-SPACING: 0px; POSITION: relative; TEXT-TRANSFORM: none; FONT-WEIGHT: 400; COLOR: rgb(33,33,33); OUTLINE-WIDTH: medium; FONT-STYLE: normal; OUTLINE-STYLE: none; ORPHANS: 2; WIDOWS: 2; MARGIN: 15px 0px 0px; LETTER-SPACING: normal; OUTLINE-COLOR: invert; LINE-HEIGHT: 1.6; TEXT-INDENT: 0px; font-variant-ligatures: none; text-decoration-line: inherit; text-decoration-thickness: initial; text-decoration-style: initial; text-decoration-color: initial; font-variant-caps: normal; -webkit-text-stroke-width: 0px' dir=ltr>Second, logically read-only operations must be implemented as a <SPAN style='BOX-SIZING: border-box; FONT-FAMILY: "Open Sans"'><STRONG style="BOX-SIZING: border-box; FONT-WEIGHT: bold; -webkit-font-smoothing: antialiased">physically read-only operations</STRONG></SPAN>. So, what does it mean? During logically read-only operation one should not do any single write to a shared memory location. Note that writes may be hidden inside of some component, in particular most of the reader-writer mutexes do writes to internal state in read_lock()/read_unlock(), such writes are no less harmful. Writes to a shared state provoke cache-coherence traffic, large amounts of which quickly brings any concurrent system to it's knees.</P>
<P class="CDt4Ke zfr3Q" style='BOX-SIZING: border-box; FONT-SIZE: 11pt; FONT-FAMILY: "Open Sans"; WHITE-SPACE: pre-wrap; WORD-SPACING: 0px; POSITION: relative; TEXT-TRANSFORM: none; FONT-WEIGHT: 400; COLOR: rgb(33,33,33); OUTLINE-WIDTH: medium; FONT-STYLE: normal; OUTLINE-STYLE: none; ORPHANS: 2; WIDOWS: 2; MARGIN: 15px 0px 0px; LETTER-SPACING: normal; OUTLINE-COLOR: invert; LINE-HEIGHT: 1.6; TEXT-INDENT: 0px; font-variant-ligatures: none; text-decoration-line: inherit; text-decoration-thickness: initial; text-decoration-style: initial; text-decoration-color: initial; font-variant-caps: normal; -webkit-text-stroke-width: 0px' dir=ltr>Due to specifics of implementation of cache-coherence in modern concurrent hardware (see <SPAN class=" aw5Odc" style="BOX-SIZING: border-box; TEXT-DECORATION: underline; COLOR: "><A class=XqQF9c style="BOX-SIZING: border-box; TEXT-DECORATION: none; COLOR: ; pointer-events: all" href="http://www.google.com/url?q=http%3A%2F%2Fen.wikipedia.org%2Fwiki%2FMOESI_protocol&amp;sa=D&amp;sntz=1&amp;usg=AOvVaw2LMBD6BGCAcH6R0VPbPIlj" target=_blank>MOESI protocol</A></SPAN>), reads to a shared state have 100% scalability (i.e. any number of threads can read from a memory location simultaneously); while writes to a shared state have zero scalability (i.e. at most 1 thread can write to a memory location at any given moment in time).</P>
<P class="CDt4Ke zfr3Q" style='BOX-SIZING: border-box; FONT-SIZE: 11pt; FONT-FAMILY: "Open Sans"; WHITE-SPACE: pre-wrap; WORD-SPACING: 0px; POSITION: relative; TEXT-TRANSFORM: none; FONT-WEIGHT: 400; COLOR: rgb(33,33,33); OUTLINE-WIDTH: medium; FONT-STYLE: normal; OUTLINE-STYLE: none; ORPHANS: 2; WIDOWS: 2; MARGIN: 15px 0px 0px; LETTER-SPACING: normal; OUTLINE-COLOR: invert; LINE-HEIGHT: 1.6; TEXT-INDENT: 0px; font-variant-ligatures: none; text-decoration-line: inherit; text-decoration-thickness: initial; text-decoration-style: initial; text-decoration-color: initial; font-variant-caps: normal; -webkit-text-stroke-width: 0px' dir=ltr>Third, <SPAN style='BOX-SIZING: border-box; FONT-FAMILY: "Open Sans"'><STRONG style="BOX-SIZING: border-box; FONT-WEIGHT: bold; -webkit-font-smoothing: antialiased">no writes to a centralized shared state on fast-paths</STRONG></SPAN>. Writes to a shared state are generally unavoidable for most concurrent data structures. However we can distinguish 4 kinds of a shared state for our needs: