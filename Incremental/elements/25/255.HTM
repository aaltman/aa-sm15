<P class="CDt4Ke zfr3Q" style='BOX-SIZING: border-box; FONT-SIZE: 11pt; FONT-FAMILY: "Open Sans"; WHITE-SPACE: pre-wrap; WORD-SPACING: 0px; POSITION: relative; TEXT-TRANSFORM: none; FONT-WEIGHT: 400; COLOR: rgb(33,33,33); OUTLINE-WIDTH: medium; FONT-STYLE: normal; PADDING-TOP: 0px; OUTLINE-STYLE: none; ORPHANS: 2; WIDOWS: 2; MARGIN: 0px; LETTER-SPACING: normal; OUTLINE-COLOR: invert; LINE-HEIGHT: 1.6; TEXT-INDENT: 0px; font-variant-ligatures: none; text-decoration-line: inherit; text-decoration-thickness: initial; text-decoration-style: initial; text-decoration-color: initial; font-variant-caps: normal; -webkit-text-stroke-width: 0px' dir=ltr><FONT class=extract>Visibility determines when other threads will see changes made by the current thread, and whether they will see them at all. A lot of people endeavour to do something special in order to ensure visibility (like placing memory fences). However, in practice it's the most boring property, because on cache-coherent architectures (read - on all modern commodity architectures - IA-32, Intel 64, IA-64, SPARC, POWER) visibility is ensured automatically. Namely, each write is automatically propagated to all other processors/cores in a best-effort manner. There are no ways to prevent nor to speed it up. Period.</FONT></P>
<P class="CDt4Ke zfr3Q" style='BOX-SIZING: border-box; FONT-SIZE: 11pt; FONT-FAMILY: "Open Sans"; WHITE-SPACE: pre-wrap; WORD-SPACING: 0px; POSITION: relative; TEXT-TRANSFORM: none; FONT-WEIGHT: 400; COLOR: rgb(33,33,33); OUTLINE-WIDTH: medium; FONT-STYLE: normal; OUTLINE-STYLE: none; ORPHANS: 2; WIDOWS: 2; MARGIN: 15px 0px 0px; LETTER-SPACING: normal; OUTLINE-COLOR: invert; LINE-HEIGHT: 1.6; TEXT-INDENT: 0px; font-variant-ligatures: none; text-decoration-line: inherit; text-decoration-thickness: initial; text-decoration-style: initial; text-decoration-color: initial; font-variant-caps: normal; -webkit-text-stroke-width: 0px' dir=ltr>On non cache-coherent architectures changes are indeed not propagated automatically, and you need to do something special. However, such architectures are rare and unique (I saw no such archs), so I think there is no sense in discussing them in general.</P>
<P class="CDt4Ke zfr3Q" style='BOX-SIZING: border-box; FONT-SIZE: 11pt; FONT-FAMILY: "Open Sans"; WHITE-SPACE: pre-wrap; WORD-SPACING: 0px; POSITION: relative; TEXT-TRANSFORM: none; FONT-WEIGHT: 400; COLOR: rgb(33,33,33); OUTLINE-WIDTH: medium; FONT-STYLE: normal; OUTLINE-STYLE: none; ORPHANS: 2; WIDOWS: 2; MARGIN: 15px 0px 0px; LETTER-SPACING: normal; OUTLINE-COLOR: invert; LINE-HEIGHT: 1.6; TEXT-INDENT: 0px; font-variant-ligatures: none; text-decoration-line: inherit; text-decoration-thickness: initial; text-decoration-style: initial; text-decoration-color: initial; font-variant-caps: normal; -webkit-text-stroke-width: 0px' dir=ltr><FONT class=extract>However, there is an interesting deviation to visibility - on x86 architecture non-temporal stores (made with instructions like MOVNTDQ) and stores made to WC (Write-Combining) region of memory are effectively non cache-coherent. That is, they will be propagated to other processors/cores only before execution of SFENCE instruction, MFENCE instruction, LOCKed instruction or other serializing actions.</FONT>