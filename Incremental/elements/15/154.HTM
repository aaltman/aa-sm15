<b> : </b><P class=line862 style="FONT-SIZE: 16px; FONT-FAMILY: sans-serif; WHITE-SPACE: normal; WORD-SPACING: 0px; TEXT-TRANSFORM: none; FONT-WEIGHT: 400; COLOR: rgb(0,0,0); FONT-STYLE: normal; ORPHANS: 2; WIDOWS: 2; LETTER-SPACING: normal; BACKGROUND-COLOR: rgb(255,255,255); TEXT-INDENT: 0px; font-variant-ligatures: normal; font-variant-caps: normal; -webkit-text-stroke-width: 0px; text-decoration-thickness: initial; text-decoration-style: initial; text-decoration-color: initial">In a shared memory model, it may be possible to solve some problems using<SPAN>&nbsp;</SPAN><STRONG>wait-free</STRONG><SPAN>&nbsp;</SPAN>protocols, in which any process can finish the protocol in a bounded number of steps, no matter what the other processes are doing (see<SPAN>&nbsp;</SPAN><A style="TEXT-DECORATION: none; BORDER-TOP: 0px; BORDER-RIGHT: 0px; BORDER-BOTTOM: 0px; COLOR: rgb(68,119,255); BORDER-LEFT: 0px" href="https://www.cs.yale.edu/homes/aspnes/pinewiki/ObstructionFreedom.html">ObstructionFreedom</A><SPAN>&nbsp;</SPAN>for more on this and some variants).<SPAN id=line-4 class=anchor></SPAN><SPAN id=line-5 class=anchor></SPAN></P>
<P class=line862 style="FONT-SIZE: 16px; FONT-FAMILY: sans-serif; WHITE-SPACE: normal; WORD-SPACING: 0px; TEXT-TRANSFORM: none; FONT-WEIGHT: 400; COLOR: rgb(0,0,0); FONT-STYLE: normal; ORPHANS: 2; WIDOWS: 2; LETTER-SPACING: normal; BACKGROUND-COLOR: rgb(255,255,255); TEXT-INDENT: 0px; font-variant-ligatures: normal; font-variant-caps: normal; -webkit-text-stroke-width: 0px; text-decoration-thickness: initial; text-decoration-style: initial; text-decoration-color: initial">The<SPAN>&nbsp;</SPAN><STRONG>wait-free hierarchy</STRONG><SPAN>&nbsp;</SPAN>h<SUP>r</SUP><SUB>m</SUB><SPAN>&nbsp;</SPAN>classifies<SPAN>&nbsp;</SPAN><A style="TEXT-DECORATION: none; BORDER-TOP: 0px; BORDER-RIGHT: 0px; BORDER-BOTTOM: 0px; COLOR: rgb(68,119,255); BORDER-LEFT: 0px" href="https://www.cs.yale.edu/homes/aspnes/pinewiki/AsynchronousSharedMemory.html">AsynchronousSharedMemory</A><SPAN>&nbsp;</SPAN>object types T by<SPAN>&nbsp;</SPAN><STRONG>consensus number</STRONG>, where a type T has consensus number n if with objects of type T and atomic registers (all initialized to appropriate values) it is possible to solve wait-free consensus (i.e., agreement, validity, wait-free termination) for n processes but not for n+1 processes. The consensus number of any type is at least 1, since 1-process consensus requires no interaction, and may range up to &#8734; for particularly powerful objects.<SPAN id=line-6 class=anchor></SPAN><SPAN id=line-7 class=anchor></SPAN></P>
<P class=line862 style="FONT-SIZE: 16px; FONT-FAMILY: sans-serif; WHITE-SPACE: normal; WORD-SPACING: 0px; TEXT-TRANSFORM: none; FONT-WEIGHT: 400; COLOR: rgb(0,0,0); FONT-STYLE: normal; ORPHANS: 2; WIDOWS: 2; LETTER-SPACING: normal; BACKGROUND-COLOR: rgb(255,255,255); TEXT-INDENT: 0px; font-variant-ligatures: normal; font-variant-caps: normal; -webkit-text-stroke-width: 0px; text-decoration-thickness: initial; text-decoration-style: initial; text-decoration-color: initial">The wait-free hierarchy was suggested by work by Maurice Herlihy<SPAN>&nbsp;</SPAN><A class=http style="TEXT-DECORATION: none; BORDER-TOP: 0px; BORDER-RIGHT: 0px; BORDER-BOTTOM: 0px; COLOR: rgb(68,119,255); BORDER-LEFT: 0px" href="http://portal.acm.org/citation.cfm?id=114005.102808&amp;dl=portal&amp;dl=ACM&amp;idx=114005&amp;part=periodical&amp;WantType=periodical&amp;title=ACM%20Transactions%20on%20Programming%20Languages%20and%20Systems%20%28TOPLAS%29&amp;CFID=56500239&amp;CFTOKEN=49560823">Wait-free synchronization, TOPLAS 13(1):124-149</A><SPAN>&nbsp;</SPAN>that classified many common (and some uncommon) shared-memory objects by consensus number, and showed that an unbounded collection of objects with consensus number n together with atomic registers gives a wait-free implementation of any object in an n-process system. Various subsequent authors noticed that this did not give a "robust" hierarchy in the sense that combining two types of objects with consensus number n could solve wait-free consensus for larger n, and the hierarchy h<SUP>r</SUP><SUB>m</SUB><SPAN>&nbsp;</SPAN>was proposed by Prasad Jayanti<SPAN>&nbsp;</SPAN><A class=http style="TEXT-DECORATION: none; BORDER-TOP: 0px; BORDER-RIGHT: 0px; BORDER-BOTTOM: 0px; COLOR: rgb(68,119,255); BORDER-LEFT: 0px" href="http://portal.acm.org/citation.cfm?id=263888">Jayanti, Robust wait-free hierarchies, JACM 44(4):592-614, 1997</A><SPAN>&nbsp;</SPAN>as a way of classifying objects that might be robust: an object is at level n of the h<SUP>r</SUP><SUB>m</SUB><SPAN>&nbsp;</SPAN>hierarchy if having unboundedly many objects plus unboundedly many registers solves n-process wait-free consensus but not (n+1)-process wait-free consensus. Whether or not the resulting hierarchy is in fact robust for arbitrary deterministic objects is still open, but Eric Ruppert<SPAN>&nbsp;</SPAN><A class=http style="TEXT-DECORATION: none; BORDER-TOP: 0px; BORDER-RIGHT: 0px; BORDER-BOTTOM: 0px; COLOR: rgb(68,119,255); BORDER-LEFT: 0px" href="http://epubs.siam.org/sam-bin/dbq/article/32943">Ruppert, Determining consensus numbers, SICOMP 30(4):1156-1168, 2000</A><SPAN>&nbsp;</SPAN>subsequently showed that it is robust for RMW registers and objects with a read operation that returns the current state, and there is a paper by Borowsky, Gafni, and Afek (<A class=http style="TEXT-DECORATION: none; BORDER-TOP: 0px; BORDER-RIGHT: 0px; BORDER-BOTTOM: 0px; COLOR: rgb(68,119,255); BORDER-LEFT: 0px" href="http://portal.acm.org/citation.cfm?id=198126&amp;dl=GUIDE&amp;coll=GUIDE&amp;CFID=56558675&amp;CFTOKEN=97060299">Consensus power makes (some) sense! (extended abstract), PODC 1994</A>) that sketches a proof based on a topological characterization of computability that h<SUP>r</SUP><SUB>m</SUB><SPAN>&nbsp;</SPAN>is robust for deterministic objects that don't discriminate between processes (unlike, say, single-writer registers). So for well-behaved shared-memory objects (i.e., deterministic, symmetrically accessible, with read operations, etc.), consensus number appears to give a real classification that allows us to say for example that any collection of read-write registers (consensus number 1), fetch-and-increments (2), test-and-set bits (2), and queues (2) is not enough to build a compare-and-swap (&#8734;).<SPAN id=line-8 class=anchor></SPAN><SPAN id=line-9 class=anchor></SPAN></P>
<P class=line862 style="FONT-SIZE: 16px; FONT-FAMILY: sans-serif; WHITE-SPACE: normal; WORD-SPACING: 0px; TEXT-TRANSFORM: none; FONT-WEIGHT: 400; COLOR: rgb(0,0,0); FONT-STYLE: normal; ORPHANS: 2; WIDOWS: 2; LETTER-SPACING: normal; BACKGROUND-COLOR: rgb(255,255,255); TEXT-INDENT: 0px; font-variant-ligatures: normal; font-variant-caps: normal; -webkit-text-stroke-width: 0px; text-decoration-thickness: initial; text-decoration-style: initial; text-decoration-color: initial">We won't do the full robustness proofs of Borowsky et al or Ruppert that let us get away with this. Instead, we'll concentrate on Herlihy's original results and show that specific objects have specific consensus numbers when used in isolation. The procedure in each case will be to show an upper bound on the consensus number using a variant of<SPAN>&nbsp;</SPAN><A style="TEXT-DECORATION: none; BORDER-TOP: 0px; BORDER-RIGHT: 0px; BORDER-BOTTOM: 0px; COLOR: rgb(68,119,255); BORDER-LEFT: 0px" href="https://www.cs.yale.edu/homes/aspnes/pinewiki/FischerLynchPaterson.html">FischerLynchPaterson</A><SPAN>&nbsp;</SPAN>(made easier because we are wait-free and don't have to worry about fairness) and then show a matching lower bound (for non-trivial upper bounds) by exhibiting an n-process consensus protocol for some n. Essentially everything below is taken from Herlihy's paper, so reading that may make more sense than reading these notes.<SPAN id=line-10 class=anchor></SPAN><SPAN id=line-11 class=anchor></SPAN></P>
<P class=line867 style="FONT-SIZE: 16px; FONT-FAMILY: sans-serif; WHITE-SPACE: normal; WORD-SPACING: 0px; TEXT-TRANSFORM: none; FONT-WEIGHT: 400; COLOR: rgb(0,0,0); FONT-STYLE: normal; ORPHANS: 2; WIDOWS: 2; LETTER-SPACING: normal; BACKGROUND-COLOR: rgb(255,255,255); TEXT-INDENT: 0px; font-variant-ligatures: normal; font-variant-caps: normal; -webkit-text-stroke-width: 0px; text-decoration-thickness: initial; text-decoration-style: initial; text-decoration-color: initial">