<b> : </b>1.2. Level 2: interfering RMW objects that return the old value, queues (without peek)</H2><SPAN id=line-46 class=anchor style="FONT-SIZE: 16px; FONT-FAMILY: sans-serif; WHITE-SPACE: normal; WORD-SPACING: 0px; TEXT-TRANSFORM: none; FONT-WEIGHT: 400; COLOR: rgb(0,0,0); FONT-STYLE: normal; ORPHANS: 2; WIDOWS: 2; LETTER-SPACING: normal; BACKGROUND-COLOR: rgb(255,255,255); TEXT-INDENT: 0px; font-variant-ligatures: normal; font-variant-caps: normal; -webkit-text-stroke-width: 0px; text-decoration-thickness: initial; text-decoration-style: initial; text-decoration-color: initial"></SPAN><SPAN id=line-47 class=anchor style="FONT-SIZE: 16px; FONT-FAMILY: sans-serif; WHITE-SPACE: normal; WORD-SPACING: 0px; TEXT-TRANSFORM: none; FONT-WEIGHT: 400; COLOR: rgb(0,0,0); FONT-STYLE: normal; ORPHANS: 2; WIDOWS: 2; LETTER-SPACING: normal; BACKGROUND-COLOR: rgb(255,255,255); TEXT-INDENT: 0px; font-variant-ligatures: normal; font-variant-caps: normal; -webkit-text-stroke-width: 0px; text-decoration-thickness: initial; text-decoration-style: initial; text-decoration-color: initial"></SPAN>
<P class=line862 style="FONT-SIZE: 16px; FONT-FAMILY: sans-serif; WHITE-SPACE: normal; WORD-SPACING: 0px; TEXT-TRANSFORM: none; FONT-WEIGHT: 400; COLOR: rgb(0,0,0); FONT-STYLE: normal; ORPHANS: 2; WIDOWS: 2; LETTER-SPACING: normal; BACKGROUND-COLOR: rgb(255,255,255); TEXT-INDENT: 0px; font-variant-ligatures: normal; font-variant-caps: normal; -webkit-text-stroke-width: 0px; text-decoration-thickness: initial; text-decoration-style: initial; text-decoration-color: initial">Suppose now that we have a RMW object that returns the old value, and suppose that it is<SPAN>&nbsp;</SPAN><EM>non-trivial</EM><SPAN>&nbsp;</SPAN>in the sense that it has at least one RMW operation where the embedded function f that determines the new value is not the identity (otherwise RMW is just read). Then there is some value v such that f(v) &#8800; v. To solve two-process consensus, have each process p<SUB>i</SUB><SPAN>&nbsp;</SPAN>first write its preferred value to a register r<SUB>i</SUB>, then execute the non-trivial RMW operation on the RMW object initialized to v. The first process in sees v and decides its own value. The second process sees f(v) and decides the first process's value (which it reads from the register). It follows that non-trivial RMW object has consensus number<SPAN>&nbsp;</SPAN><EM>at least</EM><SPAN>&nbsp;</SPAN>2.<SPAN id=line-48 class=anchor></SPAN><SPAN id=line-49 class=anchor></SPAN></P>
<P class=line874 style="FONT-SIZE: 16px; FONT-FAMILY: sans-serif; WHITE-SPACE: normal; WORD-SPACING: 0px; TEXT-TRANSFORM: none; FONT-WEIGHT: 400; COLOR: rgb(0,0,0); FONT-STYLE: normal; ORPHANS: 2; WIDOWS: 2; LETTER-SPACING: normal; BACKGROUND-COLOR: rgb(255,255,255); TEXT-INDENT: 0px; font-variant-ligatures: normal; font-variant-caps: normal; -webkit-text-stroke-width: 0px; text-decoration-thickness: initial; text-decoration-style: initial; text-decoration-color: initial">In many cases, this is all we get. Suppose that the operations of some RMW type T are interfering in a way analogous to the previous definition, where now we say that x and y commute if they leave the object in the same state (regardless of what values are returned) and that y overwrites x if the object is always in the same state after both x and xy (again regardless of what is returned). The two processes that carry out x and y know what happenened, but a third process z doesn't. So if we run z to completion we get the same decision value after both Cx and Cy, which means that Cx and Cy can't be 0-valent and 1-valent. It follows that no collection of RMW registers with interfering operations can solve 3-process consensus, and thus all such objects have consensus number 2.<SPAN id=line-50 class=anchor></SPAN><SPAN id=line-51 class=anchor></SPAN></P>
<P class=line862 style="FONT-SIZE: 16px; FONT-FAMILY: sans-serif; WHITE-SPACE: normal; WORD-SPACING: 0px; TEXT-TRANSFORM: none; FONT-WEIGHT: 400; COLOR: rgb(0,0,0); FONT-STYLE: normal; ORPHANS: 2; WIDOWS: 2; LETTER-SPACING: normal; BACKGROUND-COLOR: rgb(255,255,255); TEXT-INDENT: 0px; font-variant-ligatures: normal; font-variant-caps: normal; -webkit-text-stroke-width: 0px; text-decoration-thickness: initial; text-decoration-style: initial; text-decoration-color: initial">There are some other objects with consensus number 2 that don't fit this pattern. Define a<SPAN>&nbsp;</SPAN><STRONG>wait-free queue</STRONG><SPAN>&nbsp;</SPAN>as an object with enqueue and dequeue operations (like normal queues), where dequeue returns empty if the queue is empty (instead of blocking). To solve 2-process consensus with a wait-free queue, initialize the queue with a single value (it doesn't matter what the value is). We can then treat the queue as a non-trivial RMW register where a process wins if it successfully dequeues the initial value and loses if it gets empty.<SPAN id=line-52 class=anchor></SPAN><SPAN id=line-53 class=anchor></SPAN></P>
<P class=line862 style="FONT-SIZE: 16px; FONT-FAMILY: sans-serif; WHITE-SPACE: normal; WORD-SPACING: 0px; TEXT-TRANSFORM: none; FONT-WEIGHT: 400; COLOR: rgb(0,0,0); FONT-STYLE: normal; ORPHANS: 2; WIDOWS: 2; LETTER-SPACING: normal; BACKGROUND-COLOR: rgb(255,255,255); TEXT-INDENT: 0px; font-variant-ligatures: normal; font-variant-caps: normal; -webkit-text-stroke-width: 0px; text-decoration-thickness: initial; text-decoration-style: initial; text-decoration-color: initial">However, enqueue operations are non-interfering: if p<SUB>x</SUB><SPAN>&nbsp;</SPAN>enqueues v<SUB>x</SUB><SPAN>&nbsp;</SPAN>and p<SUB>y</SUB><SPAN>&nbsp;</SPAN>enqueues v<SUB>y</SUB>, then any third process can detect which happened first; similarly we can distinguish enq(x) deq() from deq() enq(x). So to show we can't do three process consensus we do something sneakier: given a bivalent state C with allegedly 0- and 1-valent successors C enq(x) and C enq(y), consider both C enq(x) enq(y) and C enq(y) enq(x) and run x until it does a deq() (which it must, because otherwise it can't tell what to decide) and then stop it. Now run y until it also does a deq() and then stop it. We've now destroyed the evidence of the split and poor hapless z is stuck. In the case of C deq() enq(x) and C enq(x) deq() on a non-empty queue we can kill the initial dequeuer immediately and then kill whoever dequeues x or the value it replaced, and if the queue is empty only the dequeuer knows. In either case we reach indistinguishable states after killing only 2 witnesses, and the queue has number &#8804; 2.<SPAN id=line-54 class=anchor></SPAN><SPAN id=line-55 class=anchor></SPAN></P>
<P class=line874 style="FONT-SIZE: 16px; FONT-FAMILY: sans-serif; WHITE-SPACE: normal; WORD-SPACING: 0px; TEXT-TRANSFORM: none; FONT-WEIGHT: 400; COLOR: rgb(0,0,0); FONT-STYLE: normal; ORPHANS: 2; WIDOWS: 2; LETTER-SPACING: normal; BACKGROUND-COLOR: rgb(255,255,255); TEXT-INDENT: 0px; font-variant-ligatures: normal; font-variant-caps: normal; -webkit-text-stroke-width: 0px; text-decoration-thickness: initial; text-decoration-style: initial; text-decoration-color: initial">Similar arguments work on stacks, deques, and so forth&#8212;these all have consensus number exactly 2.<SPAN id=line-56 class=anchor></SPAN><SPAN id=line-57 class=anchor></SPAN></P>
<P class=line867 style="FONT-SIZE: 16px; FONT-FAMILY: sans-serif; WHITE-SPACE: normal; WORD-SPACING: 0px; TEXT-TRANSFORM: none; FONT-WEIGHT: 400; COLOR: rgb(0,0,0); FONT-STYLE: normal; ORPHANS: 2; WIDOWS: 2; LETTER-SPACING: normal; BACKGROUND-COLOR: rgb(255,255,255); TEXT-INDENT: 0px; font-variant-ligatures: normal; font-variant-caps: normal; -webkit-text-stroke-width: 0px; text-decoration-thickness: initial; text-decoration-style: initial; text-decoration-color: initial">