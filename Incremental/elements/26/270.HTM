<DIV id=BTREE-STRUCTURE class=sect2 style='BOX-SIZING: border-box; FONT-SIZE: 14px; FONT-FAMILY: "Open Sans", sans-serif; WHITE-SPACE: normal; WORD-SPACING: 0px; TEXT-TRANSFORM: none; FONT-WEIGHT: 400; COLOR: rgb(0,0,0); FONT-STYLE: normal; TEXT-ALIGN: left; ORPHANS: 2; WIDOWS: 2; LETTER-SPACING: normal; TEXT-INDENT: 0px; font-variant-ligatures: normal; font-variant-caps: normal; -webkit-text-stroke-width: 0px; text-decoration-thickness: initial; text-decoration-style: initial; text-decoration-color: initial'>
<DIV class=titlepage style="BOX-SIZING: border-box">
<DIV style="BOX-SIZING: border-box">
<DIV style="BOX-SIZING: border-box">
<H3 class=title style='BOX-SIZING: border-box; FONT-SIZE: 1.4em; FONT-FAMILY: "Open Sans", sans-serif; COLOR: ; MARGIN: 1em 0px; DISPLAY: block; LINE-HEIGHT: 1.2'><FONT class=extract>67.4.1.&nbsp;B-Tree Structure<SPAN>&nbsp;</SPAN></FONT><A class=id_link style="BOX-SIZING: border-box; TEXT-DECORATION: none; FONT-WEIGHT: 600; COLOR: ; VISIBILITY: hidden; BACKGROUND-COLOR: transparent; transition: color 0.2s ease-in-out" href="https://www.postgresql.org/docs/current/btree-implementation.html#BTREE-STRUCTURE"></A></H3></DIV></DIV></DIV>
<P style="BOX-SIZING: border-box; MARGIN-TOP: 0px"><FONT class=extract><SPAN class=productname style="BOX-SIZING: border-box">PostgreSQL</SPAN><SPAN>&nbsp;</SPAN>B-Tree indexes are multi-level tree structures, where each level of the tree can be used as a doubly-linked list of pages. A single metapage is stored in a fixed position at the start of the first segment file of the index. All other pages are either leaf pages or internal pages. Leaf pages are the pages on the lowest level of the tree. All other levels consist of internal pages. Each leaf page contains tuples that point to table rows. Each internal page contains tuples that point to the next level down in the tree. Typically, over 99% of all pages are leaf pages. Both internal pages and leaf pages use the standard page format described in<SPAN>&nbsp;</SPAN></FONT><A title="73.6.&nbsp;Database Page Layout" class=xref style="BOX-SIZING: border-box; TEXT-DECORATION: none; FONT-WEIGHT: 600; COLOR: ; BACKGROUND-COLOR: transparent; transition: color 0.2s ease-in-out" href="https://www.postgresql.org/docs/current/storage-page-layout.html"><FONT class=extract>Section&nbsp;73.6</FONT></A><FONT class=extract>.</FONT></P>
<P style="BOX-SIZING: border-box; MARGIN-TOP: 0px"><FONT class=extract>New leaf pages are added to a B-Tree index when an existing leaf page cannot fit an incoming tuple. A<SPAN>&nbsp;</SPAN><EM class=firstterm style="BOX-SIZING: border-box; FONT-STYLE: italic">page split</EM><SPAN>&nbsp;</SPAN>operation makes room for items that originally belonged on the overflowing page by moving a portion of the items to a new page. Page splits must also insert a new<SPAN>&nbsp;</SPAN><EM class=firstterm style="BOX-SIZING: border-box; FONT-STYLE: italic">downlink</EM><SPAN>&nbsp;</SPAN>to the new page in the parent page, which may cause the parent to split in turn. Page splits<SPAN>&nbsp;</SPAN><SPAN class=quote style="BOX-SIZING: border-box">&#8220;<SPAN class=quote style="BOX-SIZING: border-box">cascade upwards</SPAN>&#8221;</SPAN><SPAN>&nbsp;</SPAN>in a recursive fashion. When the root page finally cannot fit a new downlink, a<SPAN>&nbsp;</SPAN><EM class=firstterm style="BOX-SIZING: border-box; FONT-STYLE: italic">root page split</EM><SPAN>&nbsp;</SPAN>operation takes place. This adds a new level to the tree structure by creating a new root page that is one level above the original root page.</FONT></P></DIV>
<DIV id=BTREE-DELETION class=sect2 style='BOX-SIZING: border-box; FONT-SIZE: 14px; FONT-FAMILY: "Open Sans", sans-serif; WHITE-SPACE: normal; WORD-SPACING: 0px; TEXT-TRANSFORM: none; FONT-WEIGHT: 400; COLOR: rgb(0,0,0); FONT-STYLE: normal; TEXT-ALIGN: left; ORPHANS: 2; WIDOWS: 2; LETTER-SPACING: normal; TEXT-INDENT: 0px; font-variant-ligatures: normal; font-variant-caps: normal; -webkit-text-stroke-width: 0px; text-decoration-thickness: initial; text-decoration-style: initial; text-decoration-color: initial'>
<DIV class=titlepage style="BOX-SIZING: border-box">
<DIV style="BOX-SIZING: border-box">
<DIV style="BOX-SIZING: border-box">
<H3 class=title style='BOX-SIZING: border-box; FONT-SIZE: 1.4em; FONT-FAMILY: "Open Sans", sans-serif; COLOR: ; MARGIN: 1em 0px; DISPLAY: block; LINE-HEIGHT: 1.2'><FONT class=extract>67.4.2.&nbsp;Bottom-up Index Deletion<SPAN>&nbsp;</SPAN></FONT><A class=id_link style="BOX-SIZING: border-box; TEXT-DECORATION: none; FONT-WEIGHT: 600; COLOR: ; VISIBILITY: hidden; BACKGROUND-COLOR: transparent; transition: color 0.2s ease-in-out" href="https://www.postgresql.org/docs/current/btree-implementation.html#BTREE-DELETION"></A></H3></DIV></DIV></DIV>
<P style="BOX-SIZING: border-box; MARGIN-TOP: 0px"><FONT class=extract>B-Tree indexes are not directly aware that under MVCC, there might be multiple extant versions of the same logical table row; to an index, each tuple is an independent object that needs its own index entry.<SPAN>&nbsp;</SPAN><SPAN class=quote style="BOX-SIZING: border-box">&#8220;<SPAN class=quote style="BOX-SIZING: border-box">Version churn</SPAN>&#8221;</SPAN><SPAN>&nbsp;</SPAN>tuples may sometimes accumulate and adversely affect query latency and throughput. This typically occurs with<SPAN>&nbsp;</SPAN><CODE class=command style="BOX-SIZING: border-box; FONT-SIZE: 1em; FONT-FAMILY: monospace, monospace; MARGIN-TOP: 0px; FONT-WEIGHT: 400; COLOR:  !important; MARGIN-LEFT: 0px; MARGIN-RIGHT: 0px; overflow-wrap: break-word; border-radius: 0.25rem">UPDATE</CODE>-heavy workloads where most individual updates cannot apply the<SPAN>&nbsp;</SPAN></FONT><A title="73.7.&nbsp;Heap-Only Tuples (HOT)" class=link style="BOX-SIZING: border-box; TEXT-DECORATION: none; FONT-WEIGHT: 600; COLOR: ; BACKGROUND-COLOR: transparent; transition: color 0.2s ease-in-out" href="https://www.postgresql.org/docs/current/storage-hot.html"><FONT class=extract><ACRONYM class=acronym style="BOX-SIZING: border-box">HOT</ACRONYM><SPAN>&nbsp;</SPAN>optimization.</FONT></A><FONT class=extract><SPAN>&nbsp;</SPAN>Changing the value of only one column covered by one index during an<SPAN>&nbsp;</SPAN><CODE class=command style="BOX-SIZING: border-box; FONT-SIZE: 1em; FONT-FAMILY: monospace, monospace; MARGIN-TOP: 0px; FONT-WEIGHT: 400; COLOR:  !important; MARGIN-LEFT: 0px; MARGIN-RIGHT: 0px; overflow-wrap: break-word; border-radius: 0.25rem">UPDATE</CODE><SPAN>&nbsp;</SPAN><SPAN class=emphasis style="BOX-SIZING: border-box"><EM style="BOX-SIZING: border-box; FONT-STYLE: italic">always</EM></SPAN><SPAN>&nbsp;</SPAN>necessitates a new set of index tuples &#8212; one for<SPAN>&nbsp;</SPAN><SPAN class=emphasis style="BOX-SIZING: border-box"><EM style="BOX-SIZING: border-box; FONT-STYLE: italic">each and every</EM></SPAN><SPAN>&nbsp;</SPAN>index on the table. Note in particular that this includes indexes that were not<SPAN>&nbsp;</SPAN><SPAN class=quote style="BOX-SIZING: border-box">&#8220;<SPAN class=quote style="BOX-SIZING: border-box">logically modified</SPAN>&#8221;</SPAN><SPAN>&nbsp;</SPAN>by the<SPAN>&nbsp;</SPAN><CODE class=command style="BOX-SIZING: border-box; FONT-SIZE: 1em; FONT-FAMILY: monospace, monospace; MARGIN-TOP: 0px; FONT-WEIGHT: 400; COLOR:  !important; MARGIN-LEFT: 0px; MARGIN-RIGHT: 0px; overflow-wrap: break-word; border-radius: 0.25rem">UPDATE</CODE>. All indexes will need a successor physical index tuple that points to the latest version in the table. Each new tuple within each index will generally need to coexist with the original<SPAN>&nbsp;</SPAN><SPAN class=quote style="BOX-SIZING: border-box">&#8220;<SPAN class=quote style="BOX-SIZING: border-box">updated</SPAN>&#8221;</SPAN><SPAN>&nbsp;</SPAN>tuple for a short period of time (typically until shortly after the<SPAN>&nbsp;</SPAN><CODE class=command style="BOX-SIZING: border-box; FONT-SIZE: 1em; FONT-FAMILY: monospace, monospace; MARGIN-TOP: 0px; FONT-WEIGHT: 400; COLOR:  !important; MARGIN-LEFT: 0px; MARGIN-RIGHT: 0px; overflow-wrap: break-word; border-radius: 0.25rem">UPDATE</CODE><SPAN>&nbsp;</SPAN>transaction commits).</FONT></P>
<P style="BOX-SIZING: border-box; MARGIN-TOP: 0px"><FONT class=extract>B-Tree indexes incrementally delete version churn index tuples by performing<SPAN>&nbsp;</SPAN><EM class=firstterm style="BOX-SIZING: border-box; FONT-STYLE: italic">bottom-up index deletion</EM><SPAN>&nbsp;</SPAN>passes. Each deletion pass is triggered in reaction to an anticipated<SPAN>&nbsp;</SPAN><SPAN class=quote style="BOX-SIZING: border-box">&#8220;<SPAN class=quote style="BOX-SIZING: border-box">version churn page split</SPAN>&#8221;</SPAN>. This only happens with indexes that are not logically modified by<SPAN>&nbsp;</SPAN><CODE class=command style="BOX-SIZING: border-box; FONT-SIZE: 1em; FONT-FAMILY: monospace, monospace; MARGIN-TOP: 0px; FONT-WEIGHT: 400; COLOR:  !important; MARGIN-LEFT: 0px; MARGIN-RIGHT: 0px; overflow-wrap: break-word; border-radius: 0.25rem">UPDATE</CODE><SPAN>&nbsp;</SPAN>statements, where concentrated build up of obsolete versions in particular pages would occur otherwise. A page split will usually be avoided, though it's possible that certain implementation-level heuristics will fail to identify and delete even one garbage index tuple (in which case a page split or deduplication pass resolves the issue of an incoming new tuple not fitting on a leaf page). The worst-case number of versions that any index scan must traverse (for any single logical row) is an important contributor to overall system responsiveness and throughput. A bottom-up index deletion pass targets suspected garbage tuples in a single leaf page based on<SPAN>&nbsp;</SPAN><SPAN class=emphasis style="BOX-SIZING: border-box"><EM style="BOX-SIZING: border-box; FONT-STYLE: italic">qualitative</EM></SPAN><SPAN>&nbsp;</SPAN>distinctions involving logical rows and versions. This contrasts with the<SPAN>&nbsp;</SPAN><SPAN class=quote style="BOX-SIZING: border-box">&#8220;<SPAN class=quote style="BOX-SIZING: border-box">top-down</SPAN>&#8221;</SPAN><SPAN>&nbsp;</SPAN>index cleanup performed by autovacuum workers, which is triggered when certain<SPAN>&nbsp;</SPAN><SPAN class=emphasis style="BOX-SIZING: border-box"><EM style="BOX-SIZING: border-box; FONT-STYLE: italic">quantitative</EM></SPAN><SPAN>&nbsp;</SPAN>table-level thresholds are exceeded (see<SPAN>&nbsp;</SPAN></FONT><A title="25.1.6.&nbsp;The Autovacuum Daemon" class=xref style="BOX-SIZING: border-box; TEXT-DECORATION: none; FONT-WEIGHT: 600; COLOR: ; BACKGROUND-COLOR: transparent; transition: color 0.2s ease-in-out" href="https://www.postgresql.org/docs/current/routine-vacuuming.html#AUTOVACUUM"><FONT class=extract>Section&nbsp;25.1.6</FONT></A><FONT class=extract>).</FONT></P>
<DIV class=note style="BOX-SIZING: border-box; BORDER-TOP: 1px solid; BORDER-RIGHT: 1px solid; BORDER-BOTTOM: 1px solid; PADDING-TOP: 1px; PADDING-LEFT: 1px; BORDER-LEFT: 1px solid; MARGIN: 4ex auto; PADDING-RIGHT: 1px; border-radius: 8px">
<H3 class=title style='BOX-SIZING: border-box; FONT-SIZE: 1.4em; FONT-FAMILY: "Open Sans", sans-serif; MARGIN-TOP: 0px; COLOR: ; TEXT-ALIGN: center; MARGIN-LEFT: 0px; DISPLAY: block; LINE-HEIGHT: 1.2; MARGIN-RIGHT: 0px'><FONT class=extract>Note</FONT></H3>
<P style="BOX-SIZING: border-box; MARGIN-TOP: 0px"><FONT class=extract>Not all deletion operations that are performed within B-Tree indexes are bottom-up deletion operations. There is a distinct category of index tuple deletion:<SPAN>&nbsp;</SPAN><EM class=firstterm style="BOX-SIZING: border-box; FONT-STYLE: italic">simple index tuple deletion</EM>. This is a deferred maintenance operation that deletes index tuples that are known to be safe to delete (those whose item identifier's<SPAN>&nbsp;</SPAN><CODE class=literal style="BOX-SIZING: border-box; FONT-SIZE: 1em; BORDER-TOP: medium none; FONT-FAMILY: monospace, monospace; BORDER-RIGHT: medium none; MARGIN-TOP: 0px; BORDER-BOTTOM: medium none; FONT-WEIGHT: 400; COLOR:  !important; PADDING-BOTTOM: 0px !important; PADDING-TOP: 0px !important; PADDING-LEFT: 0px !important; MARGIN-LEFT: 0px; BORDER-LEFT: medium none; PADDING-RIGHT: 0px !important; MARGIN-RIGHT: 0px; overflow-wrap: break-word; border-radius: 0.25rem">LP_DEAD</CODE><SPAN>&nbsp;</SPAN>bit is already set). Like bottom-up index deletion, simple index deletion takes place at the point that a page split is anticipated as a way of avoiding the split.</FONT></P>
<P style="BOX-SIZING: border-box; MARGIN-BOTTOM: 0px !important; MARGIN-TOP: 0px"><FONT class=extract>Simple deletion is opportunistic in the sense that it can only take place when recent index scans set the<SPAN>&nbsp;</SPAN><CODE class=literal style="BOX-SIZING: border-box; FONT-SIZE: 1em; BORDER-TOP: medium none; FONT-FAMILY: monospace, monospace; BORDER-RIGHT: medium none; MARGIN-TOP: 0px; BORDER-BOTTOM: medium none; FONT-WEIGHT: 400; COLOR:  !important; PADDING-BOTTOM: 0px !important; PADDING-TOP: 0px !important; PADDING-LEFT: 0px !important; MARGIN-LEFT: 0px; BORDER-LEFT: medium none; PADDING-RIGHT: 0px !important; MARGIN-RIGHT: 0px; overflow-wrap: break-word; border-radius: 0.25rem">LP_DEAD</CODE><SPAN>&nbsp;</SPAN>bits of affected items in passing. Prior to<SPAN>&nbsp;</SPAN><SPAN class=productname style="BOX-SIZING: border-box">PostgreSQL</SPAN><SPAN>&nbsp;</SPAN>14, the only category of B-Tree deletion was simple deletion. The main differences between it and bottom-up deletion are that only the former is opportunistically driven by the activity of passing index scans, while only the latter specifically targets version churn from<SPAN>&nbsp;</SPAN><CODE class=command style="BOX-SIZING: border-box; FONT-SIZE: 1em; BORDER-TOP: medium none; FONT-FAMILY: monospace, monospace; BORDER-RIGHT: medium none; MARGIN-TOP: 0px; BORDER-BOTTOM: medium none; FONT-WEIGHT: 400; COLOR:  !important; PADDING-BOTTOM: 0px !important; PADDING-TOP: 0px !important; PADDING-LEFT: 0px !important; MARGIN-LEFT: 0px; BORDER-LEFT: medium none; PADDING-RIGHT: 0px !important; MARGIN-RIGHT: 0px; overflow-wrap: break-word; border-radius: 0.25rem">UPDATE</CODE>s that do not logically modify indexed columns.</FONT></P></DIV>
<P style="BOX-SIZING: border-box; MARGIN-TOP: 0px"><FONT class=extract>Bottom-up index deletion performs the vast majority of all garbage index tuple cleanup for particular indexes with certain workloads. This is expected with any B-Tree index that is subject to significant version churn from<SPAN>&nbsp;</SPAN><CODE class=command style="BOX-SIZING: border-box; FONT-SIZE: 1em; FONT-FAMILY: monospace, monospace; MARGIN-TOP: 0px; FONT-WEIGHT: 400; COLOR:  !important; MARGIN-LEFT: 0px; MARGIN-RIGHT: 0px; overflow-wrap: break-word; border-radius: 0.25rem">UPDATE</CODE>s that rarely or never logically modify the columns that the index covers. The average and worst-case number of versions per logical row can be kept low purely through targeted incremental deletion passes. It's quite possible that the on-disk size of certain indexes will never increase by even one single page/block despite<SPAN>&nbsp;</SPAN><SPAN class=emphasis style="BOX-SIZING: border-box"><EM style="BOX-SIZING: border-box; FONT-STYLE: italic">constant</EM></SPAN><SPAN>&nbsp;</SPAN>version churn from<SPAN>&nbsp;</SPAN><CODE class=command style="BOX-SIZING: border-box; FONT-SIZE: 1em; FONT-FAMILY: monospace, monospace; MARGIN-TOP: 0px; FONT-WEIGHT: 400; COLOR:  !important; MARGIN-LEFT: 0px; MARGIN-RIGHT: 0px; overflow-wrap: break-word; border-radius: 0.25rem">UPDATE</CODE>s. Even then, an exhaustive<SPAN>&nbsp;</SPAN><SPAN class=quote style="BOX-SIZING: border-box">&#8220;<SPAN class=quote style="BOX-SIZING: border-box">clean sweep</SPAN>&#8221;</SPAN><SPAN>&nbsp;</SPAN>by a<SPAN>&nbsp;</SPAN><CODE class=command style="BOX-SIZING: border-box; FONT-SIZE: 1em; FONT-FAMILY: monospace, monospace; MARGIN-TOP: 0px; FONT-WEIGHT: 400; COLOR:  !important; MARGIN-LEFT: 0px; MARGIN-RIGHT: 0px; overflow-wrap: break-word; border-radius: 0.25rem">VACUUM</CODE><SPAN>&nbsp;</SPAN>operation (typically run in an autovacuum worker process) will eventually be required as a part of<SPAN>&nbsp;</SPAN><SPAN class=emphasis style="BOX-SIZING: border-box"><EM style="BOX-SIZING: border-box; FONT-STYLE: italic">collective</EM></SPAN><SPAN>&nbsp;</SPAN>cleanup of the table and each of its indexes.</FONT></P>
<P style="BOX-SIZING: border-box; MARGIN-TOP: 0px"><FONT class=extract>Unlike<SPAN>&nbsp;</SPAN><CODE class=command style="BOX-SIZING: border-box; FONT-SIZE: 1em; FONT-FAMILY: monospace, monospace; MARGIN-TOP: 0px; FONT-WEIGHT: 400; COLOR:  !important; MARGIN-LEFT: 0px; MARGIN-RIGHT: 0px; overflow-wrap: break-word; border-radius: 0.25rem">VACUUM</CODE>, bottom-up index deletion does not provide any strong guarantees about how old the oldest garbage index tuple may be. No index can be permitted to retain<SPAN>&nbsp;</SPAN><SPAN class=quote style="BOX-SIZING: border-box">&#8220;<SPAN class=quote style="BOX-SIZING: border-box">floating garbage</SPAN>&#8221;</SPAN><SPAN>&nbsp;</SPAN>index tuples that became dead prior to a conservative cutoff point shared by the table and all of its indexes collectively. This fundamental table-level invariant makes it safe to recycle table<SPAN>&nbsp;</SPAN><ACRONYM class=acronym style="BOX-SIZING: border-box">TID</ACRONYM>s. This is how it is possible for distinct logical rows to reuse the same table<SPAN>&nbsp;</SPAN><ACRONYM class=acronym style="BOX-SIZING: border-box">TID</ACRONYM><SPAN>&nbsp;</SPAN>over time (though this can never happen with two logical rows whose lifetimes span the same<SPAN>&nbsp;</SPAN><CODE class=command style="BOX-SIZING: border-box; FONT-SIZE: 1em; FONT-FAMILY: monospace, monospace; MARGIN-TOP: 0px; FONT-WEIGHT: 400; COLOR:  !important; MARGIN-LEFT: 0px; MARGIN-RIGHT: 0px; overflow-wrap: break-word; border-radius: 0.25rem">VACUUM</CODE><SPAN>&nbsp;</SPAN>cycle).</FONT></P></DIV>
<DIV id=BTREE-DEDUPLICATION class=sect2 style='BOX-SIZING: border-box; FONT-SIZE: 14px; FONT-FAMILY: "Open Sans", sans-serif; WHITE-SPACE: normal; WORD-SPACING: 0px; TEXT-TRANSFORM: none; FONT-WEIGHT: 400; COLOR: rgb(0,0,0); FONT-STYLE: normal; TEXT-ALIGN: left; ORPHANS: 2; WIDOWS: 2; LETTER-SPACING: normal; TEXT-INDENT: 0px; font-variant-ligatures: normal; font-variant-caps: normal; -webkit-text-stroke-width: 0px; text-decoration-thickness: initial; text-decoration-style: initial; text-decoration-color: initial'>
<DIV class=titlepage style="BOX-SIZING: border-box">
<DIV style="BOX-SIZING: border-box">
<DIV style="BOX-SIZING: border-box">
<H3 class=title style='BOX-SIZING: border-box; FONT-SIZE: 1.4em; FONT-FAMILY: "Open Sans", sans-serif; COLOR: ; MARGIN: 1em 0px; DISPLAY: block; LINE-HEIGHT: 1.2'><FONT class=extract>67.4.3.&nbsp;Deduplication<SPAN>&nbsp;</SPAN></FONT><A class=id_link style="BOX-SIZING: border-box; TEXT-DECORATION: none; FONT-WEIGHT: 600; COLOR: ; VISIBILITY: hidden; BACKGROUND-COLOR: transparent; transition: color 0.2s ease-in-out" href="https://www.postgresql.org/docs/current/btree-implementation.html#BTREE-DEDUPLICATION"></A></H3></DIV></DIV></DIV>
<P style="BOX-SIZING: border-box; MARGIN-TOP: 0px"><FONT class=extract>A duplicate is a leaf page tuple (a tuple that points to a table row) where<SPAN>&nbsp;</SPAN><SPAN class=emphasis style="BOX-SIZING: border-box"><EM style="BOX-SIZING: border-box; FONT-STYLE: italic">all</EM></SPAN><SPAN>&nbsp;</SPAN>indexed key columns have values that match corresponding column values from at least one other leaf page tuple in the same index. Duplicate tuples are quite common in practice. B-Tree indexes can use a special, space-efficient representation for duplicates when an optional technique is enabled:<SPAN>&nbsp;</SPAN><EM class=firstterm style="BOX-SIZING: border-box; FONT-STYLE: italic">deduplication</EM>.</FONT></P>
<P style="BOX-SIZING: border-box; MARGIN-TOP: 0px"><FONT class=extract>Deduplication works by periodically merging groups of duplicate tuples together, forming a single<SPAN>&nbsp;</SPAN><EM class=firstterm style="BOX-SIZING: border-box; FONT-STYLE: italic">posting list</EM><SPAN>&nbsp;</SPAN>tuple for each group. The column key value(s) only appear once in this representation. This is followed by a sorted array of<SPAN>&nbsp;</SPAN><ACRONYM class=acronym style="BOX-SIZING: border-box">TID</ACRONYM>s that point to rows in the table. This significantly reduces the storage size of indexes where each value (or each distinct combination of column values) appears several times on average. The latency of queries can be reduced significantly. Overall query throughput may increase significantly. The overhead of routine index vacuuming may also be reduced significantly.</FONT></P>
<DIV class=note style="BOX-SIZING: border-box; BORDER-TOP: 1px solid; BORDER-RIGHT: 1px solid; BORDER-BOTTOM: 1px solid; PADDING-TOP: 1px; PADDING-LEFT: 1px; BORDER-LEFT: 1px solid; MARGIN: 4ex auto; PADDING-RIGHT: 1px; border-radius: 8px">
<H3 class=title style='BOX-SIZING: border-box; FONT-SIZE: 1.4em; FONT-FAMILY: "Open Sans", sans-serif; MARGIN-TOP: 0px; COLOR: ; TEXT-ALIGN: center; MARGIN-LEFT: 0px; DISPLAY: block; LINE-HEIGHT: 1.2; MARGIN-RIGHT: 0px'><FONT class=extract>Note</FONT></H3>
<P style="BOX-SIZING: border-box; MARGIN-BOTTOM: 0px !important; MARGIN-TOP: 0px"><FONT class=extract>B-Tree deduplication is just as effective with<SPAN>&nbsp;</SPAN><SPAN class=quote style="BOX-SIZING: border-box">&#8220;<SPAN class=quote style="BOX-SIZING: border-box">duplicates</SPAN>&#8221;</SPAN><SPAN>&nbsp;</SPAN>that contain a NULL value, even though NULL values are never equal to each other according to the<SPAN>&nbsp;</SPAN><CODE class=literal style="BOX-SIZING: border-box; FONT-SIZE: 1em; BORDER-TOP: medium none; FONT-FAMILY: monospace, monospace; BORDER-RIGHT: medium none; MARGIN-TOP: 0px; BORDER-BOTTOM: medium none; FONT-WEIGHT: 400; COLOR:  !important; PADDING-BOTTOM: 0px !important; PADDING-TOP: 0px !important; PADDING-LEFT: 0px !important; MARGIN-LEFT: 0px; BORDER-LEFT: medium none; PADDING-RIGHT: 0px !important; MARGIN-RIGHT: 0px; overflow-wrap: break-word; border-radius: 0.25rem">=</CODE><SPAN>&nbsp;</SPAN>member of any B-Tree operator class. As far as any part of the implementation that understands the on-disk B-Tree structure is concerned, NULL is just another value from the domain of indexed values.</FONT></P></DIV>
<P style="BOX-SIZING: border-box; MARGIN-TOP: 0px"><FONT class=extract>The deduplication process occurs lazily, when a new item is inserted that cannot fit on an existing leaf page, though only when index tuple deletion could not free sufficient space for the new item (typically deletion is briefly considered and then skipped over). Unlike GIN posting list tuples, B-Tree posting list tuples do not need to expand every time a new duplicate is inserted; they are merely an alternative physical representation of the original logical contents of the leaf page. This design prioritizes consistent performance with mixed read-write workloads. Most client applications will at least see a moderate performance benefit from using deduplication. Deduplication is enabled by default.</FONT></P>
<P style="BOX-SIZING: border-box; MARGIN-TOP: 0px"><FONT class=extract><CODE class=command style="BOX-SIZING: border-box; FONT-SIZE: 1em; FONT-FAMILY: monospace, monospace; MARGIN-TOP: 0px; FONT-WEIGHT: 400; COLOR:  !important; MARGIN-LEFT: 0px; MARGIN-RIGHT: 0px; overflow-wrap: break-word; border-radius: 0.25rem">CREATE INDEX</CODE><SPAN>&nbsp;</SPAN>and<SPAN>&nbsp;</SPAN><CODE class=command style="BOX-SIZING: border-box; FONT-SIZE: 1em; FONT-FAMILY: monospace, monospace; MARGIN-TOP: 0px; FONT-WEIGHT: 400; COLOR:  !important; MARGIN-LEFT: 0px; MARGIN-RIGHT: 0px; overflow-wrap: break-word; border-radius: 0.25rem">REINDEX</CODE><SPAN>&nbsp;</SPAN>apply deduplication to create posting list tuples, though the strategy they use is slightly different. Each group of duplicate ordinary tuples encountered in the sorted input taken from the table is merged into a posting list tuple<SPAN>&nbsp;</SPAN><SPAN class=emphasis style="BOX-SIZING: border-box"><EM style="BOX-SIZING: border-box; FONT-STYLE: italic">before</EM></SPAN><SPAN>&nbsp;</SPAN>being added to the current pending leaf page. Individual posting list tuples are packed with as many<SPAN>&nbsp;</SPAN><ACRONYM class=acronym style="BOX-SIZING: border-box">TID</ACRONYM>s as possible. Leaf pages are written out in the usual way, without any separate deduplication pass. This strategy is well-suited to<SPAN>&nbsp;</SPAN><CODE class=command style="BOX-SIZING: border-box; FONT-SIZE: 1em; FONT-FAMILY: monospace, monospace; MARGIN-TOP: 0px; FONT-WEIGHT: 400; COLOR:  !important; MARGIN-LEFT: 0px; MARGIN-RIGHT: 0px; overflow-wrap: break-word; border-radius: 0.25rem">CREATE INDEX</CODE><SPAN>&nbsp;</SPAN>and<SPAN>&nbsp;</SPAN><CODE class=command style="BOX-SIZING: border-box; FONT-SIZE: 1em; FONT-FAMILY: monospace, monospace; MARGIN-TOP: 0px; FONT-WEIGHT: 400; COLOR:  !important; MARGIN-LEFT: 0px; MARGIN-RIGHT: 0px; overflow-wrap: break-word; border-radius: 0.25rem">REINDEX</CODE><SPAN>&nbsp;</SPAN>because they are once-off batch operations.</FONT></P>
<P style="BOX-SIZING: border-box; MARGIN-TOP: 0px"><FONT class=extract>Write-heavy workloads that don't benefit from deduplication due to having few or no duplicate values in indexes will incur a small, fixed performance penalty (unless deduplication is explicitly disabled). The<SPAN>&nbsp;</SPAN><CODE class=literal style="BOX-SIZING: border-box; FONT-SIZE: 1em; FONT-FAMILY: monospace, monospace; MARGIN-TOP: 0px; FONT-WEIGHT: 400; COLOR:  !important; MARGIN-LEFT: 0px; MARGIN-RIGHT: 0px; overflow-wrap: break-word; border-radius: 0.25rem">deduplicate_items</CODE><SPAN>&nbsp;</SPAN>storage parameter can be used to disable deduplication within individual indexes. There is never any performance penalty with read-only workloads, since reading posting list tuples is at least as efficient as reading the standard tuple representation. Disabling deduplication isn't usually helpful.</FONT></P>
<P style="BOX-SIZING: border-box; MARGIN-TOP: 0px"><FONT class=extract>It is sometimes possible for unique indexes (as well as unique constraints) to use deduplication. This allows leaf pages to temporarily<SPAN>&nbsp;</SPAN><SPAN class=quote style="BOX-SIZING: border-box">&#8220;<SPAN class=quote style="BOX-SIZING: border-box">absorb</SPAN>&#8221;</SPAN><SPAN>&nbsp;</SPAN>extra version churn duplicates. Deduplication in unique indexes augments bottom-up index deletion, especially in cases where a long-running transaction holds a snapshot that blocks garbage collection. The goal is to buy time for the bottom-up index deletion strategy to become effective again. Delaying page splits until a single long-running transaction naturally goes away can allow a bottom-up deletion pass to succeed where an earlier deletion pass failed.</FONT></P>
<DIV class=tip style="BOX-SIZING: border-box; BORDER-TOP: 1px solid; BORDER-RIGHT: 1px solid; BORDER-BOTTOM: 1px solid; PADDING-TOP: 1px; PADDING-LEFT: 1px; BORDER-LEFT: 1px solid; MARGIN: 4ex auto; PADDING-RIGHT: 1px; border-radius: 8px">
<H3 class=title style='BOX-SIZING: border-box; FONT-SIZE: 1.4em; FONT-FAMILY: "Open Sans", sans-serif; MARGIN-TOP: 0px; COLOR: ; TEXT-ALIGN: center; MARGIN-LEFT: 0px; DISPLAY: block; LINE-HEIGHT: 1.2; MARGIN-RIGHT: 0px'><FONT class=extract>Tip</FONT></H3>
<P style="BOX-SIZING: border-box; MARGIN-BOTTOM: 0px !important; MARGIN-TOP: 0px"><FONT class=extract>A special heuristic is applied to determine whether a deduplication pass in a unique index should take place. It can often skip straight to splitting a leaf page, avoiding a performance penalty from wasting cycles on unhelpful deduplication passes. If you're concerned about the overhead of deduplication, consider setting<SPAN>&nbsp;</SPAN><CODE class=literal style="BOX-SIZING: border-box; FONT-SIZE: 1em; BORDER-TOP: medium none; FONT-FAMILY: monospace, monospace; BORDER-RIGHT: medium none; MARGIN-TOP: 0px; BORDER-BOTTOM: medium none; FONT-WEIGHT: 400; COLOR:  !important; PADDING-BOTTOM: 0px !important; PADDING-TOP: 0px !important; PADDING-LEFT: 0px !important; MARGIN-LEFT: 0px; BORDER-LEFT: medium none; PADDING-RIGHT: 0px !important; MARGIN-RIGHT: 0px; overflow-wrap: break-word; border-radius: 0.25rem">deduplicate_items = off</CODE><SPAN>&nbsp;</SPAN>selectively. Leaving deduplication enabled in unique indexes has little downside.</FONT></P></DIV>
<P style="BOX-SIZING: border-box; MARGIN-TOP: 0px"><FONT class=extract>Deduplication cannot be used in all cases due to implementation-level restrictions. Deduplication safety is determined when<SPAN>&nbsp;</SPAN><CODE class=command style="BOX-SIZING: border-box; FONT-SIZE: 1em; FONT-FAMILY: monospace, monospace; MARGIN-TOP: 0px; FONT-WEIGHT: 400; COLOR:  !important; MARGIN-LEFT: 0px; MARGIN-RIGHT: 0px; overflow-wrap: break-word; border-radius: 0.25rem">CREATE INDEX</CODE><SPAN>&nbsp;</SPAN>or<SPAN>&nbsp;</SPAN><CODE class=command style="BOX-SIZING: border-box; FONT-SIZE: 1em; FONT-FAMILY: monospace, monospace; MARGIN-TOP: 0px; FONT-WEIGHT: 400; COLOR:  !important; MARGIN-LEFT: 0px; MARGIN-RIGHT: 0px; overflow-wrap: break-word; border-radius: 0.25rem">REINDEX</CODE><SPAN>&nbsp;</SPAN>is run.</FONT></P>
<P style="BOX-SIZING: border-box; MARGIN-TOP: 0px"><FONT class=extract>Note that deduplication is deemed unsafe and cannot be used in the following cases involving semantically significant differences among equal datums:</FONT></P>
<DIV class=itemizedlist style="BOX-SIZING: border-box">
<UL class=itemizedlist style="LIST-STYLE-TYPE: disc; BOX-SIZING: border-box; MARGIN-TOP: 0px">
<LI class=listitem style="BOX-SIZING: border-box">
<P style="BOX-SIZING: border-box; MARGIN-TOP: 0px; MARGIN-LEFT: 0px !important"><FONT class=extract><CODE class=type style="BOX-SIZING: border-box; FONT-SIZE: 1em; FONT-FAMILY: monospace, monospace; MARGIN-TOP: 0px; FONT-WEIGHT: 400; COLOR:  !important; MARGIN-LEFT: 0px; MARGIN-RIGHT: 0px; overflow-wrap: break-word; border-radius: 0.25rem">text</CODE>,<SPAN>&nbsp;</SPAN><CODE class=type style="BOX-SIZING: border-box; FONT-SIZE: 1em; FONT-FAMILY: monospace, monospace; MARGIN-TOP: 0px; FONT-WEIGHT: 400; COLOR:  !important; MARGIN-LEFT: 0px; MARGIN-RIGHT: 0px; overflow-wrap: break-word; border-radius: 0.25rem">varchar</CODE>, and<SPAN>&nbsp;</SPAN><CODE class=type style="BOX-SIZING: border-box; FONT-SIZE: 1em; FONT-FAMILY: monospace, monospace; MARGIN-TOP: 0px; FONT-WEIGHT: 400; COLOR:  !important; MARGIN-LEFT: 0px; MARGIN-RIGHT: 0px; overflow-wrap: break-word; border-radius: 0.25rem">char</CODE><SPAN>&nbsp;</SPAN>cannot use deduplication when a<SPAN>&nbsp;</SPAN><SPAN class=emphasis style="BOX-SIZING: border-box"><EM style="BOX-SIZING: border-box; FONT-STYLE: italic">nondeterministic</EM></SPAN><SPAN>&nbsp;</SPAN>collation is used. Case and accent differences must be preserved among equal datums.</FONT></P>
<LI class=listitem style="BOX-SIZING: border-box">
<P style="BOX-SIZING: border-box; MARGIN-TOP: 0px; MARGIN-LEFT: 0px !important"><FONT class=extract><CODE class=type style="BOX-SIZING: border-box; FONT-SIZE: 1em; FONT-FAMILY: monospace, monospace; MARGIN-TOP: 0px; FONT-WEIGHT: 400; COLOR:  !important; MARGIN-LEFT: 0px; MARGIN-RIGHT: 0px; overflow-wrap: break-word; border-radius: 0.25rem">numeric</CODE><SPAN>&nbsp;</SPAN>cannot use deduplication. Numeric display scale must be preserved among equal datums.</FONT></P>
<LI class=listitem style="BOX-SIZING: border-box">
<P style="BOX-SIZING: border-box; MARGIN-TOP: 0px; MARGIN-LEFT: 0px !important"><FONT class=extract><CODE class=type style="BOX-SIZING: border-box; FONT-SIZE: 1em; FONT-FAMILY: monospace, monospace; MARGIN-TOP: 0px; FONT-WEIGHT: 400; COLOR:  !important; MARGIN-LEFT: 0px; MARGIN-RIGHT: 0px; overflow-wrap: break-word; border-radius: 0.25rem">jsonb</CODE><SPAN>&nbsp;</SPAN>cannot use deduplication, since the<SPAN>&nbsp;</SPAN><CODE class=type style="BOX-SIZING: border-box; FONT-SIZE: 1em; FONT-FAMILY: monospace, monospace; MARGIN-TOP: 0px; FONT-WEIGHT: 400; COLOR:  !important; MARGIN-LEFT: 0px; MARGIN-RIGHT: 0px; overflow-wrap: break-word; border-radius: 0.25rem">jsonb</CODE><SPAN>&nbsp;</SPAN>B-Tree operator class uses<SPAN>&nbsp;</SPAN><CODE class=type style="BOX-SIZING: border-box; FONT-SIZE: 1em; FONT-FAMILY: monospace, monospace; MARGIN-TOP: 0px; FONT-WEIGHT: 400; COLOR:  !important; MARGIN-LEFT: 0px; MARGIN-RIGHT: 0px; overflow-wrap: break-word; border-radius: 0.25rem">numeric</CODE><SPAN>&nbsp;</SPAN>internally.</FONT></P>
<LI class=listitem style="BOX-SIZING: border-box">
<P style="BOX-SIZING: border-box; MARGIN-TOP: 0px; MARGIN-LEFT: 0px !important"><FONT class=extract><CODE class=type style="BOX-SIZING: border-box; FONT-SIZE: 1em; FONT-FAMILY: monospace, monospace; MARGIN-TOP: 0px; FONT-WEIGHT: 400; COLOR:  !important; MARGIN-LEFT: 0px; MARGIN-RIGHT: 0px; overflow-wrap: break-word; border-radius: 0.25rem">float4</CODE><SPAN>&nbsp;</SPAN>and<SPAN>&nbsp;</SPAN><CODE class=type style="BOX-SIZING: border-box; FONT-SIZE: 1em; FONT-FAMILY: monospace, monospace; MARGIN-TOP: 0px; FONT-WEIGHT: 400; COLOR:  !important; MARGIN-LEFT: 0px; MARGIN-RIGHT: 0px; overflow-wrap: break-word; border-radius: 0.25rem">float8</CODE><SPAN>&nbsp;</SPAN>cannot use deduplication. These types have distinct representations for<SPAN>&nbsp;</SPAN><CODE class=literal style="BOX-SIZING: border-box; FONT-SIZE: 1em; FONT-FAMILY: monospace, monospace; MARGIN-TOP: 0px; FONT-WEIGHT: 400; COLOR:  !important; MARGIN-LEFT: 0px; MARGIN-RIGHT: 0px; overflow-wrap: break-word; border-radius: 0.25rem">-0</CODE><SPAN>&nbsp;</SPAN>and<SPAN>&nbsp;</SPAN><CODE class=literal style="BOX-SIZING: border-box; FONT-SIZE: 1em; FONT-FAMILY: monospace, monospace; MARGIN-TOP: 0px; FONT-WEIGHT: 400; COLOR:  !important; MARGIN-LEFT: 0px; MARGIN-RIGHT: 0px; overflow-wrap: break-word; border-radius: 0.25rem">0</CODE>, which are nevertheless considered equal. This difference must be preserved.</FONT></P></LI></UL></DIV>
<P style="BOX-SIZING: border-box; MARGIN-TOP: 0px"><FONT class=extract>There is one further implementation-level restriction that may be lifted in a future version of<SPAN>&nbsp;</SPAN><SPAN class=productname style="BOX-SIZING: border-box">PostgreSQL</SPAN>:</FONT></P>
<DIV class=itemizedlist style="BOX-SIZING: border-box">
<UL class=itemizedlist style="LIST-STYLE-TYPE: disc; BOX-SIZING: border-box; MARGIN-TOP: 0px">
<LI class=listitem style="BOX-SIZING: border-box">
<P style="BOX-SIZING: border-box; MARGIN-TOP: 0px; MARGIN-LEFT: 0px !important"><FONT class=extract>Container types (such as composite types, arrays, or range types) cannot use deduplication.</FONT></P></LI></UL></DIV>
<P style="BOX-SIZING: border-box; MARGIN-TOP: 0px"><FONT class=extract>There is one further implementation-level restriction that applies regardless of the operator class or collation used:</FONT></P>
<DIV class=itemizedlist style="BOX-SIZING: border-box">
<UL class=itemizedlist style="LIST-STYLE-TYPE: disc; BOX-SIZING: border-box; MARGIN-TOP: 0px">
<LI class=listitem style="BOX-SIZING: border-box">
<P style="BOX-SIZING: border-box; MARGIN-TOP: 0px; MARGIN-LEFT: 0px !important"><FONT class=extract><CODE class=literal style="BOX-SIZING: border-box; FONT-SIZE: 1em; FONT-FAMILY: monospace, monospace; MARGIN-TOP: 0px; FONT-WEIGHT: 400; COLOR:  !important; MARGIN-LEFT: 0px; MARGIN-RIGHT: 0px; overflow-wrap: break-word; border-radius: 0.25rem">INCLUDE</CODE><SPAN>&nbsp;</SPAN>indexes can never use deduplication.</FONT></P></LI></UL></DIV></DIV>